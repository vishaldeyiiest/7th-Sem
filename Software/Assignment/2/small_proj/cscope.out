cscope 15 $HOME/Study/7thSem/Software/Assignment/2/small_proj -c               0000259580
	@Assignment1/lexical_hardcoded.cpp

1 #include 
	~<bits/stdc++.h
>

2 #include 
	~<ctype.h
>

3 #include 
	~"lexical_hardcoded.hpp
"

4 #define 
	#SHOW_DEFINE
(
x
) 
	`fprintf
(
yyout
, "%s - ", #x)

	)

5 #define 
	#ERROR
 777

	)

6 
using
 
namespace
 
	gstd
;

8 
FILE
 *
	gyyin
, *
	gyyout
;

9 char *
	gyyt
;

10 int 
	gyyleng
, 
	gflag_sub
;

12 int 
yylex
();

13 int 
	$isReserved
(char 
a
[])

15 if(!
	`strcmp
(
a
, "for"))

16 return 
FOR_TOK
;

17 if(!
	`strcmp
(
a
, "switch"))

18 return 
SWITCH_TOK
;

20 if(!
	`strcmp
(
a
, "case"))

21 return 
CASE_TOK
;

22 if(!
	`strcmp
(
a
, "if"))

23 return 
IF_TOK
;

24 if(!
	`strcmp
(
a
, "else"))

25 return 
ELSE_TOK
;

26 if(!
	`strcmp
(
a
, "void"))

27 return 
VOID_TOK
;

29 return 
ID_TOK
;

30 
	}
}

32 int 
	$check_operator
(char 
a
[])

34 if(!
	`strcmp
(
a
, ">="))

35 return 
GTEQ_TOK
;

36 if(!
	`strcmp
(
a
, "<="))

37 return 
LSEQ_TOK
;

38 if(!
	`strcmp
(
a
, "=="))

39 return 
EQ2_TOK
;

40 if(!
	`strcmp
(
a
, "!="))

41 return 
NOTEQ_TOK
;

42 if(!
	`strcmp
(
a
, "+="))

43 return 
ADDEQ_TOK
;

44 if(!
	`strcmp
(
a
, "-="))

45 return 
MINEQ_TOK
;

46 if(!
	`strcmp
(
a
, "*="))

47 return 
MULTEQ_TOK
;

48 if(!
	`strcmp
(
a
, "/="))

49 return 
DIVEQ_TOK
;

50 if(!
	`strcmp
(
a
, "%="))

51 return 
MODEQ_TOK
;

52 if(!
	`strcmp
(
a
, "&="))

53 return 
BITANDEQ_TOK
;

54 if(!
	`strcmp
(
a
, "|="))

55 return 
BITOREQ_TOK
;

56 if(!
	`strcmp
(
a
, "^="))

57 return 
BITXOREQ_TOK
;

58 if(!
	`strcmp
(
a
, "&&"))

59 return 
AND_TOK
;

60 if(!
	`strcmp
(
a
, "||"))

61 return 
OR_TOK
;

62 if(!
	`strcmp
(
a
, "++"))

63 return 
INC_TOK
;

64 if(!
	`strcmp
(
a
, "--"))

65 return 
DEC_TOK
;

67 
	}
}

69 int 
	$main
(int 
argc
, char *
argv
[])

71 int 
token
;

72 if(
argc
 != 3)

74 
	`fprintf
(
stderr
, "Usage: <input file> <output file>\n");

75 
	`exit
(1);

79 
yyin
 = 
	`fopen
(
argv
[1], "r");

80 
yyout
 = 
	`fopen
(
argv
[2], "w");

81 while(!
	`feof
(
yyin
))

83 
token
 = 
	`yylex
();

84 
	`fprintf
(
yyout
, "%d\n", 
token
);

87 
	`fclose
(
yyin
);

88 
	`fclose
(
yyout
);

89 
	}
}

93 int 
	$yylex
()

95 char 
c
;

96 
yyin
 = 
stdin
;

97 
c
 = 
	`getc
(
yyin
);

98 while(
	`isspace
(
c
))

99 
c
 = 
	`getc
(
yyin
);

101 switch(
c
)

111 
yyt
[0] = 
c
;

112 
yyleng
 = 1;

113 
	`printf
("%c\n", 
c
);

114 return 
c
;

120 char 
ch
 = 
	`getc
(
yyin
);

121 if(
ch
 == '=' 
or
 ch == 
c
)

123 
yyt
 = (char*)
	`malloc
(2*sizeof(char));

124 
yyt
[0] = 
c
; yyt[1] = 
ch
;

125 
yyleng
 = 2;

126 
	`printf
("%s\n", 
yyt
);

127 return 
	`check_operator
(
yyt
);

131 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

132 
yyt
[0] = 
c
;

133 
yyleng
 = 1;

134 
	`printf
("%c\n", 
c
);

135 return 
c
;

141 char 
ch
 = 
	`getc
(
yyin
);

142 if(
ch
 == '=' 
or
 ch == 
c
)

144 
yyt
 = (char*)
	`malloc
(2*sizeof(char));

145 
yyt
[0] = 
c
; yyt[1] = 
ch
;

146 
yyleng
 = 2;

147 
	`printf
("%s\n", 
yyt
);

148 return 
MINEQ_TOK
;

151 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

153 int 
l
 = 0;

154 0
_sub
 = 0;

155 
	`fseek
(
yyin
, -2, 
SEEK_CUR
);

156 char 
prev
 = 
	`getc
(
yyin
);

159 while(
	`isspace
(
prev
))

161 
l
++;

162 
	`fseek
(
yyin
, -
l
, 
SEEK_CUR
);

163 
prev
 = 
	`getc
(
yyin
);

165 
	`fseek
(
yyin
, 
l
, 
SEEK_CUR
);

166 
c
 = 
	`getc
(
yyin
);

167 while(
	`isspace
(
c
))

168 
c
 = 
	`getc
(
yyin
);

171 if((
prev
 == '=' || prev == '(') && (
	`isalpha
(
c
) || 
	`isdigit
(c)))

173 int 
len
 = 0, 
temp
 = 0, 
flag
 = 0;

174 if(
	`isdigit
(
c
))

176 
flag
 = 1;

177 while(
	`isdigit
(
c
))

179 
len
++;

180 
temp
 = temp*10+
c
-'0';

181 
c
 = 
	`getc
(
yyin
);

184 if(
	`isalpha
(
c
))

186 while(
	`isalnum
(
c
))

187 
len
++, 
c
 = 
	`getc
(
yyin
);

189 
len
++;

190 
	`fseek
(
yyin
, -
len
, 
SEEK_CUR
);

191 
yyt
 = (char*)
	`malloc
(
len
*sizeof(char));

192 
yyt
[
yyleng
++] = '-';

193 while(
len
--)

194 
yyt
[
yyleng
++] = 
	`getc
(
yyin
);

195 if(
flag
)

197 
	`printf
("-%d\n", 
temp
);

198 return -
temp
;

202 
	`printf
("%s\n", 
yyt
);

203 return 
ID_TOK
;

208 
yyt
[0] = 
c
;

209 
yyleng
 = 1;

210 
	`printf
("%c\n", 
c
);

211 return 
c
;

225 char 
ch
 = 
	`getc
(
yyin
);

226 if(
ch
 == '=' || (ch == 
c
 && c == '+'))

228 
yyt
 = (char*)
	`malloc
(2*sizeof(char));

229 
yyt
[0] = 
c
; yyt[1] = 
ch
;

230 
yyleng
 = 2;

231 
	`printf
("%s\n", 
yyt
);

232 return 
	`check_operator
(
yyt
);

236 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

237 
yyt
[0] = 
c
;

238 
yyleng
 = 1;

239 
	`printf
("%c\n", 
c
);

240 return 
c
;

256 int 
len
 = 0, 
error_flag
 = 0;

257 char 
ch
 = 
c
;

258 while(
	`isdigit
(
ch
))

260 
len
++;

261 
ch
 = 
	`getc
(
yyin
);

263 if(
	`isalpha
(
ch
))

265 
error_flag
 = 1;

266 while(
	`isalnum
(
ch
))

267 
len
++, 
ch
 = 
	`getc
(
yyin
);

269 
	`fseek
(
yyin
, -
len
, 
SEEK_CUR
);

270 
yyt
 = (char*)
	`malloc
(
len
*sizeof(char));

271 
	`memset
(
yyt
, '\0', 
len
*sizeof(char));

273 
ch
 = 
c
;

274 int 
temp
 = 0;

275 while(
	`isdigit
(
ch
))

277 
yyt
[
yyleng
] = 
ch
;

278 
yyleng
++;

279 
temp
 = temp*10+
ch
-'0';

280 
ch
 = 
	`getc
(
yyin
);

282 if(
	`isalpha
(
ch
))

284 while(
	`isalnum
(
ch
))

286 
yyt
[
yyleng
] = 
ch
;

287 
yyleng
++;

288 
ch
 = 
	`getc
(
yyin
);

292 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

293 if(
error_flag
)

295 
	`printf
("%d\n", 
ERROR
);

296 return 
ERROR
;

298 
	`printf
("%s\n", 
yyt
);

299 return 
temp
;

326 if(
	`isalpha
(
c
))

328 int 
upp
 = 1;

329 if(
	`islower
(
c
))

330 
upp
 = 0;

332 int 
len
 = 0;

333 char 
ch
 = 
c
;

334 while(
	`isalnum
(
ch
))

336 
len
++;

337 
ch
 = 
	`getc
(
yyin
);

340 
	`fseek
(
yyin
, -
len
, 
SEEK_CUR
);

341 
yyt
 = (char*)
	`malloc
(
len
*sizeof(char));

342 
	`memset
(
yyt
, '\0', 
len
*sizeof(char));

344 while(
	`isalnum
(
c
))

346 
yyt
[
yyleng
++] = 
c
;

347 
c
 = 
	`getc
(
yyin
);

349 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

350 
	`printf
("%s\n", 
yyt
);

351 if(
upp
)

353 return 
ID_TOK
;

355 return 
	`isReserved
(
yyt
);

359 
	}
}

	@Assignment1/lexical_hardcoded.hpp

2 #define 
	#LPAREN_TOK
 '('

	)

3 #define 
	#RPAREN_TOK
 ')'

	)

4 #define 
	#GT_TOK
 '>'

	)

5 #define 
	#LS_TOK
 '<'

	)

6 #define 
	#EQ_TOK
 '='

	)

7 #define 
	#MINUS_TOK
 '-'

	)

8 #define 
	#ADDITION_TOK
 '+'

	)

9 #define 
	#MULTI_TOK
 '*'

	)

10 #define 
	#DIVISION_TOK
 '/'

	)

11 #define 
	#MOD_TOK
 '%'

	)

12 #define 
	#LCURLY_TOK
 '{'

	)

13 #define 
	#RCURLY_TOK
 '}'

	)

14 #define 
	#BITOR_TOK
 '|'

	)

15 #define 
	#BITAND_TOK
 '&'

	)

16 #define 
	#XOR_TOK
 '^'

	)

17 #define 
	#NOT_TOK
 '!'

	)

18 #define 
	#COMMA_TOK
 ','

	)

19 #define 
	#SEMCOL_TOK
 ';'

	)

22 #define 
	#MINEQ_TOK
 300

	)

23 #define 
	#ADDEQ_TOK
 301

	)

24 #define 
	#MODEQ_TOK
 302

	)

25 #define 
	#MULTEQ_TOK
 303

	)

26 #define 
	#DIVEQ_TOK
 304

	)

27 #define 
	#BITANDEQ_TOK
 305

	)

28 #define 
	#BITOREQ_TOK
 306

	)

29 #define 
	#BITXOREQ_TOK
 307

	)

32 #define 
	#FOR_TOK
 256

	)

33 #define 
	#SWITCH_TOK
 257

	)

34 #define 
	#CASE_TOK
 258

	)

35 #define 
	#IF_TOK
 259

	)

36 #define 
	#ELSE_TOK
 260

	)

37 #define 
	#VOID_TOK
 261

	)

40 #define 
	#ID_TOK
 350

	)

42 #define 
	#GTEQ_TOK
 400

	)

43 #define 
	#LSEQ_TOK
 401

	)

44 #define 
	#AND_TOK
 402

	)

45 #define 
	#OR_TOK
 403

	)

46 #define 
	#EQ2_TOK
 404

	)

47 #define 
	#NOTEQ_TOK
 405

	)

49 #define 
	#INC_TOK
 450

	)

50 #define 
	#DEC_TOK
 451

	@Assignment2/lexical_parser.cpp

1 #include 
	~<bits/stdc++.h
>

2 #include 
	~<ctype.h
>

3 #include 
	~"lexical_parser.hpp
"

4 #define 
	#ERROR
 777

	)

5 
using
 
namespace
 
	gstd
;

7 
FILE
 *
	gyyin
, *
	gyyout
;

8 char *
	gyyt
;

9 int 
	gyyleng
;

11 int 
yylex
();

13 int 
	$main
(int 
argc
, char *
argv
[])

15 int 
token
;

16 if(
argc
 != 3)

18 
	`fprintf
(
stderr
, "Usage: <input file> <output file>\n");

19 
	`exit
(1);

23 
yyin
 = 
	`fopen
(
argv
[1], "r");

24 
yyout
 = 
	`fopen
(
argv
[2], "w");

25 while(!
	`feof
(
yyin
))

27 
token
 = 
	`yylex
();

28 
	`printf
("%s %d\n", 
yyt
, 
token
);

29 
	`fprintf
(
yyout
, "%d\n", 
token
);

30 
delete
 
yyt
;

33 
	`fclose
(
yyin
);

34 
	`fclose
(
yyout
);

35 
	}
}

37 char 
	$get_ch
()

39 char 
ch
 = 
	`getc
(
yyin
);

40 while(
	`isspace
(
ch
))

41 
ch
 = 
	`getc
(
yyin
);

42 return 
ch
;

43 
	}
}

45 int 
	$convto_int
(char *
a
)

47 int 
temp
 = 0;

48 for(int 
i
 = 0; i < 
yyleng
; i++)

49 
temp
 = temp*10 + 
yyt
[
i
] - '0';

50 return 
temp
;

51 
	}
}

53 int 
	$yylex
()

55 char 
c
;

56 int 
state
 = 0, 
prev_state
 = 0, 
len
 = 0;

57 
yyleng
 = 0;

58 
yyt
 = (char*)
	`malloc
(256);

59 
	`memset
(
yyt
, '\0', 256);

60 while(!
	`feof
(
yyin
))

62 if(
state
 != -1)

64 
c
 = 
	`getc
(
yyin
);

65 while(
	`isspace
(
c
))

66 
c
 = 
	`getc
(
yyin
);

67 
yyt
[
yyleng
++] = 
c
;

70 switch(
state
)

75 
yyt
[--
yyleng
] = '\0';

76 
state
 = 0;

77 
	`ungetc
(
c
, 
yyin
);

79 if(
prev_state
 == 
INTCONST
)

81 return 
	`convto_int
(
yyt
);

83 return 
prev_state
;

89 if(
c
 == ';')

90 
state
 = 
SEMCOL_TOK
;

91 else if(
c
 == '(')

92 
state
 = 
LPAREN_TOK
;

93 else if(
c
 == ')')

94 
state
 = 
RPAREN_TOK
;

95 else if(
c
 == '{')

96 
state
 = 
LCURLY_TOK
;

97 else if(
c
 == '}')

98 
state
 = 
RCURLY_TOK
;

99 else if(
c
 == ',')

100 
state
 = 
COMMA_TOK
;

101 else if(
c
 == 'f')

102 
state
 = 2;

103 else if(
c
 == 'w')

104 
state
 = 3;

105 else if(
c
 == 'i')

106 
state
 = 4;

107 else if(
c
 == 'e')

108 
state
 = 5;

109 else if((
c
 >= 'a' && c <= 'd') || (c == 'g') || (c == 'h') || (c >= 'j' && c <= 'v') || (c >= 'x' && c <= 'z') || (c >= 'A' && c <= 'Z'))

110 
state
 = 
ID_TOK
;

111 else if(
c
 >= '0' && c <= '9')

112 
state
 = 
INTCONST
;

113 else if(
c
 == '+')

114 
state
 = 
ADDITION_TOK
;

115 else if(
c
 == '-')

116 
state
 = 
MINUS_TOK
;

117 else if(
c
 == '*')

118 
state
 = 
MULTI_TOK
;

119 else if(
c
 == '/')

120 
state
 = 
DIVISION_TOK
;

121 else if(
c
 == '%')

122 
state
 = 
MOD_TOK
;

123 else if(
c
 == '=')

124 
state
 = 
EQ_TOK
;

125 else if(
c
 == '<')

126 
state
 = 
LS_TOK
;

127 else if(
c
 == '>')

128 
state
 = 
GT_TOK
;

129 else if(
c
 == '&')

130 
state
 = 
BITAND_TOK
;

131 else if(
c
 == '|')

132 
state
 = 
BITOR_TOK
;

133 else if(
c
 == '!')

134 
state
 = 
NOT_TOK
;

135 else if(
c
 == '^')

136 
state
 = 
XOR_TOK
;

144 if(
c
 == 'o')

145 
state
 = 20;

147 
prev_state
 = 
ID_TOK
, 
state
 = -1;

157 if(
c
 == 'r')

158 
state
 = 
FOR_TOK
;

160 
prev_state
 = 
ID_TOK
, 
state
 = -1;

167 case 
INTCONST
:

168 if(
c
 >= '0' && c <= '9')

169 
state
 = 
INTCONST
;

170 else if((
c
 >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))

171 return 
ERROR
;

173 
prev_state
 = 
state
, state = -1;

177 case 
FOR_TOK
:

178 case 
WHILE_TOK
:

179 case 
IF_TOK
:

180 case 
ELSE_TOK
:

181 case 
ID_TOK
:

183 if((
c
 >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))

184 
state
 = 
ID_TOK
;

186 
prev_state
 = 
state
,

187 
state
 = -1;

193 if(
c
 == 'h')

194 
state
 = 22;

196 
prev_state
 = 
ID_TOK
, 
state
 = -1;

205 if(
c
 == 'i')

206 
state
 = 23;

208 
prev_state
 = 
ID_TOK
, 
state
 = -1;

217 if(
c
 == 'l')

218 
state
 = 24;

220 
prev_state
 = 
ID_TOK
, 
state
 = -1;

229 if(
c
 == 'e')

230 
state
 = 
WHILE_TOK
;

232 
prev_state
 = 
ID_TOK
, 
state
 = -1;

242 if(
c
 == 'f')

243 
state
 = 
IF_TOK
;

245 
prev_state
 = 
ID_TOK
, 
state
 = -1;

255 if(
c
 == 'l')

256 
state
 = 27;

258 
prev_state
 = 
ID_TOK
, 
state
 = -1;

267 if(
c
 == 's')

268 
state
 = 28;

270 
prev_state
 = 
ID_TOK
, 
state
 = -1;

275 if(
c
 == 'e')

276 
state
 = 
ELSE_TOK
;

278 
prev_state
 = 
ID_TOK
, 
state
 = -1;

286 case 
ADDITION_TOK
:

287 if(
c
 == '+')

288 
state
 = 
INC_TOK
;

289 else if(
c
 == '=')

290 
state
 = 
ADDEQ_TOK
;

292 
prev_state
 = 
state
, state = -1;

296 case 
MINUS_TOK
:

298 if(
c
 == '-')

299 
state
 = 
DEC_TOK
;

300 else if(
c
 == '=')

301 
state
 = 
MINEQ_TOK
;

303 
prev_state
 = 
state
, state = -1;

307 case 
MULTI_TOK
:

309 if(
c
 == '=')

310 
state
 = 
MULTEQ_TOK
;

312 
prev_state
 = 
state
, state = -1;

316 case 
DIVISION_TOK
:

318 if(
c
 == '=')

319 
state
 = 
DIVEQ_TOK
;

321 
prev_state
 = 
state
, state = -1;

325 case 
MOD_TOK
:

327 if(
c
 == '=')

328 
state
 = 
MODEQ_TOK
;

330 
prev_state
 = 
state
, state = -1;

334 case 
BITAND_TOK
:

336 if(
c
 == '=')

337 
state
 = 
BITANDEQ_TOK
;

338 else if(
c
 == '&')

339 
state
 = 
AND_TOK
;

341 
prev_state
 = 
state
, state = -1;

345 case 
BITOR_TOK
:

347 if(
c
 == '=')

348 
state
 = 
BITOREQ_TOK
;

349 else if(
c
 == '|')

350 
state
 = 
OR_TOK
;

352 
prev_state
 = 
state
, state = -1;

356 case 
XOR_TOK
:

358 if(
c
 == '=')

359 
state
 = 
BITXOREQ_TOK
;

361 
prev_state
 = 
state
, state = -1;

365 case 
LS_TOK
:

367 if(
c
 == '=')

368 
state
 = 
LSEQ_TOK
;

369 else if(
c
 == '<')

370 
state
 = 
LSHIFT_TOK
;

372 
prev_state
 = 
state
, state = -1;

376 case 
GT_TOK
:

378 if(
c
 == '=')

379 
state
 = 
GTEQ_TOK
;

380 else if(
c
 == '>')

381 
state
 = 
RSHIFT_TOK
;

383 
prev_state
 = 
state
, state = -1;

387 case 
EQ_TOK
:

389 if(
c
 == '=')

390 
state
 = 
EQ2_TOK
;

392 
prev_state
 = 
state
, state = -1;

396 case 
NOT_TOK
:

398 if(
c
 == '=')

399 
state
 = 
NOTEQ_TOK
;

401 
prev_state
 = 
state
, state = -1;

405 case 
ADDEQ_TOK
:

406 case 
MINEQ_TOK
:

407 case 
MULTEQ_TOK
:

408 case 
MODEQ_TOK
:

409 case 
DIVEQ_TOK
:

410 case 
INC_TOK
:

411 case 
DEC_TOK
:

412 case 
LSEQ_TOK
:

413 case 
GTEQ_TOK
:

414 case 
EQ2_TOK
:

415 case 
NOTEQ_TOK
:

416 case 
LSHIFT_TOK
:

417 case 
RSHIFT_TOK
:

418 case 
LPAREN_TOK
:

419 case 
RPAREN_TOK
:

420 case 
LCURLY_TOK
:

421 case 
RCURLY_TOK
:

422 case 
AND_TOK
:

423 case 
OR_TOK
:

424 case 
SEMCOL_TOK
:

425 case 
COMMA_TOK
:

426 
	`ungetc
(
c
, 
yyin
);

427 
yyt
[--
yyleng
] = '\0';

429 return 
state
;

432 return 
ERROR
;

437 
	}
}

	@Assignment2/lexical_parser.hpp

2 #define 
	#LPAREN_TOK
 '('

	)

3 #define 
	#RPAREN_TOK
 ')'

	)

4 #define 
	#GT_TOK
 '>'

	)

5 #define 
	#LS_TOK
 '<'

	)

6 #define 
	#EQ_TOK
 '='

	)

7 #define 
	#MINUS_TOK
 '-'

	)

8 #define 
	#ADDITION_TOK
 '+'

	)

9 #define 
	#MULTI_TOK
 '*'

	)

10 #define 
	#DIVISION_TOK
 '/'

	)

11 #define 
	#MOD_TOK
 '%'

	)

12 #define 
	#LCURLY_TOK
 '{'

	)

13 #define 
	#RCURLY_TOK
 '}'

	)

14 #define 
	#BITOR_TOK
 '|'

	)

15 #define 
	#BITAND_TOK
 '&'

	)

16 #define 
	#XOR_TOK
 '^'

	)

17 #define 
	#NOT_TOK
 '!'

	)

18 #define 
	#COMMA_TOK
 ','

	)

19 #define 
	#SEMCOL_TOK
 ';'

	)

22 #define 
	#MINEQ_TOK
 300

	)

23 #define 
	#ADDEQ_TOK
 301

	)

24 #define 
	#MODEQ_TOK
 302

	)

25 #define 
	#MULTEQ_TOK
 303

	)

26 #define 
	#DIVEQ_TOK
 304

	)

27 #define 
	#BITANDEQ_TOK
 305

	)

28 #define 
	#BITOREQ_TOK
 306

	)

29 #define 
	#BITXOREQ_TOK
 307

	)

32 #define 
	#FOR_TOK
 256

	)

33 #define 
	#SWITCH_TOK
 257

	)

34 #define 
	#CASE_TOK
 258

	)

35 #define 
	#IF_TOK
 259

	)

36 #define 
	#ELSE_TOK
 260

	)

37 #define 
	#VOID_TOK
 261

	)

38 #define 
	#WHILE_TOK
 262

	)

41 #define 
	#ID_TOK
 350

	)

42 #define 
	#INTCONST
 351

	)

44 #define 
	#GTEQ_TOK
 400

	)

45 #define 
	#LSEQ_TOK
 401

	)

46 #define 
	#AND_TOK
 402

	)

47 #define 
	#OR_TOK
 403

	)

48 #define 
	#EQ2_TOK
 404

	)

49 #define 
	#NOTEQ_TOK
 405

	)

50 #define 
	#LSHIFT_TOK
 406

	)

51 #define 
	#RSHIFT_TOK
 407

	)

53 #define 
	#INC_TOK
 450

	)

54 #define 
	#DEC_TOK
 451

	@Assignment3/a/lex.c

4 #define 
	#YY_INT_ALIGNED
 short int

	)

8 #define 
	#FLEX_SCANNER


	)

9 #define 
	#YY_FLEX_MAJOR_VERSION
 2

	)

10 #define 
	#YY_FLEX_MINOR_VERSION
 6

	)

11 #define 
	#YY_FLEX_SUBMINOR_VERSION
 0

	)

12 #if 
YY_FLEX_SUBMINOR_VERSION
 > 0

13 #define 
	#FLEX_BETA


	)

19 #include 
	~<stdio.h
>

20 #include 
	~<string.h
>

21 #include 
	~<errno.h
>

22 #include 
	~<stdlib.h
>

28 #ifndef 
FLEXINT_H


29 #define 
	#FLEXINT_H


	)

33 #if 
defined
 (
__STDC_VERSION__
) && __STDC_VERSION__ >= 199901L

38 #ifndef 
__STDC_LIMIT_MACROS


39 #define 
	#__STDC_LIMIT_MACROS
 1

	)

42 #include 
	~<inttypes.h
>

43 typedef 
int8_t
 
	tflex_int8_t
;

44 typedef 
uint8_t
 
	tflex_uint8_t
;

45 typedef 
int16_t
 
	tflex_int16_t
;

46 typedef 
uint16_t
 
	tflex_uint16_t
;

47 typedef 
int32_t
 
	tflex_int32_t
;

48 typedef 
uint32_t
 
	tflex_uint32_t
;

50 typedef signed char 
	tflex_int8_t
;

51 typedef short int 
	tflex_int16_t
;

52 typedef int 
	tflex_int32_t
;

53 typedef unsigned char 
	tflex_uint8_t
;

54 typedef unsigned short int 
	tflex_uint16_t
;

55 typedef unsigned int 
	tflex_uint32_t
;

58 #ifndef 
INT8_MIN


59 #define 
	#INT8_MIN
 (-128)

	)

61 #ifndef 
INT16_MIN


62 #define 
	#INT16_MIN
 (-32767-1)

	)

64 #ifndef 
INT32_MIN


65 #define 
	#INT32_MIN
 (-2147483647-1)

	)

67 #ifndef 
INT8_MAX


68 #define 
	#INT8_MAX
 (127)

	)

70 #ifndef 
INT16_MAX


71 #define 
	#INT16_MAX
 (32767)

	)

73 #ifndef 
INT32_MAX


74 #define 
	#INT32_MAX
 (2147483647)

	)

76 #ifndef 
UINT8_MAX


77 #define 
	#UINT8_MAX
 (255U)

	)

79 #ifndef 
UINT16_MAX


80 #define 
	#UINT16_MAX
 (65535U)

	)

82 #ifndef 
UINT32_MAX


83 #define 
	#UINT32_MAX
 (4294967295U)

	)

90 #ifdef 
__cplusplus


93 #define 
	#YY_USE_CONST


	)

98 #if 
defined
 (
__STDC__
)

100 #define 
	#YY_USE_CONST


	)

105 #ifdef 
YY_USE_CONST


106 #define 
	#yyconst
 const

	)

108 #define 
	#yyconst


	)

112 #define 
	#YY_NULL
 0

	)

119 #define 
	#YY_SC_TO_UI
(
c
) ((unsigned int) (unsigned char) c)

	)

125 #define 
	#BEGIN
 (
yy_start
) = 1 + 2 *

	)

131 #define 
	#YY_START
 (((
yy_start
) - 1) / 2)

	)

132 #define 
	#YYSTATE
 
YY_START


	)

135 #define 
	#YY_STATE_EOF
(
state
) (
YY_END_OF_BUFFER
 + state + 1)

	)

138 #define 
	#YY_NEW_FILE
 
	`yyrestart
(
yyin
 )

	)

140 #define 
	#YY_END_OF_BUFFER_CHAR
 0

	)

143 #ifndef 
YY_BUF_SIZE


144 #ifdef 
__ia64__


149 #define 
	#YY_BUF_SIZE
 32768

	)

151 #define 
	#YY_BUF_SIZE
 16384

	)

157 #define 
	#YY_STATE_BUF_SIZE
 ((
YY_BUF_SIZE
 + 2) * sizeof(
yy_state_type
))

	)

159 #ifndef 
YY_TYPEDEF_YY_BUFFER_STATE


160 #define 
	#YY_TYPEDEF_YY_BUFFER_STATE


	)

161 typedef struct 
yy_buffer_state
 *
	tYY_BUFFER_STATE
;

164 #ifndef 
YY_TYPEDEF_YY_SIZE_T


165 #define 
	#YY_TYPEDEF_YY_SIZE_T


	)

166 typedef 
size_t
 
	tyy_size_t
;

169 extern 
yy_size_t
 
yyleng
;

171 extern 
FILE
 *
yyin
, *
yyout
;

173 #define 
	#EOB_ACT_CONTINUE_SCAN
 0

	)

174 #define 
	#EOB_ACT_END_OF_FILE
 1

	)

175 #define 
	#EOB_ACT_LAST_MATCH
 2

	)

177 #define 
	#YY_LESS_LINENO
(
n
)

	)

178 #define 
	#YY_LINENO_REWIND_TO
(
ptr
)

	)

181 #define 
	#yyless
(
n
) \

185 int 
yyless_macro_arg
 = (
n
); \

186 
	`YY_LESS_LINENO
(
yyless_macro_arg
);\

187 *
yy_cp
 = (
yy_hold_char
); \

188 
YY_RESTORE_YY_MORE_OFFSET
 \

189 (
yy_c_buf_p
) = 
yy_cp
 = 
yy_bp
 + 
yyless_macro_arg
 - 
YY_MORE_ADJ
; \

190 
YY_DO_BEFORE_ACTION
; \

192 while ( 0 )

	)

194 #define 
	#unput
(
c
) 
	`yyunput
( c, (
yyt_ptr
) )

	)

196 #ifndef 
YY_STRUCT_YY_BUFFER_STATE


197 #define 
	#YY_STRUCT_YY_BUFFER_STATE


	)

198 struct 
	syy_buffer_state


200 
FILE
 *
	myy_input_file
;

202 char *
	myy_ch_buf
;

203 char *
	myy_buf_pos
;

208 
yy_size_t
 
	myy_buf_size
;

213 int 
	myy_n_chars
;

219 int 
	myy_is_our_buffer
;

226 int 
	myy_is_interactive
;

232 int 
	myy_at_bol
;

234 int 
	myy_bs_lineno
;

235 int 
	myy_bs_column
;

240 int 
	myy_fill_buffer
;

242 int 
	myy_buffer_status
;

244 #define 
	#YY_BUFFER_NEW
 0

	)

245 #define 
	#YY_BUFFER_NORMAL
 1

	)

256 #define 
	#YY_BUFFER_EOF_PENDING
 2

	)

262 static 
size_t
 
	gyy_buffer_stack_top
 = 0;

263 static 
size_t
 
	gyy_buffer_stack_max
 = 0;

264 static 
YY_BUFFER_STATE
 * 
	gyy_buffer_stack
 = 0;

272 #define 
	#YY_CURRENT_BUFFER
 ( (
yy_buffer_stack
) \

273 ? (
yy_buffer_stack
)[(
yy_buffer_stack_top
)] \

274 : 
NULL
)

	)

279 #define 
	#YY_CURRENT_BUFFER_LVALUE
 (
yy_buffer_stack
)[(
yy_buffer_stack_top
)]

	)

282 static char 
	gyy_hold_char
;

283 static int 
	gyy_n_chars
;

284 
yy_size_t
 
	gyyleng
;

287 static char *
	gyy_c_buf_p
 = (char *) 0;

288 static int 
	gyy_init
 = 0;

289 static int 
	gyy_start
 = 0;

294 static int 
	gyy_did_buffer_switch_on_eof
;

296 void 
yyrestart
 (
FILE
 *
input_file
 );

297 void 
yy_switch_to_buffer
 (
YY_BUFFER_STATE
 
new_buffer
 );

298 
YY_BUFFER_STATE
 
yy_create_buffer
 (
FILE
 *
file
,int 
size
 );

299 void 
yy_delete_buffer
 (
YY_BUFFER_STATE
 
b
 );

300 void 
yy_flush_buffer
 (
YY_BUFFER_STATE
 
b
 );

301 void 
yypush_buffer_state
 (
YY_BUFFER_STATE
 
new_buffer
 );

302 void 
yypop_buffer_state
 (void );

304 static void 
yyensure_buffer_stack
 (void );

305 static void 
yy_load_buffer_state
 (void );

306 static void 
yy_init_buffer
 (
YY_BUFFER_STATE
 
b
,
FILE
 *
file
 );

308 #define 
	#YY_FLUSH_BUFFER
 
	`yy_flush_buffer
(
YY_CURRENT_BUFFER
 )

	)

310 
YY_BUFFER_STATE
 
yy_scan_buffer
 (char *
base
,
yy_size_t
 
size
 );

311 
YY_BUFFER_STATE
 
yy_scan_string
 (
yyconst
 char *
yy_str
 );

312 
YY_BUFFER_STATE
 
yy_scan_bytes
 (
yyconst
 char *
bytes
,
yy_size_t
 
len
 );

314 void *
yyalloc
 (
yy_size_t
 );

315 void *
yyrealloc
 (void *,
yy_size_t
 );

316 void 
yyfree
 (void * );

318 #define 
	#yy_new_buffer
 
yy_create_buffer


	)

320 #define 
	#yy_set_interactive
(
is_interactive
) \

322 if ( ! 
YY_CURRENT_BUFFER
 ){ \

323 
	`yyensure_buffer_stack
 (); \

324 
YY_CURRENT_BUFFER_LVALUE
 = \

325 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 ); \

327 
YY_CURRENT_BUFFER_LVALUE
->
yy_is_interactive
 = 
is_interactive
; \

328 }

	)

330 #define 
	#yy_set_bol
(
at_bol
) \

332 if ( ! 
YY_CURRENT_BUFFER
 ){\

333 
	`yyensure_buffer_stack
 (); \

334 
YY_CURRENT_BUFFER_LVALUE
 = \

335 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 ); \

337 
YY_CURRENT_BUFFER_LVALUE
->
yy_at_bol
 = 
at_bol
; \

338 }

	)

340 #define 
	#YY_AT_BOL
() (
YY_CURRENT_BUFFER_LVALUE
->
yy_at_bol
)

	)

344 typedef unsigned char 
	tYY_CHAR
;

346 
FILE
 *
	gyyin
 = (FILE *) 0, *
	gyyout
 = (FILE *) 0;

348 typedef int 
	tyy_state_type
;

350 extern int 
yylineno
;

352 int 
	gyylineno
 = 1;

354 extern char *
yyt
;

355 #ifdef 
yyt_ptr


356 #undef 
yyt_ptr


358 #define 
	#yyt_ptr
 
yyt


	)

360 static 
yy_state_type
 
yy_get_previous_state
 (void );

361 static 
yy_state_type
 
yy_try_NUL_trans
 (yy_state_type 
current_state
 );

362 static int 
yy_get_next_buffer
 (void );

363 #if 
defined
(
__GNUC__
) && __GNUC__ >= 3

364 
__attribute__
((
__noreturn__
))

366 static void 
yy_fatal_error
 (
yyconst
 char 
msg
[] );

371 #define 
	#YY_DO_BEFORE_ACTION
 \

372 (
yyt_ptr
) = 
yy_bp
; \

373 
yyleng
 = (
size_t
) (
yy_cp
 - 
yy_bp
); \

374 (
yy_hold_char
) = *
yy_cp
; \

375 *
yy_cp
 = '\0'; \

376 (
yy_c_buf_p
) = 
yy_cp
;

	)

378 #define 
	#YY_NUM_RULES
 53

	)

379 #define 
	#YY_END_OF_BUFFER
 54

	)

382 struct 
	syy_trans_info


384 
flex_int32_t
 
	myy_verify
;

385 
flex_int32_t
 
	myy_nxt
;

387 static 
yyconst
 
flex_int16_t
 
	gyy_accept
[91] =

400 static 
yyconst
 
YY_CHAR
 
	gyy_ec
[256] =

432 static 
yyconst
 
YY_CHAR
 
	gyy_meta
[39] =

440 static 
yyconst
 
flex_uint16_t
 
	gyy_base
[99] =

455 static 
yyconst
 
flex_int16_t
 
	gyy_def
[99] =

470 static 
yyconst
 
flex_uint16_t
 
	gyy_nxt
[155] =

491 static 
yyconst
 
flex_int16_t
 
	gyy_chk
[155] =

512 static 
yy_state_type
 
	gyy_last_accepting_state
;

513 static char *
	gyy_last_accepting_cpos
;

515 extern int 
yy_flex_debug
;

516 int 
	gyy_flex_debug
 = 0;

521 #define 
	#REJECT
 
reject_used_but_not_detected


	)

522 #define 
	#yymore
() 
yymore_used_but_not_detected


	)

523 #define 
	#YY_MORE_ADJ
 0

	)

524 #define 
	#YY_RESTORE_YY_MORE_OFFSET


	)

525 char *
	gyyt
;

528 #include 
	~<stdio.h
>

529 #include 
	~"lexical.hpp
"

532 #define 
	#INITIAL
 0

	)

534 #ifndef 
YY_NO_UNISTD_H


539 #include 
	~<unistd.h
>

542 #ifndef 
YY_EXTRA_TYPE


543 #define 
	#YY_EXTRA_TYPE
 void *

	)

546 static int 
yy_init_globals
 (void );

551 int 
yylex_destroy
 (void );

553 int 
yyget_debug
 (void );

555 void 
yyset_debug
 (int 
debug_flag
 );

557 
YY_EXTRA_TYPE
 
yyget_extra
 (void );

559 void 
yyset_extra
 (
YY_EXTRA_TYPE
 
user_defined
 );

561 
FILE
 *
yyget_in
 (void );

563 void 
yyset_in
 (
FILE
 * 
_in_str
 );

565 
FILE
 *
yyget_out
 (void );

567 void 
yyset_out
 (
FILE
 * 
_out_str
 );

569 
yy_size_t
 
yyget_leng
 (void );

571 char *
yyget_text
 (void );

573 int 
yyget_lineno
 (void );

575 void 
yyset_lineno
 (int 
_line_number
 );

581 #ifndef 
YY_SKIP_YYWRAP


582 #ifdef 
__cplusplus


583 extern "C" int 
yywrap
 (void );

585 extern int 
yywrap
 (void );

589 #ifndef 
YY_NO_UNPUT


591 static void 
yyunput
 (int 
c
,char *
buf_ptr
 );

595 #ifndef 
yyt_ptr


596 static void 
yy_flex_strncpy
 (char *,
yyconst
 char *,int );

599 #ifdef 
YY_NEED_STRLEN


600 static int 
yy_flex_strlen
 (
yyconst
 char * );

603 #ifndef 
YY_NO_INPUT


605 #ifdef 
__cplusplus


606 static int 
yyinput
 (void );

608 static int 
input
 (void );

614 #ifndef 
YY_READ_BUF_SIZE


615 #ifdef 
__ia64__


617 #define 
	#YY_READ_BUF_SIZE
 16384

	)

619 #define 
	#YY_READ_BUF_SIZE
 8192

	)

624 #ifndef 
ECHO


628 #define 
	#ECHO
 do { if (
	`fwrite
( 
yyt
, 
yyleng
, 1, 
yyout
 )) {} } while (0)

	)

634 #ifndef 
YY_INPUT


635 #define 
	#YY_INPUT
(
buf
,
result
,
max_size
) \

636 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_is_interactive
 ) \

638 int 
c
 = '*'; \

639 
size_t
 
n
; \

640 for ( 
n
 = 0; n < 
max_size
 && \

641 (
c
 = 
	`getc
( 
yyin
 )) != 
EOF
 && c != '\n'; ++
n
 ) \

642 
buf
[
n
] = (char) 
c
; \

643 if ( 
c
 == '\n' ) \

644 
buf
[
n
++] = (char) 
c
; \

645 if ( 
c
 == 
EOF
 && 
	`ferror
( 
yyin
 ) ) \

646 
	`YY_FATAL_ERROR
( "input in flex scanner failed" ); \

647 
result
 = 
n
; \

651 
errno
=0; \

652 while ( (
result
 = 
	`fread
(
buf
, 1, 
max_size
, 
yyin
))==0 && 
	`ferror
(yyin)) \

654 if( 
errno
 != 
EINTR
) \

656 
	`YY_FATAL_ERROR
( "input in flex scanner failed" ); \

659 
errno
=0; \

660 
	`clearerr
(
yyin
); \

664 

	)

671 #ifndef 
yyterminate


672 #define 
	#yyterminate
() return 
YY_NULL


	)

676 #ifndef 
YY_START_STACK_INCR


677 #define 
	#YY_START_STACK_INCR
 25

	)

681 #ifndef 
YY_FATAL_ERROR


682 #define 
	#YY_FATAL_ERROR
(
msg
) 
	`yy_fatal_error
( msg )

	)

690 #ifndef 
YY_DECL


691 #define 
	#YY_DECL_IS_OURS
 1

	)

693 extern int 
yylex
 (void);

695 #define 
	#YY_DECL
 int 
	`yylex
 (void)

	)

701 #ifndef 
YY_USER_ACTION


702 #define 
	#YY_USER_ACTION


	)

706 #ifndef 
YY_BREAK


707 #define 
	#YY_BREAK
 break;

	)

710 #define 
	#YY_RULE_SETUP
 \

711 
YY_USER_ACTION


	)

715 
	gYY_DECL


717 
yy_state_type
 
	gyy_current_state
;

718 char *
	gyy_cp
, *
	gyy_bp
;

719 int 
	gyy_act
;

721 if ( !(
	gyy_init
) )

723 (
	gyy_init
) = 1;

725 #ifdef 
YY_USER_INIT


726 
	gYY_USER_INIT
;

729 if ( ! (
	gyy_start
) )

730 (
	gyy_start
) = 1;

732 if ( ! 
	gyyin
 )

733 
	gyyin
 = 
stdin
;

735 if ( ! 
	gyyout
 )

736 
	gyyout
 = 
stdout
;

738 if ( ! 
	gYY_CURRENT_BUFFER
 ) {

739 
yyensure_buffer_stack
 ();

740 
	gYY_CURRENT_BUFFER_LVALUE
 =

741 
yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 );

744 
yy_load_buffer_state
( );

754 
	gyy_cp
 = (
yy_c_buf_p
);

757 *
	gyy_cp
 = (
yy_hold_char
);

762 
	gyy_bp
 = 
yy_cp
;

764 
	gyy_current_state
 = (
yy_start
);

765 
	gyy_match
:

768 
YY_CHAR
 
yy_c
 = 
yy_ec
[
YY_SC_TO_UI
(*
yy_cp
)] ;

769 if ( 
	gyy_accept
[
yy_current_state
] )

771 (
	gyy_last_accepting_state
) = 
yy_current_state
;

772 (
	gyy_last_accepting_cpos
) = 
yy_cp
;

774 while ( 
	gyy_chk
[
yy_base
[
yy_current_state
] + 
	gyy_c
] != yy_current_state )

776 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

777 if ( 
	gyy_current_state
 >= 91 )

778 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

780 
	gyy_current_state
 = 
yy_nxt
[
yy_base
[
yy_current_state
] + (unsigned int) 
yy_c
];

781 ++
	gyy_cp
;

783 while ( 
	gyy_base
[
yy_current_state
] != 116 );

785 
	gyy_find_action
:

786 
yy_act
 = 
yy_accept
[
yy_current_state
];

787 if ( 
	gyy_act
 == 0 )

789 
yy_cp
 = (
yy_last_accepting_cpos
);

790 
	gyy_current_state
 = (
yy_last_accepting_state
);

791 
	gyy_act
 = 
yy_accept
[
yy_current_state
];

794 
	gYY_DO_BEFORE_ACTION
;

796 
	gdo_action
:

798 switch ( 
yy_act
 )

802 *
yy_cp
 = (
yy_hold_char
);

803 
	gyy_cp
 = (
yy_last_accepting_cpos
);

804 
	gyy_current_state
 = (
yy_last_accepting_state
);

805 goto 
	gyy_find_action
;

808 
YY_RULE_SETUP


811 
YY_BREAK


814 
YY_RULE_SETUP


817 
YY_BREAK


819 
YY_RULE_SETUP


821 {
ECHO
; 
printf
("Unterminated comment\n"); }

822 
YY_BREAK


824 
YY_RULE_SETUP


826 {return 
FOR_TOK
;}

827 
YY_BREAK


829 
YY_RULE_SETUP


831 {return 
WHILE_TOK
;}

832 
YY_BREAK


834 
YY_RULE_SETUP


836 {return 
IF_TOK
;}

837 
YY_BREAK


839 
YY_RULE_SETUP


841 {return 
ELSE_TOK
;}

842 
YY_BREAK


844 
YY_RULE_SETUP


846 {return 
SWITCH_TOK
;}

847 
YY_BREAK


849 
YY_RULE_SETUP


851 {return 
CASE_TOK
;}

852 
YY_BREAK


854 
YY_RULE_SETUP


856 {return 
VOID_TOK
;}

857 
YY_BREAK


859 
YY_RULE_SETUP


861 {return 
LPAREN_TOK
;}

862 
YY_BREAK


864 
YY_RULE_SETUP


866 {return 
RPAREN_TOK
;}

867 
YY_BREAK


869 
YY_RULE_SETUP


871 {return 
GT_TOK
;}

872 
YY_BREAK


874 
YY_RULE_SETUP


876 {return 
LS_TOK
;}

877 
YY_BREAK


879 
YY_RULE_SETUP


881 {return 
EQ_TOK
;}

882 
YY_BREAK


884 
YY_RULE_SETUP


886 {return 
MINUS_TOK
;}

887 
YY_BREAK


889 
YY_RULE_SETUP


891 {return 
ADDITION_TOK
;}

892 
YY_BREAK


894 
YY_RULE_SETUP


896 {return 
MULTI_TOK
;}

897 
YY_BREAK


899 
YY_RULE_SETUP


901 {return 
DIVISION_TOK
;}

902 
YY_BREAK


904 
YY_RULE_SETUP


906 {return 
MOD_TOK
;}

907 
YY_BREAK


909 
YY_RULE_SETUP


911 {return 
LCURLY_TOK
;}

912 
YY_BREAK


914 
YY_RULE_SETUP


916 {return 
RCURLY_TOK
;}

917 
YY_BREAK


919 
YY_RULE_SETUP


921 {return 
BITOR_TOK
;}

922 
YY_BREAK


924 
YY_RULE_SETUP


926 {return 
BITAND_TOK
;}

927 
YY_BREAK


929 
YY_RULE_SETUP


931 {return 
XOR_TOK
;}

932 
YY_BREAK


934 
YY_RULE_SETUP


936 {return 
NOT_TOK
;}

937 
YY_BREAK


939 
YY_RULE_SETUP


941 {return 
COMMA_TOK
;}

942 
YY_BREAK


944 
YY_RULE_SETUP


946 {return 
SEMCOL_TOK
;}

947 
YY_BREAK


949 
YY_RULE_SETUP


951 {return 
MINEQ_TOK
;}

952 
YY_BREAK


954 
YY_RULE_SETUP


956 {return 
ADDEQ_TOK
;}

957 
YY_BREAK


959 
YY_RULE_SETUP


961 {return 
MODEQ_TOK
;}

962 
YY_BREAK


964 
YY_RULE_SETUP


966 {return 
MULTEQ_TOK
;}

967 
YY_BREAK


969 
YY_RULE_SETUP


971 {return 
DIVEQ_TOK
;}

972 
YY_BREAK


974 
YY_RULE_SETUP


976 {return 
BITANDEQ_TOK
;}

977 
YY_BREAK


979 
YY_RULE_SETUP


981 {return 
BITOREQ_TOK
;}

982 
YY_BREAK


984 
YY_RULE_SETUP


986 {return 
BITXOREQ_TOK
;}

987 
YY_BREAK


989 
YY_RULE_SETUP


991 {return 
GTEQ_TOK
;}

992 
YY_BREAK


994 
YY_RULE_SETUP


996 {return 
LSEQ_TOK
;}

997 
YY_BREAK


999 
YY_RULE_SETUP


1001 {return 
AND_TOK
;}

1002 
YY_BREAK


1004 
YY_RULE_SETUP


1006 {return 
OR_TOK
;}

1007 
YY_BREAK


1009 
YY_RULE_SETUP


1011 {return 
EQ2_TOK
;}

1012 
YY_BREAK


1014 
YY_RULE_SETUP


1016 {return 
NOTEQ_TOK
;}

1017 
YY_BREAK


1019 
YY_RULE_SETUP


1021 {return 
LSHIFT_TOK
;}

1022 
YY_BREAK


1024 
YY_RULE_SETUP


1026 {return 
RSHIFT_TOK
;}

1027 
YY_BREAK


1029 
YY_RULE_SETUP


1031 {return 
INC_TOK
;}

1032 
YY_BREAK


1034 
YY_RULE_SETUP


1036 {return 
DEC_TOK
;}

1037 
YY_BREAK


1039 
YY_RULE_SETUP


1041 {return 
INT_TOK
;}

1042 
YY_BREAK


1045 
YY_RULE_SETUP


1048 
YY_BREAK


1050 
YY_RULE_SETUP


1052 {return 
ID_TOK
;}

1053 
YY_BREAK


1055 
YY_RULE_SETUP


1057 {return 
atoi
(
yyt
);}

1058 
YY_BREAK


1060 
YY_RULE_SETUP


1062 {
ECHO
; 
printf
(" - Illegal Identifier\n");}

1063 
YY_BREAK


1065 
YY_RULE_SETUP


1067 {
ECHO
; 
printf
(" - Unknown character\n");}

1068 
YY_BREAK


1070 
YY_RULE_SETUP


1072 
ECHO
;

1073 
	gYY_BREAK


1075 case 
YY_STATE_EOF
(
INITIAL
):

1076 
yyterminate
();

1078 case 
	gYY_END_OF_BUFFER
:

1081 int 
yy_amount_of_matched_text
 = (int) (
yy_cp
 - (
yyt_ptr
)) - 1;

1084 *
	gyy_cp
 = (
yy_hold_char
);

1085 
YY_RESTORE_YY_MORE_OFFSET


1087 if ( 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_buffer_status
 == 
YY_BUFFER_NEW
 )

1098 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->yy_n_chars;

1099 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_input_file
 = 
yyin
;

1100 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_buffer_status
 = 
YY_BUFFER_NORMAL
;

1110 if ( (
	gyy_c_buf_p
) <= &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] )

1112 
yy_state_type
 
yy_next_state
;

1114 (
	gyy_c_buf_p
) = (
yyt_ptr
) + 
yy_amount_of_matched_text
;

1116 
	gyy_current_state
 = 
yy_get_previous_state
( );

1127 
	gyy_next_state
 = 
yy_try_NUL_trans
( 
yy_current_state
 );

1129 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1131 if ( 
	gyy_next_state
 )

1134 
	gyy_cp
 = ++(
yy_c_buf_p
);

1135 
	gyy_current_state
 = 
yy_next_state
;

1136 goto 
	gyy_match
;

1141 
	gyy_cp
 = (
yy_c_buf_p
);

1142 goto 
	gyy_find_action
;

1146 else switch ( 
yy_get_next_buffer
( ) )

1148 case 
	gEOB_ACT_END_OF_FILE
:

1150 (
yy_did_buffer_switch_on_eof
) = 0;

1152 if ( 
yywrap
( ) )

1163 (
	gyy_c_buf_p
) = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1165 
	gyy_act
 = 
YY_STATE_EOF
(
YY_START
);

1166 goto 
	gdo_action
;

1171 if ( ! (
	gyy_did_buffer_switch_on_eof
) )

1172 
	gYY_NEW_FILE
;

1177 case 
	gEOB_ACT_CONTINUE_SCAN
:

1178 (
yy_c_buf_p
) =

1179 (
yyt_ptr
) + 
yy_amount_of_matched_text
;

1181 
	gyy_current_state
 = 
yy_get_previous_state
( );

1183 
	gyy_cp
 = (
yy_c_buf_p
);

1184 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1185 goto 
	gyy_match
;

1187 case 
	gEOB_ACT_LAST_MATCH
:

1188 (
yy_c_buf_p
) =

1189 &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)];

1191 
	gyy_current_state
 = 
yy_get_previous_state
( );

1193 
	gyy_cp
 = (
yy_c_buf_p
);

1194 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1195 goto 
	gyy_find_action
;

1201 
YY_FATAL_ERROR
(

1215 static int 
	$yy_get_next_buffer
 (void)

1217 char *
dest
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
;

1218 char *
source
 = (
yyt_ptr
);

1219 
yy_size_t
 
number_to_move
, 
i
;

1220 int 
ret_val
;

1222 if ( (
yy_c_buf_p
) > &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
) + 1] )

1223 
	`YY_FATAL_ERROR
(

1226 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_fill_buffer
 == 0 )

1228 if ( (
yy_c_buf_p
) - (
yyt_ptr
) - 
YY_MORE_ADJ
 == 1 )

1233 return 
EOB_ACT_END_OF_FILE
;

1241 return 
EOB_ACT_LAST_MATCH
;

1248 
number_to_move
 = (
yy_size_t
) ((
yy_c_buf_p
) - (
yyt_ptr
)) - 1;

1250 for ( 
i
 = 0; i < 
number_to_move
; ++i )

1251 *(
dest
++) = *(
source
++);

1253 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_buffer_status
 == 
YY_BUFFER_EOF_PENDING
 )

1257 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars) = 0;

1261 
yy_size_t
 
num_to_read
 =

1262 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 - 
number_to_move
 - 1;

1264 while ( 
num_to_read
 <= 0 )

1268 
YY_BUFFER_STATE
 
b
 = 
YY_CURRENT_BUFFER_LVALUE
;

1270 int 
yy_c_buf_p_offset
 =

1271 (int) ((
yy_c_buf_p
) - 
b
->
yy_ch_buf
);

1273 if ( 
b
->
yy_is_our_buffer
 )

1275 
yy_size_t
 
new_size
 = 
b
->
yy_buf_size
 * 2;

1277 if ( 
new_size
 <= 0 )

1278 
b
->
yy_buf_size
 += b->yy_buf_size / 8;

1280 
b
->
yy_buf_size
 *= 2;

1282 
b
->
yy_ch_buf
 = (char *)

1284 
	`yyrealloc
((void *) 
b
->
yy_ch_buf
,b->
yy_buf_size
 + 2 );

1288 
b
->
yy_ch_buf
 = 0;

1290 if ( ! 
b
->
yy_ch_buf
 )

1291 
	`YY_FATAL_ERROR
(

1294 (
yy_c_buf_p
) = &
b
->
yy_ch_buf
[
yy_c_buf_p_offset
];

1296 
num_to_read
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 -

1297 
number_to_move
 - 1;

1301 if ( 
num_to_read
 > 
YY_READ_BUF_SIZE
 )

1302 
num_to_read
 = 
YY_READ_BUF_SIZE
;

1305 
	`YY_INPUT
( (&
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[
number_to_move
]),

1306 (
yy_n_chars
), 
num_to_read
 );

1308 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1311 if ( (
yy_n_chars
) == 0 )

1313 if ( 
number_to_move
 == 
YY_MORE_ADJ
 )

1315 
ret_val
 = 
EOB_ACT_END_OF_FILE
;

1316 
	`yyrestart
(
yyin
 );

1321 
ret_val
 = 
EOB_ACT_LAST_MATCH
;

1322 
YY_CURRENT_BUFFER_LVALUE
->
yy_buffer_status
 =

1323 
YY_BUFFER_EOF_PENDING
;

1328 
ret_val
 = 
EOB_ACT_CONTINUE_SCAN
;

1330 if ((int) ((
yy_n_chars
) + 
number_to_move
) > 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
) {

1332 int 
new_size
 = (
yy_n_chars
) + 
number_to_move
 + ((yy_n_chars) >> 1);

1333 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 = (char *) 
	`yyrealloc
((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,
new_size
 );

1334 if ( ! 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 )

1335 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_get_next_buffer()" );

1338 (
yy_n_chars
) += 
number_to_move
;

1339 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] = 
YY_END_OF_BUFFER_CHAR
;

1340 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
) + 1] = 
YY_END_OF_BUFFER_CHAR
;

1342 (
yyt_ptr
) = &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[0];

1344 return 
ret_val
;

1345 
	}
}

1349 static 
yy_state_type
 
	$yy_get_previous_state
 (void)

1351 
yy_state_type
 
yy_current_state
;

1352 char *
yy_cp
;

1354 
yy_current_state
 = (
yy_start
);

1356 for ( 
yy_cp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
; yy_cp < (
yy_c_buf_p
); ++yy_cp )

1358 
YY_CHAR
 
yy_c
 = (*
yy_cp
 ? 
yy_ec
[
	`YY_SC_TO_UI
(*yy_cp)] : 1);

1359 if ( 
yy_accept
[
yy_current_state
] )

1361 (
yy_last_accepting_state
) = 
yy_current_state
;

1362 (
yy_last_accepting_cpos
) = 
yy_cp
;

1364 while ( 
yy_chk
[
yy_base
[
yy_current_state
] + 
yy_c
] != yy_current_state )

1366 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

1367 if ( 
yy_current_state
 >= 91 )

1368 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

1370 
yy_current_state
 = 
yy_nxt
[
yy_base
[yy_current_state] + (unsigned int) 
yy_c
];

1373 return 
yy_current_state
;

1374 
	}
}

1381 static 
yy_state_type
 
	$yy_try_NUL_trans
 (
yy_state_type
 
yy_current_state
 )

1383 int 
yy_is_jam
;

1384 char *
yy_cp
 = (
yy_c_buf_p
);

1386 
YY_CHAR
 
yy_c
 = 1;

1387 if ( 
yy_accept
[
yy_current_state
] )

1389 (
yy_last_accepting_state
) = 
yy_current_state
;

1390 (
yy_last_accepting_cpos
) = 
yy_cp
;

1392 while ( 
yy_chk
[
yy_base
[
yy_current_state
] + 
yy_c
] != yy_current_state )

1394 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

1395 if ( 
yy_current_state
 >= 91 )

1396 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

1398 
yy_current_state
 = 
yy_nxt
[
yy_base
[yy_current_state] + (unsigned int) 
yy_c
];

1399 
yy_is_jam
 = (
yy_current_state
 == 90);

1401 return 
yy_is_jam
 ? 0 : 
yy_current_state
;

1402 
	}
}

1404 #ifndef 
YY_NO_UNPUT


1406 static void 
	$yyunput
 (int 
c
, char * 
yy_bp
 )

1408 char *
yy_cp
;

1410 
yy_cp
 = (
yy_c_buf_p
);

1413 *
yy_cp
 = (
yy_hold_char
);

1415 if ( 
yy_cp
 < 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 + 2 )

1418 
yy_size_t
 
number_to_move
 = (
yy_n_chars
) + 2;

1419 char *
dest
 = &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[

1420 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 + 2];

1421 char *
source
 =

1422 &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[
number_to_move
];

1424 while ( 
source
 > 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 )

1425 *--
dest
 = *--
source
;

1427 
yy_cp
 += (int) (
dest
 - 
source
);

1428 
yy_bp
 += (int) (
dest
 - 
source
);

1429 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 =

1430 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
;

1432 if ( 
yy_cp
 < 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 + 2 )

1433 
	`YY_FATAL_ERROR
( "flex scanner push-back overflow" );

1436 *--
yy_cp
 = (char) 
c
;

1438 (
yyt_ptr
) = 
yy_bp
;

1439 (
yy_hold_char
) = *
yy_cp
;

1440 (
yy_c_buf_p
) = 
yy_cp
;

1441 
	}
}

1445 #ifndef 
YY_NO_INPUT


1446 #ifdef 
__cplusplus


1447 static int 
	$yyinput
 (void)

1449 static int 
	$input
 (void)

1453 int 
c
;

1455 *(
yy_c_buf_p
) = (
yy_hold_char
);

1457 if ( *(
yy_c_buf_p
) == 
YY_END_OF_BUFFER_CHAR
 )

1463 if ( (
yy_c_buf_p
) < &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] )

1465 *(
yy_c_buf_p
) = '\0';

1469 
yy_size_t
 
offset
 = (
yy_c_buf_p
) - (
yyt_ptr
);

1470 ++(
yy_c_buf_p
);

1472 switch ( 
	`yy_get_next_buffer
( ) )

1474 case 
EOB_ACT_LAST_MATCH
:

1486 
	`yyrestart
(
yyin
 );

1490 case 
EOB_ACT_END_OF_FILE
:

1492 if ( 
	`yywrap
( ) )

1493 return 
EOF
;

1495 if ( ! (
yy_did_buffer_switch_on_eof
) )

1496 
YY_NEW_FILE
;

1497 #ifdef 
__cplusplus


1498 return 
	`yyinput
();

1500 return 
	`input
();

1504 case 
EOB_ACT_CONTINUE_SCAN
:

1505 (
yy_c_buf_p
) = (
yyt_ptr
) + 
offset
;

1511 
c
 = *(unsigned char *) (
yy_c_buf_p
);

1512 *(
yy_c_buf_p
) = '\0';

1513 (
yy_hold_char
) = *++(
yy_c_buf_p
);

1515 return 
c
;

1516 
	}
}

1524 void 
	$yyrestart
 (
FILE
 * 
input_file
 )

1527 if ( ! 
YY_CURRENT_BUFFER
 ){

1528 
	`yyensure_buffer_stack
 ();

1529 
YY_CURRENT_BUFFER_LVALUE
 =

1530 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 );

1533 
	`yy_init_buffer
(
YY_CURRENT_BUFFER
,
input_file
 );

1534 
	`yy_load_buffer_state
( );

1535 
	}
}

1541 void 
	$yy_switch_to_buffer
 (
YY_BUFFER_STATE
 
new_buffer
 )

1549 
	`yyensure_buffer_stack
 ();

1550 if ( 
YY_CURRENT_BUFFER
 == 
new_buffer
 )

1553 if ( 
YY_CURRENT_BUFFER
 )

1556 *(
yy_c_buf_p
) = (
yy_hold_char
);

1557 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
 = (
yy_c_buf_p
);

1558 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1561 
YY_CURRENT_BUFFER_LVALUE
 = 
new_buffer
;

1562 
	`yy_load_buffer_state
( );

1569 (
yy_did_buffer_switch_on_eof
) = 1;

1570 
	}
}

1572 static void 
	$yy_load_buffer_state
 (void)

1574 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->yy_n_chars;

1575 (
yyt_ptr
) = (
yy_c_buf_p
) = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
;

1576 
yyin
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_input_file
;

1577 (
yy_hold_char
) = *(
yy_c_buf_p
);

1578 
	}
}

1586 
YY_BUFFER_STATE
 
	$yy_create_buffer
 (
FILE
 * 
file
, int 
size
 )

1588 
YY_BUFFER_STATE
 
b
;

1590 
b
 = (
YY_BUFFER_STATE
) 
	`yyalloc
(sizeof( struct 
yy_buffer_state
 ) );

1591 if ( ! 
b
 )

1592 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_create_buffer()" );

1594 
b
->
yy_buf_size
 = (
yy_size_t
)
size
;

1599 
b
->
yy_ch_buf
 = (char *) 
	`yyalloc
(b->
yy_buf_size
 + 2 );

1600 if ( ! 
b
->
yy_ch_buf
 )

1601 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_create_buffer()" );

1603 
b
->
yy_is_our_buffer
 = 1;

1605 
	`yy_init_buffer
(
b
,
file
 );

1607 return 
b
;

1608 
	}
}

1614 void 
	$yy_delete_buffer
 (
YY_BUFFER_STATE
 
b
 )

1617 if ( ! 
b
 )

1620 if ( 
b
 == 
YY_CURRENT_BUFFER
 )

1621 
YY_CURRENT_BUFFER_LVALUE
 = (
YY_BUFFER_STATE
) 0;

1623 if ( 
b
->
yy_is_our_buffer
 )

1624 
	`yyfree
((void *) 
b
->
yy_ch_buf
 );

1626 
	`yyfree
((void *) 
b
 );

1627 
	}
}

1633 static void 
	$yy_init_buffer
 (
YY_BUFFER_STATE
 
b
, 
FILE
 * 
file
 )

1636 int 
oerrno
 = 
errno
;

1638 
	`yy_flush_buffer
(
b
 );

1640 
b
->
yy_input_file
 = 
file
;

1641 
b
->
yy_fill_buffer
 = 1;

1647 if (
b
 != 
YY_CURRENT_BUFFER
){

1648 
b
->
yy_bs_lineno
 = 1;

1649 
b
->
yy_bs_column
 = 0;

1652 
b
->
yy_is_interactive
 = 
file
 ? (
	`isatty
( 
	`fileno
(file) ) > 0) : 0;

1654 
errno
 = 
oerrno
;

1655 
	}
}

1661 void 
	$yy_flush_buffer
 (
YY_BUFFER_STATE
 
b
 )

1663 if ( ! 
b
 )

1666 
b
->
yy_n_chars
 = 0;

1672 
b
->
yy_ch_buf
[0] = 
YY_END_OF_BUFFER_CHAR
;

1673 
b
->
yy_ch_buf
[1] = 
YY_END_OF_BUFFER_CHAR
;

1675 
b
->
yy_buf_pos
 = &b->
yy_ch_buf
[0];

1677 
b
->
yy_at_bol
 = 1;

1678 
b
->
yy_buffer_status
 = 
YY_BUFFER_NEW
;

1680 if ( 
b
 == 
YY_CURRENT_BUFFER
 )

1681 
	`yy_load_buffer_state
( );

1682 
	}
}

1690 void 
	$yypush_buffer_state
 (
YY_BUFFER_STATE
 
new_buffer
 )

1692 if (
new_buffer
 == 
NULL
)

1695 
	`yyensure_buffer_stack
();

1698 if ( 
YY_CURRENT_BUFFER
 )

1701 *(
yy_c_buf_p
) = (
yy_hold_char
);

1702 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
 = (
yy_c_buf_p
);

1703 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1707 if (
YY_CURRENT_BUFFER
)

1708 (
yy_buffer_stack_top
)++;

1709 
YY_CURRENT_BUFFER_LVALUE
 = 
new_buffer
;

1712 
	`yy_load_buffer_state
( );

1713 (
yy_did_buffer_switch_on_eof
) = 1;

1714 
	}
}

1720 void 
	$yypop_buffer_state
 (void)

1722 if (!
YY_CURRENT_BUFFER
)

1725 
	`yy_delete_buffer
(
YY_CURRENT_BUFFER
 );

1726 
YY_CURRENT_BUFFER_LVALUE
 = 
NULL
;

1727 if ((
yy_buffer_stack_top
) > 0)

1728 --(
yy_buffer_stack_top
);

1730 if (
YY_CURRENT_BUFFER
) {

1731 
	`yy_load_buffer_state
( );

1732 (
yy_did_buffer_switch_on_eof
) = 1;

1734 
	}
}

1739 static void 
	$yyensure_buffer_stack
 (void)

1741 
yy_size_t
 
num_to_alloc
;

1743 if (!(
yy_buffer_stack
)) {

1749 
num_to_alloc
 = 1;

1750 (
yy_buffer_stack
) = (struct 
yy_buffer_state
**)
yyalloc


1751 (
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*)

1753 if ( ! (
yy_buffer_stack
) )

1754 
	`YY_FATAL_ERROR
( "out of dynamic memory in yyensure_buffer_stack()" );

1756 
	`memset
((
yy_buffer_stack
), 0, 
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*));

1758 (
yy_buffer_stack_max
) = 
num_to_alloc
;

1759 (
yy_buffer_stack_top
) = 0;

1763 if ((
yy_buffer_stack_top
) >= ((
yy_buffer_stack_max
)) - 1){

1766 
yy_size_t
 
grow_size
 = 8 ;

1768 
num_to_alloc
 = (
yy_buffer_stack_max
) + 
grow_size
;

1769 (
yy_buffer_stack
) = (struct 
yy_buffer_state
**)
yyrealloc


1770 ((
yy_buffer_stack
),

1771 
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*)

1773 if ( ! (
yy_buffer_stack
) )

1774 
	`YY_FATAL_ERROR
( "out of dynamic memory in yyensure_buffer_stack()" );

1777 
	`memset
((
yy_buffer_stack
) + (
yy_buffer_stack_max
), 0, 
grow_size
 * sizeof(struct 
yy_buffer_state
*));

1778 (
yy_buffer_stack_max
) = 
num_to_alloc
;

1780 
	}
}

1788 
YY_BUFFER_STATE
 
	$yy_scan_buffer
 (char * 
base
, 
yy_size_t
 
size
 )

1790 
YY_BUFFER_STATE
 
b
;

1792 if ( 
size
 < 2 ||

1793 
base
[
size
-2] != 
YY_END_OF_BUFFER_CHAR
 ||

1794 
base
[
size
-1] != 
YY_END_OF_BUFFER_CHAR
 )

1798 
b
 = (
YY_BUFFER_STATE
) 
	`yyalloc
(sizeof( struct 
yy_buffer_state
 ) );

1799 if ( ! 
b
 )

1800 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_scan_buffer()" );

1802 
b
->
yy_buf_size
 = 
size
 - 2;

1803 
b
->
yy_buf_pos
 = b->
yy_ch_buf
 = 
base
;

1804 
b
->
yy_is_our_buffer
 = 0;

1805 
b
->
yy_input_file
 = 0;

1806 
b
->
yy_n_chars
 = b->
yy_buf_size
;

1807 
b
->
yy_is_interactive
 = 0;

1808 
b
->
yy_at_bol
 = 1;

1809 
b
->
yy_fill_buffer
 = 0;

1810 
b
->
yy_buffer_status
 = 
YY_BUFFER_NEW
;

1812 
	`yy_switch_to_buffer
(
b
 );

1814 return 
b
;

1815 
	}
}

1825 
YY_BUFFER_STATE
 
	$yy_scan_string
 (
yyconst
 char * 
yystr
 )

1828 return 
	`yy_scan_bytes
(
yystr
,
	`strlen
(yystr) );

1829 
	}
}

1838 
YY_BUFFER_STATE
 
	$yy_scan_bytes
 (
yyconst
 char * 
yybytes
, 
yy_size_t
 
_yybytes_len
 )

1840 
YY_BUFFER_STATE
 
b
;

1841 char *
buf
;

1842 
yy_size_t
 
n
;

1843 
yy_size_t
 
i
;

1846 
n
 = 
_yybytes_len
 + 2;

1847 
buf
 = (char *) 
	`yyalloc
(
n
 );

1848 if ( ! 
buf
 )

1849 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_scan_bytes()" );

1851 for ( 
i
 = 0; i < 
_yybytes_len
; ++i )

1852 
buf
[
i
] = 
yybytes
[i];

1854 
buf
[
_yybytes_len
] = buf[_yybytes_len+1] = 
YY_END_OF_BUFFER_CHAR
;

1856 
b
 = 
	`yy_scan_buffer
(
buf
,
n
 );

1857 if ( ! 
b
 )

1858 
	`YY_FATAL_ERROR
( "bad buffer in yy_scan_bytes()" );

1863 
b
->
yy_is_our_buffer
 = 1;

1865 return 
b
;

1866 
	}
}

1868 #ifndef 
YY_EXIT_FAILURE


1869 #define 
	#YY_EXIT_FAILURE
 2

	)

1872 static void 
	$yy_fatal_error
 (
yyconst
 char* 
msg
 )

1874 (void) 
	`fprintf
( 
stderr
, "%s\n", 
msg
 );

1875 
	`exit
( 
YY_EXIT_FAILURE
 );

1876 
	}
}

1880 #undef 
yyless


1881 #define 
	#yyless
(
n
) \

1885 int 
yyless_macro_arg
 = (
n
); \

1886 
	`YY_LESS_LINENO
(
yyless_macro_arg
);\

1887 
yyt
[
yyleng
] = (
yy_hold_char
); \

1888 (
yy_c_buf_p
) = 
yyt
 + 
yyless_macro_arg
; \

1889 (
yy_hold_char
) = *(
yy_c_buf_p
); \

1890 *(
yy_c_buf_p
) = '\0'; \

1891 
yyleng
 = 
yyless_macro_arg
; \

1893 while ( 0 )

	)

1900 int 
	$yyget_lineno
 (void)

1903 return 
yylineno
;

1904 
	}
}

1909 
FILE
 *
	$yyget_in
 (void)

1911 return 
yyin
;

1912 
	}
}

1917 
FILE
 *
	$yyget_out
 (void)

1919 return 
yyout
;

1920 
	}
}

1925 
yy_size_t
 
	$yyget_leng
 (void)

1927 return 
yyleng
;

1928 
	}
}

1934 char *
	$yyget_text
 (void)

1936 return 
yyt
;

1937 
	}
}

1943 void 
	$yyset_lineno
 (int 
_line_number
 )

1946 
yylineno
 = 
_line_number
;

1947 
	}
}

1955 void 
	$yyset_in
 (
FILE
 * 
_in_str
 )

1957 
yyin
 = 
_in_str
 ;

1958 
	}
}

1960 void 
	$yyset_out
 (
FILE
 * 
_out_str
 )

1962 
yyout
 = 
_out_str
 ;

1963 
	}
}

1965 int 
	$yyget_debug
 (void)

1967 return 
yy_flex_debug
;

1968 
	}
}

1970 void 
	$yyset_debug
 (int 
_bdebug
 )

1972 
yy_flex_debug
 = 
_bdebug
 ;

1973 
	}
}

1975 static int 
	$yy_init_globals
 (void)

1981 (
yy_buffer_stack
) = 0;

1982 (
yy_buffer_stack_top
) = 0;

1983 (
yy_buffer_stack_max
) = 0;

1984 (
yy_c_buf_p
) = (char *) 0;

1985 (
yy_init
) = 0;

1986 (
yy_start
) = 0;

1989 #ifdef 
YY_STDINIT


1990 
yyin
 = 
stdin
;

1991 
yyout
 = 
stdout
;

1993 
yyin
 = (
FILE
 *) 0;

1994 
yyout
 = (
FILE
 *) 0;

2001 
	}
}

2004 int 
	$yylex_destroy
 (void)

2008 while(
YY_CURRENT_BUFFER
){

2009 
	`yy_delete_buffer
(
YY_CURRENT_BUFFER
 );

2010 
YY_CURRENT_BUFFER_LVALUE
 = 
NULL
;

2011 
	`yypop_buffer_state
();

2015 
	`yyfree
((
yy_buffer_stack
) );

2016 (
yy_buffer_stack
) = 
NULL
;

2020 
	`yy_init_globals
( );

2023 
	}
}

2029 #ifndef 
yyt_ptr


2030 static void 
	$yy_flex_strncpy
 (char* 
s1
, 
yyconst
 char * 
s2
, int 
n
 )

2033 int 
i
;

2034 for ( 
i
 = 0; i < 
n
; ++i )

2035 
s1
[
i
] = 
s2
[i];

2036 
	}
}

2039 #ifdef 
YY_NEED_STRLEN


2040 static int 
	$yy_flex_strlen
 (
yyconst
 char * 
s
 )

2042 int 
n
;

2043 for ( 
n
 = 0; 
s
[n]; ++n )

2046 return 
n
;

2047 
	}
}

2050 void *
	$yyalloc
 (
yy_size_t
 
size
 )

2052 return (void *) 
	`malloc
( 
size
 );

2053 
	}
}

2055 void *
	$yyrealloc
 (void * 
ptr
, 
yy_size_t
 
size
 )

2065 return (void *) 
	`realloc
( (char *) 
ptr
, 
size
 );

2066 
	}
}

2068 void 
	$yyfree
 (void * 
ptr
 )

2070 
	`free
( (char *) 
ptr
 );

2071 
	}
}

2073 #define 
	#YYTABLES_NAME
 "yytables"

	)

2079 int 
	$main
(int 
argc
, char *
argv
[])

2081 if(
argc
 == 1)

2083 
	`printf
("No file specified!..Reading from stdin and writing to stdout.\n");

2084 
yyin
 = 
stdin
;

2085 
yyout
 = 
stdout
;

2087 else if(
argc
 == 2)

2089 
	`printf
("No output file specified!..Writing to stdout.\n");

2090 
yyout
 = 
stdout
;

2091 
yyin
 = 
	`fopen
(
argv
[1], "r");

2095 
yyin
 = 
	`fopen
(
argv
[1], "r");

2096 
yyout
 = 
	`fopen
(
argv
[2], "w");

2099 int 
token
;

2100 while(
token
 = 
	`yylex
())

2102 
	`fprintf
(
yyout
, "%d\n", 
token
);

2104 
	`fclose
(
yyin
);

2105 
	`fclose
(
yyout
);

2106 
	}
}

2107 int 
	$yywrap
(){
	}
}

	@Assignment3/lex.yy.c

4 #define 
	#YY_INT_ALIGNED
 short int

	)

8 #define 
	#FLEX_SCANNER


	)

9 #define 
	#YY_FLEX_MAJOR_VERSION
 2

	)

10 #define 
	#YY_FLEX_MINOR_VERSION
 6

	)

11 #define 
	#YY_FLEX_SUBMINOR_VERSION
 0

	)

12 #if 
YY_FLEX_SUBMINOR_VERSION
 > 0

13 #define 
	#FLEX_BETA


	)

19 #include 
	~<stdio.h
>

20 #include 
	~<string.h
>

21 #include 
	~<errno.h
>

22 #include 
	~<stdlib.h
>

28 #ifndef 
FLEXINT_H


29 #define 
	#FLEXINT_H


	)

33 #if 
defined
 (
__STDC_VERSION__
) && __STDC_VERSION__ >= 199901L

38 #ifndef 
__STDC_LIMIT_MACROS


39 #define 
	#__STDC_LIMIT_MACROS
 1

	)

42 #include 
	~<inttypes.h
>

43 typedef 
int8_t
 
	tflex_int8_t
;

44 typedef 
uint8_t
 
	tflex_uint8_t
;

45 typedef 
int16_t
 
	tflex_int16_t
;

46 typedef 
uint16_t
 
	tflex_uint16_t
;

47 typedef 
int32_t
 
	tflex_int32_t
;

48 typedef 
uint32_t
 
	tflex_uint32_t
;

50 typedef signed char 
	tflex_int8_t
;

51 typedef short int 
	tflex_int16_t
;

52 typedef int 
	tflex_int32_t
;

53 typedef unsigned char 
	tflex_uint8_t
;

54 typedef unsigned short int 
	tflex_uint16_t
;

55 typedef unsigned int 
	tflex_uint32_t
;

58 #ifndef 
INT8_MIN


59 #define 
	#INT8_MIN
 (-128)

	)

61 #ifndef 
INT16_MIN


62 #define 
	#INT16_MIN
 (-32767-1)

	)

64 #ifndef 
INT32_MIN


65 #define 
	#INT32_MIN
 (-2147483647-1)

	)

67 #ifndef 
INT8_MAX


68 #define 
	#INT8_MAX
 (127)

	)

70 #ifndef 
INT16_MAX


71 #define 
	#INT16_MAX
 (32767)

	)

73 #ifndef 
INT32_MAX


74 #define 
	#INT32_MAX
 (2147483647)

	)

76 #ifndef 
UINT8_MAX


77 #define 
	#UINT8_MAX
 (255U)

	)

79 #ifndef 
UINT16_MAX


80 #define 
	#UINT16_MAX
 (65535U)

	)

82 #ifndef 
UINT32_MAX


83 #define 
	#UINT32_MAX
 (4294967295U)

	)

90 #ifdef 
__cplusplus


93 #define 
	#YY_USE_CONST


	)

98 #if 
defined
 (
__STDC__
)

100 #define 
	#YY_USE_CONST


	)

105 #ifdef 
YY_USE_CONST


106 #define 
	#yyconst
 const

	)

108 #define 
	#yyconst


	)

112 #define 
	#YY_NULL
 0

	)

119 #define 
	#YY_SC_TO_UI
(
c
) ((unsigned int) (unsigned char) c)

	)

125 #define 
	#BEGIN
 (
yy_start
) = 1 + 2 *

	)

131 #define 
	#YY_START
 (((
yy_start
) - 1) / 2)

	)

132 #define 
	#YYSTATE
 
YY_START


	)

135 #define 
	#YY_STATE_EOF
(
state
) (
YY_END_OF_BUFFER
 + state + 1)

	)

138 #define 
	#YY_NEW_FILE
 
	`yyrestart
(
yyin
 )

	)

140 #define 
	#YY_END_OF_BUFFER_CHAR
 0

	)

143 #ifndef 
YY_BUF_SIZE


144 #ifdef 
__ia64__


149 #define 
	#YY_BUF_SIZE
 32768

	)

151 #define 
	#YY_BUF_SIZE
 16384

	)

157 #define 
	#YY_STATE_BUF_SIZE
 ((
YY_BUF_SIZE
 + 2) * sizeof(
yy_state_type
))

	)

159 #ifndef 
YY_TYPEDEF_YY_BUFFER_STATE


160 #define 
	#YY_TYPEDEF_YY_BUFFER_STATE


	)

161 typedef struct 
yy_buffer_state
 *
	tYY_BUFFER_STATE
;

164 #ifndef 
YY_TYPEDEF_YY_SIZE_T


165 #define 
	#YY_TYPEDEF_YY_SIZE_T


	)

166 typedef 
size_t
 
	tyy_size_t
;

169 extern 
yy_size_t
 
yyleng
;

171 extern 
FILE
 *
yyin
, *
yyout
;

173 #define 
	#EOB_ACT_CONTINUE_SCAN
 0

	)

174 #define 
	#EOB_ACT_END_OF_FILE
 1

	)

175 #define 
	#EOB_ACT_LAST_MATCH
 2

	)

177 #define 
	#YY_LESS_LINENO
(
n
)

	)

178 #define 
	#YY_LINENO_REWIND_TO
(
ptr
)

	)

181 #define 
	#yyless
(
n
) \

185 int 
yyless_macro_arg
 = (
n
); \

186 
	`YY_LESS_LINENO
(
yyless_macro_arg
);\

187 *
yy_cp
 = (
yy_hold_char
); \

188 
YY_RESTORE_YY_MORE_OFFSET
 \

189 (
yy_c_buf_p
) = 
yy_cp
 = 
yy_bp
 + 
yyless_macro_arg
 - 
YY_MORE_ADJ
; \

190 
YY_DO_BEFORE_ACTION
; \

192 while ( 0 )

	)

194 #define 
	#unput
(
c
) 
	`yyunput
( c, (
yyt_ptr
) )

	)

196 #ifndef 
YY_STRUCT_YY_BUFFER_STATE


197 #define 
	#YY_STRUCT_YY_BUFFER_STATE


	)

198 struct 
	syy_buffer_state


200 
FILE
 *
	myy_input_file
;

202 char *
	myy_ch_buf
;

203 char *
	myy_buf_pos
;

208 
yy_size_t
 
	myy_buf_size
;

213 int 
	myy_n_chars
;

219 int 
	myy_is_our_buffer
;

226 int 
	myy_is_interactive
;

232 int 
	myy_at_bol
;

234 int 
	myy_bs_lineno
;

235 int 
	myy_bs_column
;

240 int 
	myy_fill_buffer
;

242 int 
	myy_buffer_status
;

244 #define 
	#YY_BUFFER_NEW
 0

	)

245 #define 
	#YY_BUFFER_NORMAL
 1

	)

256 #define 
	#YY_BUFFER_EOF_PENDING
 2

	)

262 static 
size_t
 
	gyy_buffer_stack_top
 = 0;

263 static 
size_t
 
	gyy_buffer_stack_max
 = 0;

264 static 
YY_BUFFER_STATE
 * 
	gyy_buffer_stack
 = 0;

272 #define 
	#YY_CURRENT_BUFFER
 ( (
yy_buffer_stack
) \

273 ? (
yy_buffer_stack
)[(
yy_buffer_stack_top
)] \

274 : 
NULL
)

	)

279 #define 
	#YY_CURRENT_BUFFER_LVALUE
 (
yy_buffer_stack
)[(
yy_buffer_stack_top
)]

	)

282 static char 
	gyy_hold_char
;

283 static int 
	gyy_n_chars
;

284 
yy_size_t
 
	gyyleng
;

287 static char *
	gyy_c_buf_p
 = (char *) 0;

288 static int 
	gyy_init
 = 0;

289 static int 
	gyy_start
 = 0;

294 static int 
	gyy_did_buffer_switch_on_eof
;

296 void 
yyrestart
 (
FILE
 *
input_file
 );

297 void 
yy_switch_to_buffer
 (
YY_BUFFER_STATE
 
new_buffer
 );

298 
YY_BUFFER_STATE
 
yy_create_buffer
 (
FILE
 *
file
,int 
size
 );

299 void 
yy_delete_buffer
 (
YY_BUFFER_STATE
 
b
 );

300 void 
yy_flush_buffer
 (
YY_BUFFER_STATE
 
b
 );

301 void 
yypush_buffer_state
 (
YY_BUFFER_STATE
 
new_buffer
 );

302 void 
yypop_buffer_state
 (void );

304 static void 
yyensure_buffer_stack
 (void );

305 static void 
yy_load_buffer_state
 (void );

306 static void 
yy_init_buffer
 (
YY_BUFFER_STATE
 
b
,
FILE
 *
file
 );

308 #define 
	#YY_FLUSH_BUFFER
 
	`yy_flush_buffer
(
YY_CURRENT_BUFFER
 )

	)

310 
YY_BUFFER_STATE
 
yy_scan_buffer
 (char *
base
,
yy_size_t
 
size
 );

311 
YY_BUFFER_STATE
 
yy_scan_string
 (
yyconst
 char *
yy_str
 );

312 
YY_BUFFER_STATE
 
yy_scan_bytes
 (
yyconst
 char *
bytes
,
yy_size_t
 
len
 );

314 void *
yyalloc
 (
yy_size_t
 );

315 void *
yyrealloc
 (void *,
yy_size_t
 );

316 void 
yyfree
 (void * );

318 #define 
	#yy_new_buffer
 
yy_create_buffer


	)

320 #define 
	#yy_set_interactive
(
is_interactive
) \

322 if ( ! 
YY_CURRENT_BUFFER
 ){ \

323 
	`yyensure_buffer_stack
 (); \

324 
YY_CURRENT_BUFFER_LVALUE
 = \

325 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 ); \

327 
YY_CURRENT_BUFFER_LVALUE
->
yy_is_interactive
 = 
is_interactive
; \

328 }

	)

330 #define 
	#yy_set_bol
(
at_bol
) \

332 if ( ! 
YY_CURRENT_BUFFER
 ){\

333 
	`yyensure_buffer_stack
 (); \

334 
YY_CURRENT_BUFFER_LVALUE
 = \

335 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 ); \

337 
YY_CURRENT_BUFFER_LVALUE
->
yy_at_bol
 = 
at_bol
; \

338 }

	)

340 #define 
	#YY_AT_BOL
() (
YY_CURRENT_BUFFER_LVALUE
->
yy_at_bol
)

	)

344 typedef unsigned char 
	tYY_CHAR
;

346 
FILE
 *
	gyyin
 = (FILE *) 0, *
	gyyout
 = (FILE *) 0;

348 typedef int 
	tyy_state_type
;

350 extern int 
yylineno
;

352 int 
	gyylineno
 = 1;

354 extern char *
yyt
;

355 #ifdef 
yyt_ptr


356 #undef 
yyt_ptr


358 #define 
	#yyt_ptr
 
yyt


	)

360 static 
yy_state_type
 
yy_get_previous_state
 (void );

361 static 
yy_state_type
 
yy_try_NUL_trans
 (yy_state_type 
current_state
 );

362 static int 
yy_get_next_buffer
 (void );

363 #if 
defined
(
__GNUC__
) && __GNUC__ >= 3

364 
__attribute__
((
__noreturn__
))

366 static void 
yy_fatal_error
 (
yyconst
 char 
msg
[] );

371 #define 
	#YY_DO_BEFORE_ACTION
 \

372 (
yyt_ptr
) = 
yy_bp
; \

373 
yyleng
 = (
size_t
) (
yy_cp
 - 
yy_bp
); \

374 (
yy_hold_char
) = *
yy_cp
; \

375 *
yy_cp
 = '\0'; \

376 (
yy_c_buf_p
) = 
yy_cp
;

	)

378 #define 
	#YY_NUM_RULES
 53

	)

379 #define 
	#YY_END_OF_BUFFER
 54

	)

382 struct 
	syy_trans_info


384 
flex_int32_t
 
	myy_verify
;

385 
flex_int32_t
 
	myy_nxt
;

387 static 
yyconst
 
flex_int16_t
 
	gyy_accept
[91] =

400 static 
yyconst
 
YY_CHAR
 
	gyy_ec
[256] =

432 static 
yyconst
 
YY_CHAR
 
	gyy_meta
[39] =

440 static 
yyconst
 
flex_uint16_t
 
	gyy_base
[99] =

455 static 
yyconst
 
flex_int16_t
 
	gyy_def
[99] =

470 static 
yyconst
 
flex_uint16_t
 
	gyy_nxt
[155] =

491 static 
yyconst
 
flex_int16_t
 
	gyy_chk
[155] =

512 static 
yy_state_type
 
	gyy_last_accepting_state
;

513 static char *
	gyy_last_accepting_cpos
;

515 extern int 
yy_flex_debug
;

516 int 
	gyy_flex_debug
 = 0;

521 #define 
	#REJECT
 
reject_used_but_not_detected


	)

522 #define 
	#yymore
() 
yymore_used_but_not_detected


	)

523 #define 
	#YY_MORE_ADJ
 0

	)

524 #define 
	#YY_RESTORE_YY_MORE_OFFSET


	)

525 char *
	gyyt
;

528 #include 
	~<stdio.h
>

529 #include 
	~"lexical.hpp
"

532 #define 
	#INITIAL
 0

	)

534 #ifndef 
YY_NO_UNISTD_H


539 #include 
	~<unistd.h
>

542 #ifndef 
YY_EXTRA_TYPE


543 #define 
	#YY_EXTRA_TYPE
 void *

	)

546 static int 
yy_init_globals
 (void );

551 int 
yylex_destroy
 (void );

553 int 
yyget_debug
 (void );

555 void 
yyset_debug
 (int 
debug_flag
 );

557 
YY_EXTRA_TYPE
 
yyget_extra
 (void );

559 void 
yyset_extra
 (
YY_EXTRA_TYPE
 
user_defined
 );

561 
FILE
 *
yyget_in
 (void );

563 void 
yyset_in
 (
FILE
 * 
_in_str
 );

565 
FILE
 *
yyget_out
 (void );

567 void 
yyset_out
 (
FILE
 * 
_out_str
 );

569 
yy_size_t
 
yyget_leng
 (void );

571 char *
yyget_text
 (void );

573 int 
yyget_lineno
 (void );

575 void 
yyset_lineno
 (int 
_line_number
 );

581 #ifndef 
YY_SKIP_YYWRAP


582 #ifdef 
__cplusplus


583 extern "C" int 
yywrap
 (void );

585 extern int 
yywrap
 (void );

589 #ifndef 
YY_NO_UNPUT


591 static void 
yyunput
 (int 
c
,char *
buf_ptr
 );

595 #ifndef 
yyt_ptr


596 static void 
yy_flex_strncpy
 (char *,
yyconst
 char *,int );

599 #ifdef 
YY_NEED_STRLEN


600 static int 
yy_flex_strlen
 (
yyconst
 char * );

603 #ifndef 
YY_NO_INPUT


605 #ifdef 
__cplusplus


606 static int 
yyinput
 (void );

608 static int 
input
 (void );

614 #ifndef 
YY_READ_BUF_SIZE


615 #ifdef 
__ia64__


617 #define 
	#YY_READ_BUF_SIZE
 16384

	)

619 #define 
	#YY_READ_BUF_SIZE
 8192

	)

624 #ifndef 
ECHO


628 #define 
	#ECHO
 do { if (
	`fwrite
( 
yyt
, 
yyleng
, 1, 
yyout
 )) {} } while (0)

	)

634 #ifndef 
YY_INPUT


635 #define 
	#YY_INPUT
(
buf
,
result
,
max_size
) \

636 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_is_interactive
 ) \

638 int 
c
 = '*'; \

639 
size_t
 
n
; \

640 for ( 
n
 = 0; n < 
max_size
 && \

641 (
c
 = 
	`getc
( 
yyin
 )) != 
EOF
 && c != '\n'; ++
n
 ) \

642 
buf
[
n
] = (char) 
c
; \

643 if ( 
c
 == '\n' ) \

644 
buf
[
n
++] = (char) 
c
; \

645 if ( 
c
 == 
EOF
 && 
	`ferror
( 
yyin
 ) ) \

646 
	`YY_FATAL_ERROR
( "input in flex scanner failed" ); \

647 
result
 = 
n
; \

651 
errno
=0; \

652 while ( (
result
 = 
	`fread
(
buf
, 1, 
max_size
, 
yyin
))==0 && 
	`ferror
(yyin)) \

654 if( 
errno
 != 
EINTR
) \

656 
	`YY_FATAL_ERROR
( "input in flex scanner failed" ); \

659 
errno
=0; \

660 
	`clearerr
(
yyin
); \

664 

	)

671 #ifndef 
yyterminate


672 #define 
	#yyterminate
() return 
YY_NULL


	)

676 #ifndef 
YY_START_STACK_INCR


677 #define 
	#YY_START_STACK_INCR
 25

	)

681 #ifndef 
YY_FATAL_ERROR


682 #define 
	#YY_FATAL_ERROR
(
msg
) 
	`yy_fatal_error
( msg )

	)

690 #ifndef 
YY_DECL


691 #define 
	#YY_DECL_IS_OURS
 1

	)

693 extern int 
yylex
 (void);

695 #define 
	#YY_DECL
 int 
	`yylex
 (void)

	)

701 #ifndef 
YY_USER_ACTION


702 #define 
	#YY_USER_ACTION


	)

706 #ifndef 
YY_BREAK


707 #define 
	#YY_BREAK
 break;

	)

710 #define 
	#YY_RULE_SETUP
 \

711 
YY_USER_ACTION


	)

715 
	gYY_DECL


717 
yy_state_type
 
	gyy_current_state
;

718 char *
	gyy_cp
, *
	gyy_bp
;

719 int 
	gyy_act
;

721 if ( !(
	gyy_init
) )

723 (
	gyy_init
) = 1;

725 #ifdef 
YY_USER_INIT


726 
	gYY_USER_INIT
;

729 if ( ! (
	gyy_start
) )

730 (
	gyy_start
) = 1;

732 if ( ! 
	gyyin
 )

733 
	gyyin
 = 
stdin
;

735 if ( ! 
	gyyout
 )

736 
	gyyout
 = 
stdout
;

738 if ( ! 
	gYY_CURRENT_BUFFER
 ) {

739 
yyensure_buffer_stack
 ();

740 
	gYY_CURRENT_BUFFER_LVALUE
 =

741 
yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 );

744 
yy_load_buffer_state
( );

754 
	gyy_cp
 = (
yy_c_buf_p
);

757 *
	gyy_cp
 = (
yy_hold_char
);

762 
	gyy_bp
 = 
yy_cp
;

764 
	gyy_current_state
 = (
yy_start
);

765 
	gyy_match
:

768 
YY_CHAR
 
yy_c
 = 
yy_ec
[
YY_SC_TO_UI
(*
yy_cp
)] ;

769 if ( 
	gyy_accept
[
yy_current_state
] )

771 (
	gyy_last_accepting_state
) = 
yy_current_state
;

772 (
	gyy_last_accepting_cpos
) = 
yy_cp
;

774 while ( 
	gyy_chk
[
yy_base
[
yy_current_state
] + 
	gyy_c
] != yy_current_state )

776 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

777 if ( 
	gyy_current_state
 >= 91 )

778 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

780 
	gyy_current_state
 = 
yy_nxt
[
yy_base
[
yy_current_state
] + (unsigned int) 
yy_c
];

781 ++
	gyy_cp
;

783 while ( 
	gyy_base
[
yy_current_state
] != 116 );

785 
	gyy_find_action
:

786 
yy_act
 = 
yy_accept
[
yy_current_state
];

787 if ( 
	gyy_act
 == 0 )

789 
yy_cp
 = (
yy_last_accepting_cpos
);

790 
	gyy_current_state
 = (
yy_last_accepting_state
);

791 
	gyy_act
 = 
yy_accept
[
yy_current_state
];

794 
	gYY_DO_BEFORE_ACTION
;

796 
	gdo_action
:

798 switch ( 
yy_act
 )

802 *
yy_cp
 = (
yy_hold_char
);

803 
	gyy_cp
 = (
yy_last_accepting_cpos
);

804 
	gyy_current_state
 = (
yy_last_accepting_state
);

805 goto 
	gyy_find_action
;

808 
YY_RULE_SETUP


811 
YY_BREAK


814 
YY_RULE_SETUP


817 
YY_BREAK


819 
YY_RULE_SETUP


821 {
ECHO
; 
printf
("Unterminated comment\n"); }

822 
YY_BREAK


824 
YY_RULE_SETUP


826 {return 
FOR_TOK
;}

827 
YY_BREAK


829 
YY_RULE_SETUP


831 {return 
WHILE_TOK
;}

832 
YY_BREAK


834 
YY_RULE_SETUP


836 {return 
IF_TOK
;}

837 
YY_BREAK


839 
YY_RULE_SETUP


841 {return 
ELSE_TOK
;}

842 
YY_BREAK


844 
YY_RULE_SETUP


846 {return 
SWITCH_TOK
;}

847 
YY_BREAK


849 
YY_RULE_SETUP


851 {return 
CASE_TOK
;}

852 
YY_BREAK


854 
YY_RULE_SETUP


856 {return 
VOID_TOK
;}

857 
YY_BREAK


859 
YY_RULE_SETUP


861 {return 
LPAREN_TOK
;}

862 
YY_BREAK


864 
YY_RULE_SETUP


866 {return 
RPAREN_TOK
;}

867 
YY_BREAK


869 
YY_RULE_SETUP


871 {return 
GT_TOK
;}

872 
YY_BREAK


874 
YY_RULE_SETUP


876 {return 
LS_TOK
;}

877 
YY_BREAK


879 
YY_RULE_SETUP


881 {return 
EQ_TOK
;}

882 
YY_BREAK


884 
YY_RULE_SETUP


886 {return 
MINUS_TOK
;}

887 
YY_BREAK


889 
YY_RULE_SETUP


891 {return 
ADDITION_TOK
;}

892 
YY_BREAK


894 
YY_RULE_SETUP


896 {return 
MULTI_TOK
;}

897 
YY_BREAK


899 
YY_RULE_SETUP


901 {return 
DIVISION_TOK
;}

902 
YY_BREAK


904 
YY_RULE_SETUP


906 {return 
MOD_TOK
;}

907 
YY_BREAK


909 
YY_RULE_SETUP


911 {return 
LCURLY_TOK
;}

912 
YY_BREAK


914 
YY_RULE_SETUP


916 {return 
RCURLY_TOK
;}

917 
YY_BREAK


919 
YY_RULE_SETUP


921 {return 
BITOR_TOK
;}

922 
YY_BREAK


924 
YY_RULE_SETUP


926 {return 
BITAND_TOK
;}

927 
YY_BREAK


929 
YY_RULE_SETUP


931 {return 
XOR_TOK
;}

932 
YY_BREAK


934 
YY_RULE_SETUP


936 {return 
NOT_TOK
;}

937 
YY_BREAK


939 
YY_RULE_SETUP


941 {return 
COMMA_TOK
;}

942 
YY_BREAK


944 
YY_RULE_SETUP


946 {return 
SEMCOL_TOK
;}

947 
YY_BREAK


949 
YY_RULE_SETUP


951 {return 
MINEQ_TOK
;}

952 
YY_BREAK


954 
YY_RULE_SETUP


956 {return 
ADDEQ_TOK
;}

957 
YY_BREAK


959 
YY_RULE_SETUP


961 {return 
MODEQ_TOK
;}

962 
YY_BREAK


964 
YY_RULE_SETUP


966 {return 
MULTEQ_TOK
;}

967 
YY_BREAK


969 
YY_RULE_SETUP


971 {return 
DIVEQ_TOK
;}

972 
YY_BREAK


974 
YY_RULE_SETUP


976 {return 
BITANDEQ_TOK
;}

977 
YY_BREAK


979 
YY_RULE_SETUP


981 {return 
BITOREQ_TOK
;}

982 
YY_BREAK


984 
YY_RULE_SETUP


986 {return 
BITXOREQ_TOK
;}

987 
YY_BREAK


989 
YY_RULE_SETUP


991 {return 
GTEQ_TOK
;}

992 
YY_BREAK


994 
YY_RULE_SETUP


996 {return 
LSEQ_TOK
;}

997 
YY_BREAK


999 
YY_RULE_SETUP


1001 {return 
AND_TOK
;}

1002 
YY_BREAK


1004 
YY_RULE_SETUP


1006 {return 
OR_TOK
;}

1007 
YY_BREAK


1009 
YY_RULE_SETUP


1011 {return 
EQ2_TOK
;}

1012 
YY_BREAK


1014 
YY_RULE_SETUP


1016 {return 
NOTEQ_TOK
;}

1017 
YY_BREAK


1019 
YY_RULE_SETUP


1021 {return 
LSHIFT_TOK
;}

1022 
YY_BREAK


1024 
YY_RULE_SETUP


1026 {return 
RSHIFT_TOK
;}

1027 
YY_BREAK


1029 
YY_RULE_SETUP


1031 {return 
INC_TOK
;}

1032 
YY_BREAK


1034 
YY_RULE_SETUP


1036 {return 
DEC_TOK
;}

1037 
YY_BREAK


1039 
YY_RULE_SETUP


1041 {return 
INT_TOK
;}

1042 
YY_BREAK


1045 
YY_RULE_SETUP


1048 
YY_BREAK


1050 
YY_RULE_SETUP


1052 {return 
ID_TOK
;}

1053 
YY_BREAK


1055 
YY_RULE_SETUP


1057 {return 
atoi
(
yyt
);}

1058 
YY_BREAK


1060 
YY_RULE_SETUP


1062 {
ECHO
; 
printf
(" - Illegal Identifier\n");}

1063 
YY_BREAK


1065 
YY_RULE_SETUP


1067 {
ECHO
; 
printf
(" - Unknown character\n");}

1068 
YY_BREAK


1070 
YY_RULE_SETUP


1072 
ECHO
;

1073 
	gYY_BREAK


1075 case 
YY_STATE_EOF
(
INITIAL
):

1076 
yyterminate
();

1078 case 
	gYY_END_OF_BUFFER
:

1081 int 
yy_amount_of_matched_text
 = (int) (
yy_cp
 - (
yyt_ptr
)) - 1;

1084 *
	gyy_cp
 = (
yy_hold_char
);

1085 
YY_RESTORE_YY_MORE_OFFSET


1087 if ( 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_buffer_status
 == 
YY_BUFFER_NEW
 )

1098 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->yy_n_chars;

1099 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_input_file
 = 
yyin
;

1100 
	gYY_CURRENT_BUFFER_LVALUE
->
	gyy_buffer_status
 = 
YY_BUFFER_NORMAL
;

1110 if ( (
	gyy_c_buf_p
) <= &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] )

1112 
yy_state_type
 
yy_next_state
;

1114 (
	gyy_c_buf_p
) = (
yyt_ptr
) + 
yy_amount_of_matched_text
;

1116 
	gyy_current_state
 = 
yy_get_previous_state
( );

1127 
	gyy_next_state
 = 
yy_try_NUL_trans
( 
yy_current_state
 );

1129 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1131 if ( 
	gyy_next_state
 )

1134 
	gyy_cp
 = ++(
yy_c_buf_p
);

1135 
	gyy_current_state
 = 
yy_next_state
;

1136 goto 
	gyy_match
;

1141 
	gyy_cp
 = (
yy_c_buf_p
);

1142 goto 
	gyy_find_action
;

1146 else switch ( 
yy_get_next_buffer
( ) )

1148 case 
	gEOB_ACT_END_OF_FILE
:

1150 (
yy_did_buffer_switch_on_eof
) = 0;

1152 if ( 
yywrap
( ) )

1163 (
	gyy_c_buf_p
) = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1165 
	gyy_act
 = 
YY_STATE_EOF
(
YY_START
);

1166 goto 
	gdo_action
;

1171 if ( ! (
	gyy_did_buffer_switch_on_eof
) )

1172 
	gYY_NEW_FILE
;

1177 case 
	gEOB_ACT_CONTINUE_SCAN
:

1178 (
yy_c_buf_p
) =

1179 (
yyt_ptr
) + 
yy_amount_of_matched_text
;

1181 
	gyy_current_state
 = 
yy_get_previous_state
( );

1183 
	gyy_cp
 = (
yy_c_buf_p
);

1184 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1185 goto 
	gyy_match
;

1187 case 
	gEOB_ACT_LAST_MATCH
:

1188 (
yy_c_buf_p
) =

1189 &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)];

1191 
	gyy_current_state
 = 
yy_get_previous_state
( );

1193 
	gyy_cp
 = (
yy_c_buf_p
);

1194 
	gyy_bp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
;

1195 goto 
	gyy_find_action
;

1201 
YY_FATAL_ERROR
(

1215 static int 
	$yy_get_next_buffer
 (void)

1217 char *
dest
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
;

1218 char *
source
 = (
yyt_ptr
);

1219 
yy_size_t
 
number_to_move
, 
i
;

1220 int 
ret_val
;

1222 if ( (
yy_c_buf_p
) > &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
) + 1] )

1223 
	`YY_FATAL_ERROR
(

1226 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_fill_buffer
 == 0 )

1228 if ( (
yy_c_buf_p
) - (
yyt_ptr
) - 
YY_MORE_ADJ
 == 1 )

1233 return 
EOB_ACT_END_OF_FILE
;

1241 return 
EOB_ACT_LAST_MATCH
;

1248 
number_to_move
 = (
yy_size_t
) ((
yy_c_buf_p
) - (
yyt_ptr
)) - 1;

1250 for ( 
i
 = 0; i < 
number_to_move
; ++i )

1251 *(
dest
++) = *(
source
++);

1253 if ( 
YY_CURRENT_BUFFER_LVALUE
->
yy_buffer_status
 == 
YY_BUFFER_EOF_PENDING
 )

1257 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars) = 0;

1261 
yy_size_t
 
num_to_read
 =

1262 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 - 
number_to_move
 - 1;

1264 while ( 
num_to_read
 <= 0 )

1268 
YY_BUFFER_STATE
 
b
 = 
YY_CURRENT_BUFFER_LVALUE
;

1270 int 
yy_c_buf_p_offset
 =

1271 (int) ((
yy_c_buf_p
) - 
b
->
yy_ch_buf
);

1273 if ( 
b
->
yy_is_our_buffer
 )

1275 
yy_size_t
 
new_size
 = 
b
->
yy_buf_size
 * 2;

1277 if ( 
new_size
 <= 0 )

1278 
b
->
yy_buf_size
 += b->yy_buf_size / 8;

1280 
b
->
yy_buf_size
 *= 2;

1282 
b
->
yy_ch_buf
 = (char *)

1284 
	`yyrealloc
((void *) 
b
->
yy_ch_buf
,b->
yy_buf_size
 + 2 );

1288 
b
->
yy_ch_buf
 = 0;

1290 if ( ! 
b
->
yy_ch_buf
 )

1291 
	`YY_FATAL_ERROR
(

1294 (
yy_c_buf_p
) = &
b
->
yy_ch_buf
[
yy_c_buf_p_offset
];

1296 
num_to_read
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 -

1297 
number_to_move
 - 1;

1301 if ( 
num_to_read
 > 
YY_READ_BUF_SIZE
 )

1302 
num_to_read
 = 
YY_READ_BUF_SIZE
;

1305 
	`YY_INPUT
( (&
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[
number_to_move
]),

1306 (
yy_n_chars
), 
num_to_read
 );

1308 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1311 if ( (
yy_n_chars
) == 0 )

1313 if ( 
number_to_move
 == 
YY_MORE_ADJ
 )

1315 
ret_val
 = 
EOB_ACT_END_OF_FILE
;

1316 
	`yyrestart
(
yyin
 );

1321 
ret_val
 = 
EOB_ACT_LAST_MATCH
;

1322 
YY_CURRENT_BUFFER_LVALUE
->
yy_buffer_status
 =

1323 
YY_BUFFER_EOF_PENDING
;

1328 
ret_val
 = 
EOB_ACT_CONTINUE_SCAN
;

1330 if ((int) ((
yy_n_chars
) + 
number_to_move
) > 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
) {

1332 int 
new_size
 = (
yy_n_chars
) + 
number_to_move
 + ((yy_n_chars) >> 1);

1333 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 = (char *) 
	`yyrealloc
((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,
new_size
 );

1334 if ( ! 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 )

1335 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_get_next_buffer()" );

1338 (
yy_n_chars
) += 
number_to_move
;

1339 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] = 
YY_END_OF_BUFFER_CHAR
;

1340 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
) + 1] = 
YY_END_OF_BUFFER_CHAR
;

1342 (
yyt_ptr
) = &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[0];

1344 return 
ret_val
;

1345 
	}
}

1349 static 
yy_state_type
 
	$yy_get_previous_state
 (void)

1351 
yy_state_type
 
yy_current_state
;

1352 char *
yy_cp
;

1354 
yy_current_state
 = (
yy_start
);

1356 for ( 
yy_cp
 = (
yyt_ptr
) + 
YY_MORE_ADJ
; yy_cp < (
yy_c_buf_p
); ++yy_cp )

1358 
YY_CHAR
 
yy_c
 = (*
yy_cp
 ? 
yy_ec
[
	`YY_SC_TO_UI
(*yy_cp)] : 1);

1359 if ( 
yy_accept
[
yy_current_state
] )

1361 (
yy_last_accepting_state
) = 
yy_current_state
;

1362 (
yy_last_accepting_cpos
) = 
yy_cp
;

1364 while ( 
yy_chk
[
yy_base
[
yy_current_state
] + 
yy_c
] != yy_current_state )

1366 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

1367 if ( 
yy_current_state
 >= 91 )

1368 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

1370 
yy_current_state
 = 
yy_nxt
[
yy_base
[yy_current_state] + (unsigned int) 
yy_c
];

1373 return 
yy_current_state
;

1374 
	}
}

1381 static 
yy_state_type
 
	$yy_try_NUL_trans
 (
yy_state_type
 
yy_current_state
 )

1383 int 
yy_is_jam
;

1384 char *
yy_cp
 = (
yy_c_buf_p
);

1386 
YY_CHAR
 
yy_c
 = 1;

1387 if ( 
yy_accept
[
yy_current_state
] )

1389 (
yy_last_accepting_state
) = 
yy_current_state
;

1390 (
yy_last_accepting_cpos
) = 
yy_cp
;

1392 while ( 
yy_chk
[
yy_base
[
yy_current_state
] + 
yy_c
] != yy_current_state )

1394 
yy_current_state
 = (int) 
yy_def
[yy_current_state];

1395 if ( 
yy_current_state
 >= 91 )

1396 
yy_c
 = 
yy_meta
[(unsigned int) yy_c];

1398 
yy_current_state
 = 
yy_nxt
[
yy_base
[yy_current_state] + (unsigned int) 
yy_c
];

1399 
yy_is_jam
 = (
yy_current_state
 == 90);

1401 return 
yy_is_jam
 ? 0 : 
yy_current_state
;

1402 
	}
}

1404 #ifndef 
YY_NO_UNPUT


1406 static void 
	$yyunput
 (int 
c
, char * 
yy_bp
 )

1408 char *
yy_cp
;

1410 
yy_cp
 = (
yy_c_buf_p
);

1413 *
yy_cp
 = (
yy_hold_char
);

1415 if ( 
yy_cp
 < 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 + 2 )

1418 
yy_size_t
 
number_to_move
 = (
yy_n_chars
) + 2;

1419 char *
dest
 = &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[

1420 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
 + 2];

1421 char *
source
 =

1422 &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[
number_to_move
];

1424 while ( 
source
 > 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 )

1425 *--
dest
 = *--
source
;

1427 
yy_cp
 += (int) (
dest
 - 
source
);

1428 
yy_bp
 += (int) (
dest
 - 
source
);

1429 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 =

1430 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_size
;

1432 if ( 
yy_cp
 < 
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
 + 2 )

1433 
	`YY_FATAL_ERROR
( "flex scanner push-back overflow" );

1436 *--
yy_cp
 = (char) 
c
;

1438 (
yyt_ptr
) = 
yy_bp
;

1439 (
yy_hold_char
) = *
yy_cp
;

1440 (
yy_c_buf_p
) = 
yy_cp
;

1441 
	}
}

1445 #ifndef 
YY_NO_INPUT


1446 #ifdef 
__cplusplus


1447 static int 
	$yyinput
 (void)

1449 static int 
	$input
 (void)

1453 int 
c
;

1455 *(
yy_c_buf_p
) = (
yy_hold_char
);

1457 if ( *(
yy_c_buf_p
) == 
YY_END_OF_BUFFER_CHAR
 )

1463 if ( (
yy_c_buf_p
) < &
YY_CURRENT_BUFFER_LVALUE
->
yy_ch_buf
[(
yy_n_chars
)] )

1465 *(
yy_c_buf_p
) = '\0';

1469 
yy_size_t
 
offset
 = (
yy_c_buf_p
) - (
yyt_ptr
);

1470 ++(
yy_c_buf_p
);

1472 switch ( 
	`yy_get_next_buffer
( ) )

1474 case 
EOB_ACT_LAST_MATCH
:

1486 
	`yyrestart
(
yyin
 );

1490 case 
EOB_ACT_END_OF_FILE
:

1492 if ( 
	`yywrap
( ) )

1493 return 
EOF
;

1495 if ( ! (
yy_did_buffer_switch_on_eof
) )

1496 
YY_NEW_FILE
;

1497 #ifdef 
__cplusplus


1498 return 
	`yyinput
();

1500 return 
	`input
();

1504 case 
EOB_ACT_CONTINUE_SCAN
:

1505 (
yy_c_buf_p
) = (
yyt_ptr
) + 
offset
;

1511 
c
 = *(unsigned char *) (
yy_c_buf_p
);

1512 *(
yy_c_buf_p
) = '\0';

1513 (
yy_hold_char
) = *++(
yy_c_buf_p
);

1515 return 
c
;

1516 
	}
}

1524 void 
	$yyrestart
 (
FILE
 * 
input_file
 )

1527 if ( ! 
YY_CURRENT_BUFFER
 ){

1528 
	`yyensure_buffer_stack
 ();

1529 
YY_CURRENT_BUFFER_LVALUE
 =

1530 
	`yy_create_buffer
(
yyin
,
YY_BUF_SIZE
 );

1533 
	`yy_init_buffer
(
YY_CURRENT_BUFFER
,
input_file
 );

1534 
	`yy_load_buffer_state
( );

1535 
	}
}

1541 void 
	$yy_switch_to_buffer
 (
YY_BUFFER_STATE
 
new_buffer
 )

1549 
	`yyensure_buffer_stack
 ();

1550 if ( 
YY_CURRENT_BUFFER
 == 
new_buffer
 )

1553 if ( 
YY_CURRENT_BUFFER
 )

1556 *(
yy_c_buf_p
) = (
yy_hold_char
);

1557 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
 = (
yy_c_buf_p
);

1558 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1561 
YY_CURRENT_BUFFER_LVALUE
 = 
new_buffer
;

1562 
	`yy_load_buffer_state
( );

1569 (
yy_did_buffer_switch_on_eof
) = 1;

1570 
	}
}

1572 static void 
	$yy_load_buffer_state
 (void)

1574 (
yy_n_chars
) = 
YY_CURRENT_BUFFER_LVALUE
->yy_n_chars;

1575 (
yyt_ptr
) = (
yy_c_buf_p
) = 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
;

1576 
yyin
 = 
YY_CURRENT_BUFFER_LVALUE
->
yy_input_file
;

1577 (
yy_hold_char
) = *(
yy_c_buf_p
);

1578 
	}
}

1586 
YY_BUFFER_STATE
 
	$yy_create_buffer
 (
FILE
 * 
file
, int 
size
 )

1588 
YY_BUFFER_STATE
 
b
;

1590 
b
 = (
YY_BUFFER_STATE
) 
	`yyalloc
(sizeof( struct 
yy_buffer_state
 ) );

1591 if ( ! 
b
 )

1592 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_create_buffer()" );

1594 
b
->
yy_buf_size
 = (
yy_size_t
)
size
;

1599 
b
->
yy_ch_buf
 = (char *) 
	`yyalloc
(b->
yy_buf_size
 + 2 );

1600 if ( ! 
b
->
yy_ch_buf
 )

1601 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_create_buffer()" );

1603 
b
->
yy_is_our_buffer
 = 1;

1605 
	`yy_init_buffer
(
b
,
file
 );

1607 return 
b
;

1608 
	}
}

1614 void 
	$yy_delete_buffer
 (
YY_BUFFER_STATE
 
b
 )

1617 if ( ! 
b
 )

1620 if ( 
b
 == 
YY_CURRENT_BUFFER
 )

1621 
YY_CURRENT_BUFFER_LVALUE
 = (
YY_BUFFER_STATE
) 0;

1623 if ( 
b
->
yy_is_our_buffer
 )

1624 
	`yyfree
((void *) 
b
->
yy_ch_buf
 );

1626 
	`yyfree
((void *) 
b
 );

1627 
	}
}

1633 static void 
	$yy_init_buffer
 (
YY_BUFFER_STATE
 
b
, 
FILE
 * 
file
 )

1636 int 
oerrno
 = 
errno
;

1638 
	`yy_flush_buffer
(
b
 );

1640 
b
->
yy_input_file
 = 
file
;

1641 
b
->
yy_fill_buffer
 = 1;

1647 if (
b
 != 
YY_CURRENT_BUFFER
){

1648 
b
->
yy_bs_lineno
 = 1;

1649 
b
->
yy_bs_column
 = 0;

1652 
b
->
yy_is_interactive
 = 
file
 ? (
	`isatty
( 
	`fileno
(file) ) > 0) : 0;

1654 
errno
 = 
oerrno
;

1655 
	}
}

1661 void 
	$yy_flush_buffer
 (
YY_BUFFER_STATE
 
b
 )

1663 if ( ! 
b
 )

1666 
b
->
yy_n_chars
 = 0;

1672 
b
->
yy_ch_buf
[0] = 
YY_END_OF_BUFFER_CHAR
;

1673 
b
->
yy_ch_buf
[1] = 
YY_END_OF_BUFFER_CHAR
;

1675 
b
->
yy_buf_pos
 = &b->
yy_ch_buf
[0];

1677 
b
->
yy_at_bol
 = 1;

1678 
b
->
yy_buffer_status
 = 
YY_BUFFER_NEW
;

1680 if ( 
b
 == 
YY_CURRENT_BUFFER
 )

1681 
	`yy_load_buffer_state
( );

1682 
	}
}

1690 void 
	$yypush_buffer_state
 (
YY_BUFFER_STATE
 
new_buffer
 )

1692 if (
new_buffer
 == 
NULL
)

1695 
	`yyensure_buffer_stack
();

1698 if ( 
YY_CURRENT_BUFFER
 )

1701 *(
yy_c_buf_p
) = (
yy_hold_char
);

1702 
YY_CURRENT_BUFFER_LVALUE
->
yy_buf_pos
 = (
yy_c_buf_p
);

1703 
YY_CURRENT_BUFFER_LVALUE
->
yy_n_chars
 = (yy_n_chars);

1707 if (
YY_CURRENT_BUFFER
)

1708 (
yy_buffer_stack_top
)++;

1709 
YY_CURRENT_BUFFER_LVALUE
 = 
new_buffer
;

1712 
	`yy_load_buffer_state
( );

1713 (
yy_did_buffer_switch_on_eof
) = 1;

1714 
	}
}

1720 void 
	$yypop_buffer_state
 (void)

1722 if (!
YY_CURRENT_BUFFER
)

1725 
	`yy_delete_buffer
(
YY_CURRENT_BUFFER
 );

1726 
YY_CURRENT_BUFFER_LVALUE
 = 
NULL
;

1727 if ((
yy_buffer_stack_top
) > 0)

1728 --(
yy_buffer_stack_top
);

1730 if (
YY_CURRENT_BUFFER
) {

1731 
	`yy_load_buffer_state
( );

1732 (
yy_did_buffer_switch_on_eof
) = 1;

1734 
	}
}

1739 static void 
	$yyensure_buffer_stack
 (void)

1741 
yy_size_t
 
num_to_alloc
;

1743 if (!(
yy_buffer_stack
)) {

1749 
num_to_alloc
 = 1;

1750 (
yy_buffer_stack
) = (struct 
yy_buffer_state
**)
yyalloc


1751 (
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*)

1753 if ( ! (
yy_buffer_stack
) )

1754 
	`YY_FATAL_ERROR
( "out of dynamic memory in yyensure_buffer_stack()" );

1756 
	`memset
((
yy_buffer_stack
), 0, 
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*));

1758 (
yy_buffer_stack_max
) = 
num_to_alloc
;

1759 (
yy_buffer_stack_top
) = 0;

1763 if ((
yy_buffer_stack_top
) >= ((
yy_buffer_stack_max
)) - 1){

1766 
yy_size_t
 
grow_size
 = 8 ;

1768 
num_to_alloc
 = (
yy_buffer_stack_max
) + 
grow_size
;

1769 (
yy_buffer_stack
) = (struct 
yy_buffer_state
**)
yyrealloc


1770 ((
yy_buffer_stack
),

1771 
num_to_alloc
 * sizeof(struct 
yy_buffer_state
*)

1773 if ( ! (
yy_buffer_stack
) )

1774 
	`YY_FATAL_ERROR
( "out of dynamic memory in yyensure_buffer_stack()" );

1777 
	`memset
((
yy_buffer_stack
) + (
yy_buffer_stack_max
), 0, 
grow_size
 * sizeof(struct 
yy_buffer_state
*));

1778 (
yy_buffer_stack_max
) = 
num_to_alloc
;

1780 
	}
}

1788 
YY_BUFFER_STATE
 
	$yy_scan_buffer
 (char * 
base
, 
yy_size_t
 
size
 )

1790 
YY_BUFFER_STATE
 
b
;

1792 if ( 
size
 < 2 ||

1793 
base
[
size
-2] != 
YY_END_OF_BUFFER_CHAR
 ||

1794 
base
[
size
-1] != 
YY_END_OF_BUFFER_CHAR
 )

1798 
b
 = (
YY_BUFFER_STATE
) 
	`yyalloc
(sizeof( struct 
yy_buffer_state
 ) );

1799 if ( ! 
b
 )

1800 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_scan_buffer()" );

1802 
b
->
yy_buf_size
 = 
size
 - 2;

1803 
b
->
yy_buf_pos
 = b->
yy_ch_buf
 = 
base
;

1804 
b
->
yy_is_our_buffer
 = 0;

1805 
b
->
yy_input_file
 = 0;

1806 
b
->
yy_n_chars
 = b->
yy_buf_size
;

1807 
b
->
yy_is_interactive
 = 0;

1808 
b
->
yy_at_bol
 = 1;

1809 
b
->
yy_fill_buffer
 = 0;

1810 
b
->
yy_buffer_status
 = 
YY_BUFFER_NEW
;

1812 
	`yy_switch_to_buffer
(
b
 );

1814 return 
b
;

1815 
	}
}

1825 
YY_BUFFER_STATE
 
	$yy_scan_string
 (
yyconst
 char * 
yystr
 )

1828 return 
	`yy_scan_bytes
(
yystr
,
	`strlen
(yystr) );

1829 
	}
}

1838 
YY_BUFFER_STATE
 
	$yy_scan_bytes
 (
yyconst
 char * 
yybytes
, 
yy_size_t
 
_yybytes_len
 )

1840 
YY_BUFFER_STATE
 
b
;

1841 char *
buf
;

1842 
yy_size_t
 
n
;

1843 
yy_size_t
 
i
;

1846 
n
 = 
_yybytes_len
 + 2;

1847 
buf
 = (char *) 
	`yyalloc
(
n
 );

1848 if ( ! 
buf
 )

1849 
	`YY_FATAL_ERROR
( "out of dynamic memory in yy_scan_bytes()" );

1851 for ( 
i
 = 0; i < 
_yybytes_len
; ++i )

1852 
buf
[
i
] = 
yybytes
[i];

1854 
buf
[
_yybytes_len
] = buf[_yybytes_len+1] = 
YY_END_OF_BUFFER_CHAR
;

1856 
b
 = 
	`yy_scan_buffer
(
buf
,
n
 );

1857 if ( ! 
b
 )

1858 
	`YY_FATAL_ERROR
( "bad buffer in yy_scan_bytes()" );

1863 
b
->
yy_is_our_buffer
 = 1;

1865 return 
b
;

1866 
	}
}

1868 #ifndef 
YY_EXIT_FAILURE


1869 #define 
	#YY_EXIT_FAILURE
 2

	)

1872 static void 
	$yy_fatal_error
 (
yyconst
 char* 
msg
 )

1874 (void) 
	`fprintf
( 
stderr
, "%s\n", 
msg
 );

1875 
	`exit
( 
YY_EXIT_FAILURE
 );

1876 
	}
}

1880 #undef 
yyless


1881 #define 
	#yyless
(
n
) \

1885 int 
yyless_macro_arg
 = (
n
); \

1886 
	`YY_LESS_LINENO
(
yyless_macro_arg
);\

1887 
yyt
[
yyleng
] = (
yy_hold_char
); \

1888 (
yy_c_buf_p
) = 
yyt
 + 
yyless_macro_arg
; \

1889 (
yy_hold_char
) = *(
yy_c_buf_p
); \

1890 *(
yy_c_buf_p
) = '\0'; \

1891 
yyleng
 = 
yyless_macro_arg
; \

1893 while ( 0 )

	)

1900 int 
	$yyget_lineno
 (void)

1903 return 
yylineno
;

1904 
	}
}

1909 
FILE
 *
	$yyget_in
 (void)

1911 return 
yyin
;

1912 
	}
}

1917 
FILE
 *
	$yyget_out
 (void)

1919 return 
yyout
;

1920 
	}
}

1925 
yy_size_t
 
	$yyget_leng
 (void)

1927 return 
yyleng
;

1928 
	}
}

1934 char *
	$yyget_text
 (void)

1936 return 
yyt
;

1937 
	}
}

1943 void 
	$yyset_lineno
 (int 
_line_number
 )

1946 
yylineno
 = 
_line_number
;

1947 
	}
}

1955 void 
	$yyset_in
 (
FILE
 * 
_in_str
 )

1957 
yyin
 = 
_in_str
 ;

1958 
	}
}

1960 void 
	$yyset_out
 (
FILE
 * 
_out_str
 )

1962 
yyout
 = 
_out_str
 ;

1963 
	}
}

1965 int 
	$yyget_debug
 (void)

1967 return 
yy_flex_debug
;

1968 
	}
}

1970 void 
	$yyset_debug
 (int 
_bdebug
 )

1972 
yy_flex_debug
 = 
_bdebug
 ;

1973 
	}
}

1975 static int 
	$yy_init_globals
 (void)

1981 (
yy_buffer_stack
) = 0;

1982 (
yy_buffer_stack_top
) = 0;

1983 (
yy_buffer_stack_max
) = 0;

1984 (
yy_c_buf_p
) = (char *) 0;

1985 (
yy_init
) = 0;

1986 (
yy_start
) = 0;

1989 #ifdef 
YY_STDINIT


1990 
yyin
 = 
stdin
;

1991 
yyout
 = 
stdout
;

1993 
yyin
 = (
FILE
 *) 0;

1994 
yyout
 = (
FILE
 *) 0;

2001 
	}
}

2004 int 
	$yylex_destroy
 (void)

2008 while(
YY_CURRENT_BUFFER
){

2009 
	`yy_delete_buffer
(
YY_CURRENT_BUFFER
 );

2010 
YY_CURRENT_BUFFER_LVALUE
 = 
NULL
;

2011 
	`yypop_buffer_state
();

2015 
	`yyfree
((
yy_buffer_stack
) );

2016 (
yy_buffer_stack
) = 
NULL
;

2020 
	`yy_init_globals
( );

2023 
	}
}

2029 #ifndef 
yyt_ptr


2030 static void 
	$yy_flex_strncpy
 (char* 
s1
, 
yyconst
 char * 
s2
, int 
n
 )

2033 int 
i
;

2034 for ( 
i
 = 0; i < 
n
; ++i )

2035 
s1
[
i
] = 
s2
[i];

2036 
	}
}

2039 #ifdef 
YY_NEED_STRLEN


2040 static int 
	$yy_flex_strlen
 (
yyconst
 char * 
s
 )

2042 int 
n
;

2043 for ( 
n
 = 0; 
s
[n]; ++n )

2046 return 
n
;

2047 
	}
}

2050 void *
	$yyalloc
 (
yy_size_t
 
size
 )

2052 return (void *) 
	`malloc
( 
size
 );

2053 
	}
}

2055 void *
	$yyrealloc
 (void * 
ptr
, 
yy_size_t
 
size
 )

2065 return (void *) 
	`realloc
( (char *) 
ptr
, 
size
 );

2066 
	}
}

2068 void 
	$yyfree
 (void * 
ptr
 )

2070 
	`free
( (char *) 
ptr
 );

2071 
	}
}

2073 #define 
	#YYTABLES_NAME
 "yytables"

	)

2079 int 
	$main
(int 
argc
, char *
argv
[])

2081 if(
argc
 == 1)

2083 
	`printf
("No file specified!..Reading from stdin and writing to stdout.\n");

2084 
yyin
 = 
stdin
;

2085 
yyout
 = 
stdout
;

2087 else if(
argc
 == 2)

2089 
	`printf
("No output file specified!..Writing to stdout.\n");

2090 
yyout
 = 
stdout
;

2091 
yyin
 = 
	`fopen
(
argv
[1], "r");

2095 
yyin
 = 
	`fopen
(
argv
[1], "r");

2096 
yyout
 = 
	`fopen
(
argv
[2], "w");

2099 int 
token
;

2100 while(
token
 = 
	`yylex
())

2102 
	`fprintf
(
yyout
, "%d\n", 
token
);

2104 
	`fclose
(
yyin
);

2105 
	`fclose
(
yyout
);

2106 
	}
}

2107 int 
	$yywrap
(){
	}
}

	@Assignment3/lexical.hpp

2 #define 
	#LPAREN_TOK
 '('

	)

3 #define 
	#RPAREN_TOK
 ')'

	)

4 #define 
	#GT_TOK
 '>'

	)

5 #define 
	#LS_TOK
 '<'

	)

6 #define 
	#EQ_TOK
 '='

	)

7 #define 
	#MINUS_TOK
 '-'

	)

8 #define 
	#ADDITION_TOK
 '+'

	)

9 #define 
	#MULTI_TOK
 '*'

	)

10 #define 
	#DIVISION_TOK
 '/'

	)

11 #define 
	#MOD_TOK
 '%'

	)

12 #define 
	#LCURLY_TOK
 '{'

	)

13 #define 
	#RCURLY_TOK
 '}'

	)

14 #define 
	#BITOR_TOK
 '|'

	)

15 #define 
	#BITAND_TOK
 '&'

	)

16 #define 
	#XOR_TOK
 '^'

	)

17 #define 
	#NOT_TOK
 '!'

	)

18 #define 
	#COMMA_TOK
 ','

	)

19 #define 
	#SEMCOL_TOK
 ';'

	)

22 #define 
	#MINEQ_TOK
 300

	)

23 #define 
	#ADDEQ_TOK
 301

	)

24 #define 
	#MODEQ_TOK
 302

	)

25 #define 
	#MULTEQ_TOK
 303

	)

26 #define 
	#DIVEQ_TOK
 304

	)

27 #define 
	#BITANDEQ_TOK
 305

	)

28 #define 
	#BITOREQ_TOK
 306

	)

29 #define 
	#BITXOREQ_TOK
 307

	)

32 #define 
	#FOR_TOK
 256

	)

33 #define 
	#SWITCH_TOK
 257

	)

34 #define 
	#CASE_TOK
 258

	)

35 #define 
	#IF_TOK
 259

	)

36 #define 
	#ELSE_TOK
 260

	)

37 #define 
	#VOID_TOK
 261

	)

38 #define 
	#WHILE_TOK
 262

	)

41 #define 
	#ID_TOK
 350

	)

42 #define 
	#INTCONST
 351

	)

44 #define 
	#GTEQ_TOK
 400

	)

45 #define 
	#LSEQ_TOK
 401

	)

46 #define 
	#AND_TOK
 402

	)

47 #define 
	#OR_TOK
 403

	)

48 #define 
	#EQ2_TOK
 404

	)

49 #define 
	#NOTEQ_TOK
 405

	)

50 #define 
	#LSHIFT_TOK
 406

	)

51 #define 
	#RSHIFT_TOK
 407

	)

53 #define 
	#INC_TOK
 450

	)

54 #define 
	#DEC_TOK
 451

	)

56 #define 
	#INT_TOK
 500

	)

57 #define 
	#FLOAT_TOK
 501

	@Pyth/ncl1701.py

1 
	gT
 = int(
	$raw_input
())

2 for 
t
 
in
 
	$range
(
T
):

3 
n
 = int(
	$raw_input
())

4 
st
 = 
	$raw_input
()

5 
st
 = 
	$sorted
(
st
)

6 
print
 ''.
	`join
(
st
)

	@Pyth/neO01.py

1 
def
 
	$calc
(
A
, 
n
):

2 
pos
 = 0

3 for 
i
 
in
 
	$range
(
n
):

4 if 
A
[
i
] >= 0:

5 
pos
 = 
i


7 
dp
 = [0]*(
pos
+1)

9 
B
 = 
A
[
pos
:]

10 
C
 = 
A
[:
pos
]

11 
sb
 = 
	$sum
(
B
)

12 
l
 = 
	$len
(
B
)

13 
dp
 = []

14 
dp
.
	`append
(
sb
*
l
 + 
	$sum
(
C
))

15 
sc
 = 
	$sum
(
C
)

16 
lc
 = 
	$len
(
C
)

17 #print 
sb
, 
sc


18 
i
 = 
pos
-1

19 
k
 = 1

20 while 
i
 >= 0:

21 
sb
 = sb+
C
[
i
]

22 
sc
 = sc-
C
[
i
]

23 
dp
.
	`append
(
sb
*(
l
+
k
) + 
sc
)

24 
i
 -= 1

25 
k
 += 1

26 #print 
dp


27 return 
	$max
(
dp
)

29 
T
 = int(
	$raw_input
())

30 for 
t
 
in
 
	$range
(
T
):

31 
n
 = int(
	$raw_input
())

32 
A
 = 
	`map
(int, 
	`raw_input
().
	$split
())

33 
A
.
	$sort
()

35 
flag
 = 
	`all
(
i
 <= 0 for i 
in
 
A
)

36 for 
i
 
in
 
	$range
(
n
):

37 if 
A
[
i
] >= 0:

38 
pos
 = 
i


40 if 
flag
 == 
False
:

41 
print
 
	$calc
(
A
, 
n
)

43 
print
 
	`sum
(
A
)

	@Pyth/sumq.py

1 
	gmod
 = 1000000007

2 
import
 
bisect


4 
T
 = int(
	$raw_input
())

5 for 
t
 
in
 
	$range
(
T
):

6 
p
, 
q
, 
r
 = 
	`map
(int, 
	`raw_input
().
	$split
())

7 
A
 = 
	`map
(int, 
	`raw_input
().
	$split
())

8 
B
 = 
	`map
(int, 
	`raw_input
().
	$split
())

9 
C
 = 
	`map
(int, 
	`raw_input
().
	$split
())

10 
A
.
	$sort
()

11 
B
.
	$sort
()

12 
C
.
	$sort
()

13 
a
 = 
bisect
.
	`bisect
(
A
, 
B
[-1])

14 
c
 = 
bisect
.
	`bisect
(
C
, 
B
[-1])

15 
A
 = A[:
a
]

16 
C
 = C[:
c
]

17 #print 
a
, 
c


18 
sa
 = [0]*(
a
+1)

19 
sc
 = [0]*(
c
+1)

20 for 
i
 
in
 
	`range
(1, 
a
+1):

21 
sa
[
i
] = sa[i-1]+
A
[i-1]

22 for 
i
 
in
 
	`range
(1, 
c
+1):

23 
sc
[
i
] = sc[i-1] + 
C
[i-1]

24 
print
 
sa
, 
sc


25 
s
 = 0

26 for 
i
 
in
 
B
:

27 
la
 = 
bisect
.
	$bisect
(
A
, 
i
)

28 
lc
 = 
bisect
.
	$bisect
(
C
, 
i
)

29 #print 
la
, 
lc


30 
s
 += ((
sa
[
la
] + la*
i
)%
mod
) * ((
lc
*i + 
sc
[lc]) % mod)

31 
s
 = s%
mod


33 
print
 
s
%
mod


	@Pyth/unionset.py

2 
	gT
 = int(
	$raw_input
())

3 for 
t
 
in
 
	$range
(
T
):

4 
n
, 
k
 = 
	`map
(int, 
	`raw_input
().
	$split
())

5 
bitmap
 = []

6 
cnt
 = []

7 
f
 = 0

8 for 
i
 
in
 
	$range
(
n
):

9 
temp
 = ['0']*
k


11 
A
 = 
	`map
(int, 
	`raw_input
().
	$split
())

12 
l
 = 
A
[0]

13 if 
l
 == 
k
:

14 
f
 += 1

15 
A
 = A[1:]

16 for 
e
 
in
 
A
:

17 
temp
[
e
-1] = '1'

18 #print 
temp
,

19 
bitmap
.
	`append
(int(''.
	`join
(
temp
), 2))

20 
cnt
.
	$append
(
l
)

22 #print 
bitmap


23 
co
 = 0

24 
num
 = int(''.
	`join
(['1']*
k
), 2)

25 #print 
f


26 
co
 += 
f
*(f-1)/2 + f*(
n
-f)

27 for 
i
 
in
 
	`range
(
n
-1):

28 if 
cnt
[
i
] == 
k
:

30 for 
j
 
in
 
	`range
(
i
+1, 
n
):

31 if 
cnt
[
i
]+cnt[
j
] < 
k
 
or
 cnt[j] == k:

33 if 
bitmap
[
i
]|bitmap[
j
] == 
num
:

34 
co
 += 1

37 
print
 
co


	@lexical_hardcoded.cpp

1 #include 
	~<bits/stdc++.h
>

2 #include 
	~<ctype.h
>

3 #include 
	~"lexical_hardcoded.hpp
"

4 
using
 
namespace
 
	gstd
;

6 
FILE
 *
	gyyin
, *
	gyyout
;

7 char *
	gyyt
;

8 int 
	gyyleng
;

10 int 
yylex
();

11 int 
	$isReserved
(char 
a
[])

13 if(!
	`strcmp
(
a
, "for"))

14 return 
FOR_TOK
;

15 if(!
	`strcmp
(
a
, "switch"))

16 return 
SWITCH_TOK
;

17 if(!
	`strcmp
(
a
, "case"))

18 return 
CASE_TOK
;

19 if(!
	`strcmp
(
a
, "if"))

20 return 
IF_TOK
;

21 if(!
	`strcmp
(
a
, "else"))

22 return 
ELSE_TOK
;

23 if(!
	`strcmp
(
a
, "main"))

24 return 
MAIN_TOK
;

25 if(!
	`strcmp
(
a
, "void"))

26 return 
VOID_TOK
;

28 return 
ID_TOK
;

29 
	}
}

31 int 
	$isComparator
(char 
a
[])

33 if(!
	`strcmp
(
a
, ">="))

34 return 
GTEQ_TOK
;

35 if(!
	`strcmp
(
a
, "<="))

36 return 
LSEQ_TOK
;

37 if(!
	`strcmp
(
a
, "=="))

38 return 
EQ2_TOK
;

39 if(!
	`strcmp
(
a
, "!="))

40 return 
NOTEQ_TOK
;

41 
	}
}

43 int 
	$main
(int 
argc
, char *
argv
[])

45 int 
token
;

46 if(
argc
 != 3)

48 
	`fprintf
(
stderr
, "Usage: <input file> <output file>\n");

49 
	`exit
(1);

53 
yyin
 = 
	`fopen
(
argv
[1], "r");

54 
yyout
 = 
	`fopen
(
argv
[2], "w");

55 while(!
	`feof
(
yyin
))

57 
token
 = 
	`yylex
();

58 
	`fprintf
(
yyout
, "%d\n", 
token
);

61 
	`fclose
(
yyin
);

62 
	`fclose
(
yyout
);

63 
	}
}

67 int 
	$yylex
()

69 char 
c
;

70 
yyleng
 = 0;

71 if(
yyin
 == 
NULL
)

72 
yyin
 = 
stdin
;

73 
c
 = 
	`getc
(
yyin
);

74 while(
	`isspace
(
c
))

75 
c
 = 
	`getc
(
yyin
);

78 switch(
c
)

93 
yyt
[0] = 
c
;

94 
yyleng
 = 1;

95 
	`printf
("%c\n", 
c
);

96 return 
c
;

104 char 
temp
[2];

105 
temp
[0] = 
c
;

106 char 
ch
 = 
	`getc
(
yyin
);

107 if(
ch
 != '=')

109 
yyt
[0] = 
c
;

110 
yyleng
 = 1;

111 
	`printf
("%c\n", 
c
);

112 return 
c
;

116 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

117 
yyt
 = (char*)
	`malloc
(2*sizeof(char));

118 
yyt
[0] = 
c
; yyt[1] = 
ch
;

119 
yyleng
 = 2;

120 return 
	`isComparator
(
yyt
);

136 int 
len
 = 0;

137 char 
ch
 = 
c
;

138 while(
	`isdigit
(
ch
))

140 
len
++;

141 
ch
 = 
	`getc
(
yyin
);

143 
	`fseek
(
yyin
, -
len
, 
SEEK_CUR
);

144 
yyt
 = (char*)
	`malloc
(
len
*sizeof(char));

145 
	`memset
(
yyt
, '\0', 
len
*sizeof(char));

147 int 
temp
 = 0;

148 while(
	`isdigit
(
c
))

150 
yyt
[
yyleng
] = 
c
;

151 
yyleng
++;

152 
temp
 = temp*10+
c
-'0';

153 
c
 = 
	`getc
(
yyin
);

155 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

156 
	`printf
("%s\n", 
yyt
);

157 return 
temp
;

184 if(
	`isalpha
(
c
))

186 int 
upp
 = 1;

187 if(
	`islower
(
c
))

188 
upp
 = 0;

190 int 
len
 = 0;

191 char 
ch
 = 
c
;

192 while(
	`isalnum
(
ch
))

194 
len
++;

195 
ch
 = 
	`getc
(
yyin
);

197 
	`fseek
(
yyin
, -
len
, 
SEEK_CUR
);

198 
yyt
 = (char*)
	`malloc
(
len
*sizeof(char));

199 
	`memset
(
yyt
, '\0', 
len
*sizeof(char));

201 while(
	`isalnum
(
c
))

203 
yyt
[
yyleng
++] = 
c
;

204 
c
 = 
	`getc
(
yyin
);

206 
	`fseek
(
yyin
, -1, 
SEEK_CUR
);

207 
	`printf
("%s\n", 
yyt
);

208 if(
upp
)

209 return 
ID_TOK
;

210 return 
	`isReserved
(
yyt
);

214 
	}
}

	@lexical_hardcoded.hpp

2 #define 
	#LPAREN_TOK
 '('

	)

3 #define 
	#RPAREN_TOK
 ')'

	)

4 #define 
	#GT_TOK
 '>'

	)

5 #define 
	#LS_TOK
 '<'

	)

6 #define 
	#EQ_TOK
 '='

	)

7 #define 
	#MINUS_TOK
 '-'

	)

8 #define 
	#ADDITION_TOK
 '+'

	)

9 #define 
	#MULTI_TOK
 '*'

	)

10 #define 
	#DIVISION_TOK
 '/'

	)

11 #define 
	#MOD_TOK
 '%'

	)

12 #define 
	#LCURLY_TOK
 '{'

	)

13 #define 
	#RCURLY_TOK
 '}'

	)

14 #define 
	#BITOR_TOK
 '|'

	)

15 #define 
	#BITAND_TOK
 '&'

	)

16 #define 
	#XOR_TOK
 '^'

	)

17 #define 
	#NOT_TOK
 '!'

	)

20 #define 
	#MINEQ_TOK
 300

	)

21 #define 
	#ADDEQ_TOK
 301

	)

22 #define 
	#MODEQ_TOK
 302

	)

23 #define 
	#MULTEQ_TOK
 303

	)

24 #define 
	#DIVEQ_TOK
 304

	)

25 #define 
	#BITANDEQ_TOK
 305

	)

26 #define 
	#BITOREQ_TOK
 306

	)

27 #define 
	#BITXOREQ_TOK
 307

	)

30 #define 
	#FOR_TOK
 256

	)

31 #define 
	#SWITCH_TOK
 257

	)

32 #define 
	#CASE_TOK
 258

	)

33 #define 
	#IF_TOK
 259

	)

34 #define 
	#ELSE_TOK
 260

	)

35 #define 
	#VOID_TOK
 261

	)

38 #define 
	#ID_TOK
 350

	)

39 #define 
	#INTCONST
 351

	)

41 #define 
	#GTEQ_TOK
 400

	)

42 #define 
	#LSEQ_TOK
 401

	)

43 #define 
	#AND_TOK
 402

	)

44 #define 
	#OR_TOK
 403

	)

45 #define 
	#EQ2_TOK
 404

	)

46 #define 
	#NOTEQ_TOK
 405

	@/usr/include/ctype.h

22 #ifndef 
_CTYPE_H


23 #define 
	#_CTYPE_H
 1

	)

25 #include 
	~<features.h
>

26 #include 
	~<bits/types.h
>

28 
	g__BEGIN_DECLS


30 #ifndef 
_ISbit


39 #include 
	~<endian.h
>

40 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


41 #define 
	#_ISbit
(
bit
) (1 << (bit))

	)

43 #define 
	#_ISbit
(
bit
) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))

	)

48 
	m_ISupper
 = 
_ISbit
 (0),

49 
	m_ISlower
 = 
_ISbit
 (1),

50 
	m_ISalpha
 = 
_ISbit
 (2),

51 
	m_ISdigit
 = 
_ISbit
 (3),

52 
	m_ISxdigit
 = 
_ISbit
 (4),

53 
	m_ISspace
 = 
_ISbit
 (5),

54 
	m_ISprint
 = 
_ISbit
 (6),

55 
	m_ISgraph
 = 
_ISbit
 (7),

56 
	m_ISblank
 = 
_ISbit
 (8),

57 
	m_IScntrl
 = 
_ISbit
 (9),

58 
	m_ISpunct
 = 
_ISbit
 (10),

59 
	m_ISalnum
 = 
_ISbit
 (11)

79 extern const unsigned short int **
	$__ctype_b_loc
 (void)

80 
__THROW
 
	`__attribute__
 ((
__const__
));

81 extern const 
__int32_t
 **
	$__ctype_tolower_loc
 (void)

82 
__THROW
 
	`__attribute__
 ((
__const__
));

83 extern const 
__int32_t
 **
	$__ctype_toupper_loc
 (void)

84 
__THROW
 
	`__attribute__
 ((
__const__
));

87 #ifndef 
__cplusplus


88 #define 
	#__isctype
(
c
, 
type
) \

89 ((*
	`__ctype_b_loc
 ())[(int) (
c
)] & (unsigned short int) 
type
)

	)

90 #elif 
defined
 
__USE_EXTERN_INLINES


91 #define 
	#__isctype_f
(
type
) \

92 
__extern_inline
 int \

93 
is
##
	`type
 (int 
__c
) 
__THROW
 \

95 return (*
	`__ctype_b_loc
 ())[(int) (
__c
)] & (unsigned short int) 
_IS
##
type
; \

96 
	}

	)
}

99 #define 
	#__isascii
(
c
) (((c) & ~0x7f) == 0)

	)

100 #define 
	#__toascii
(
c
) ((c) & 0x7f)

	)

102 #define 
	#__exctype
(
name
) extern int 
	`name
 (int) 
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exctype
 (
isalnum
);

111 
__exctype
 (
isalpha
);

112 
__exctype
 (
iscntrl
);

113 
__exctype
 (
isdigit
);

114 
__exctype
 (
islower
);

115 
__exctype
 (
isgraph
);

116 
__exctype
 (
isprint
);

117 
__exctype
 (
ispunct
);

118 
__exctype
 (
isspace
);

119 
__exctype
 (
isupper
);

120 
__exctype
 (
isxdigit
);

124 extern int 
	$tolower
 (int 
__c
) 
__THROW
;

127 extern int 
	$toupper
 (int 
__c
) 
__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exctype
 (
isblank
);

138 
__END_NAMESPACE_C99


141 #ifdef 
__USE_GNU


143 extern int 
	$isctype
 (int 
__c
, int 
__mask
) 
__THROW
;

146 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


150 extern int 
	$isascii
 (int 
__c
) 
__THROW
;

154 extern int 
	$toascii
 (int 
__c
) 
__THROW
;

158 
	`__exctype
 (
_toupper
);

159 
	`__exctype
 (
_tolower
);

163 #define 
	#__tobody
(
c
, 
f
, 
a
, 
args
) \

164 (
__extension__
 \

165 ({ int 
__res
; \

166 if (sizeof (
c
) > 1) \

168 if (
	`__builtin_constant_p
 (
c
)) \

170 int 
__c
 = (
c
); \

171 
__res
 = 
__c
 < -128 || __c > 255 ? __c : (
a
)[__c]; \

174 
__res
 = 
f
 
args
; \

177 
__res
 = (
a
)[(int) (
c
)]; \

178 
__res
; 
	}
}))

	)

180 #if !
defined
 
__NO_CTYPE


181 #ifdef 
__isctype_f


182 
	$__isctype_f
 (
alnum
)

183 
	$__isctype_f
 (
alpha
)

184 
	$__isctype_f
 (
cntrl
)

185 
	$__isctype_f
 (
digit
)

186 
	$__isctype_f
 (
lower
)

187 
	$__isctype_f
 (
graph
)

188 
	$__isctype_f
 (
print
)

189 
	$__isctype_f
 (
punct
)

190 
	$__isctype_f
 (
space
)

191 
	$__isctype_f
 (
upper
)

192 
	$__isctype_f
 (
xdigit
)

193 #ifdef 
__USE_ISOC99


194 
	$__isctype_f
 (
blank
)

196 #elif 
defined
 
__isctype


197 #define 
	#isalnum
(
c
) 
	`__isctype
((c), 
_ISalnum
)

	)

198 #define 
	#isalpha
(
c
) 
	`__isctype
((c), 
_ISalpha
)

	)

199 #define 
	#iscntrl
(
c
) 
	`__isctype
((c), 
_IScntrl
)

	)

200 #define 
	#isdigit
(
c
) 
	`__isctype
((c), 
_ISdigit
)

	)

201 #define 
	#islower
(
c
) 
	`__isctype
((c), 
_ISlower
)

	)

202 #define 
	#isgraph
(
c
) 
	`__isctype
((c), 
_ISgraph
)

	)

203 #define 
	#isprint
(
c
) 
	`__isctype
((c), 
_ISprint
)

	)

204 #define 
	#ispunct
(
c
) 
	`__isctype
((c), 
_ISpunct
)

	)

205 #define 
	#isspace
(
c
) 
	`__isctype
((c), 
_ISspace
)

	)

206 #define 
	#isupper
(
c
) 
	`__isctype
((c), 
_ISupper
)

	)

207 #define 
	#isxdigit
(
c
) 
	`__isctype
((c), 
_ISxdigit
)

	)

208 #ifdef 
__USE_ISOC99


209 #define 
	#isblank
(
c
) 
	`__isctype
((c), 
_ISblank
)

	)

213 #ifdef 
__USE_EXTERN_INLINES


214 
__extern_inline
 int

215 
	`__NTH
 (
	$tolower
 (int 
__c
))

217 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_tolower_loc
 ())[__c] : __c;

218 
	}
}

220 
__extern_inline
 int

221 
__NTH
 (
	$toupper
 (int 
__c
))

223 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_toupper_loc
 ())[__c] : __c;

224 
	}
}

227 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


228 #define 
	#tolower
(
c
) 
	`__tobody
 (c, 
tolower
, *
	`__ctype_tolower_loc
 (), (c))

	)

229 #define 
	#toupper
(
c
) 
	`__tobody
 (c, 
toupper
, *
	`__ctype_toupper_loc
 (), (c))

	)

232 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


233 #define 
	#isascii
(
c
) 
	`__isascii
 (c)

	)

234 #define 
	#toascii
(
c
) 
	`__toascii
 (c)

	)

236 #define 
	#_tolower
(
c
) ((int) (*
	`__ctype_tolower_loc
 ())[(int) (c)])

	)

237 #define 
	#_toupper
(
c
) ((int) (*
	`__ctype_toupper_loc
 ())[(int) (c)])

	)

243 #ifdef 
__USE_XOPEN2K8


257 #include 
	~<xlocale.h
>

261 #define 
	#__isctype_l
(
c
, 
type
, 
locale
) \

262 ((
locale
)->
__ctype_b
[(int) (
c
)] & (unsigned short int) 
type
)

	)

264 #define 
	#__exctype_l
(
name
) \

265 extern int 
	`name
 (int, 
__locale_t
) 
__THROW


	)

271 
__exctype_l
 (
isalnum_l
);

272 
__exctype_l
 (
isalpha_l
);

273 
__exctype_l
 (
iscntrl_l
);

274 
__exctype_l
 (
isdigit_l
);

275 
__exctype_l
 (
islower_l
);

276 
__exctype_l
 (
isgraph_l
);

277 
__exctype_l
 (
isprint_l
);

278 
__exctype_l
 (
ispunct_l
);

279 
__exctype_l
 (
isspace_l
);

280 
__exctype_l
 (
isupper_l
);

281 
__exctype_l
 (
isxdigit_l
);

283 
__exctype_l
 (
isblank_l
);

287 extern int 
	$__tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

288 extern int 
	$tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

291 extern int 
	$__toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

292 extern int 
	$toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

294 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


295 #define 
	#__tolower_l
(
c
, 
locale
) \

296 
	`__tobody
 (
c
, 
__tolower_l
, (
locale
)->
__ctype_tolower
, (c, locale))

	)

297 #define 
	#__toupper_l
(
c
, 
locale
) \

298 
	`__tobody
 (
c
, 
__toupper_l
, (
locale
)->
__ctype_toupper
, (c, locale))

	)

299 #define 
	#tolower_l
(
c
, 
locale
) 
	`__tolower_l
 ((c), (locale))

	)

300 #define 
	#toupper_l
(
c
, 
locale
) 
	`__toupper_l
 ((c), (locale))

	)

304 #ifndef 
__NO_CTYPE


305 #define 
	#__isalnum_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalnum
, (l))

	)

306 #define 
	#__isalpha_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalpha
, (l))

	)

307 #define 
	#__iscntrl_l
(
c
,
l
) 
	`__isctype_l
((c), 
_IScntrl
, (l))

	)

308 #define 
	#__isdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISdigit
, (l))

	)

309 #define 
	#__islower_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISlower
, (l))

	)

310 #define 
	#__isgraph_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISgraph
, (l))

	)

311 #define 
	#__isprint_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISprint
, (l))

	)

312 #define 
	#__ispunct_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISpunct
, (l))

	)

313 #define 
	#__isspace_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISspace
, (l))

	)

314 #define 
	#__isupper_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISupper
, (l))

	)

315 #define 
	#__isxdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISxdigit
, (l))

	)

317 #define 
	#__isblank_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISblank
, (l))

	)

319 #ifdef 
__USE_MISC


320 #define 
	#__isascii_l
(
c
,
l
) ((l), 
	`__isascii
 (c))

	)

321 #define 
	#__toascii_l
(
c
,
l
) ((l), 
	`__toascii
 (c))

	)

324 #define 
	#isalnum_l
(
c
,
l
) 
	`__isalnum_l
 ((c), (l))

	)

325 #define 
	#isalpha_l
(
c
,
l
) 
	`__isalpha_l
 ((c), (l))

	)

326 #define 
	#iscntrl_l
(
c
,
l
) 
	`__iscntrl_l
 ((c), (l))

	)

327 #define 
	#isdigit_l
(
c
,
l
) 
	`__isdigit_l
 ((c), (l))

	)

328 #define 
	#islower_l
(
c
,
l
) 
	`__islower_l
 ((c), (l))

	)

329 #define 
	#isgraph_l
(
c
,
l
) 
	`__isgraph_l
 ((c), (l))

	)

330 #define 
	#isprint_l
(
c
,
l
) 
	`__isprint_l
 ((c), (l))

	)

331 #define 
	#ispunct_l
(
c
,
l
) 
	`__ispunct_l
 ((c), (l))

	)

332 #define 
	#isspace_l
(
c
,
l
) 
	`__isspace_l
 ((c), (l))

	)

333 #define 
	#isupper_l
(
c
,
l
) 
	`__isupper_l
 ((c), (l))

	)

334 #define 
	#isxdigit_l
(
c
,
l
) 
	`__isxdigit_l
 ((c), (l))

	)

336 #define 
	#isblank_l
(
c
,
l
) 
	`__isblank_l
 ((c), (l))

	)

338 #ifdef 
__USE_MISC


339 #define 
	#isascii_l
(
c
,
l
) 
	`__isascii_l
 ((c), (l))

	)

340 #define 
	#toascii_l
(
c
,
l
) 
	`__toascii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/errno.h

22 #ifndef 
_ERRNO_H


26 #ifndef 
__need_Emath


27 #define 
	#_ERRNO_H
 1

	)

28 #include 
	~<features.h
>

31 
	g__BEGIN_DECLS


35 #include 
	~<bits/errno.h
>

36 #undef 
__need_Emath


38 #ifdef 
_ERRNO_H


45 #ifndef 
errno


46 extern int 
errno
;

49 #ifdef 
__USE_GNU


54 extern char *
program_invocation_name
, *
program_invocation_short_name
;

58 
	g__END_DECLS


66 #if 
defined
 
__USE_GNU
 || defined 
__need_error_t


67 #ifndef 
__error_t_defined


68 typedef int 
	terror_t
;

69 #define 
	#__error_t_defined
 1

	)

71 #undef 
__need_error_t


	@/usr/include/inttypes.h

22 #ifndef 
_INTTYPES_H


23 #define 
	#_INTTYPES_H
 1

	)

25 #include 
	~<features.h
>

27 #include 
	~<stdint.h
>

30 #ifndef 
____gwchar_t_defined


31 #ifdef 
__cplusplus


32 #define 
	#__gwchar_t
 
wchar_t


	)

33 #elif 
defined
 
__WCHAR_TYPE__


34 typedef 
__WCHAR_TYPE__
 
	t__gwchar_t
;

36 #define 
	#__need_wchar_t


	)

37 #include 
	~<stddef.h
>

38 typedef 
wchar_t
 
	t__gwchar_t
;

40 #define 
	#____gwchar_t_defined
 1

	)

43 #if 
__WORDSIZE
 == 64

44 #define 
	#__PRI64_PREFIX
 "l"

	)

45 #define 
	#__PRIPTR_PREFIX
 "l"

	)

47 #define 
	#__PRI64_PREFIX
 "ll"

	)

48 #define 
	#__PRIPTR_PREFIX


	)

54 #define 
	#PRId8
 "d"

	)

55 #define 
	#PRId16
 "d"

	)

56 #define 
	#PRId32
 "d"

	)

57 #define 
	#PRId64
 
__PRI64_PREFIX
 "d"

	)

59 #define 
	#PRIdLEAST8
 "d"

	)

60 #define 
	#PRIdLEAST16
 "d"

	)

61 #define 
	#PRIdLEAST32
 "d"

	)

62 #define 
	#PRIdLEAST64
 
__PRI64_PREFIX
 "d"

	)

64 #define 
	#PRIdFAST8
 "d"

	)

65 #define 
	#PRIdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

66 #define 
	#PRIdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

67 #define 
	#PRIdFAST64
 
__PRI64_PREFIX
 "d"

	)

70 #define 
	#PRIi8
 "i"

	)

71 #define 
	#PRIi16
 "i"

	)

72 #define 
	#PRIi32
 "i"

	)

73 #define 
	#PRIi64
 
__PRI64_PREFIX
 "i"

	)

75 #define 
	#PRIiLEAST8
 "i"

	)

76 #define 
	#PRIiLEAST16
 "i"

	)

77 #define 
	#PRIiLEAST32
 "i"

	)

78 #define 
	#PRIiLEAST64
 
__PRI64_PREFIX
 "i"

	)

80 #define 
	#PRIiFAST8
 "i"

	)

81 #define 
	#PRIiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

82 #define 
	#PRIiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

83 #define 
	#PRIiFAST64
 
__PRI64_PREFIX
 "i"

	)

86 #define 
	#PRIo8
 "o"

	)

87 #define 
	#PRIo16
 "o"

	)

88 #define 
	#PRIo32
 "o"

	)

89 #define 
	#PRIo64
 
__PRI64_PREFIX
 "o"

	)

91 #define 
	#PRIoLEAST8
 "o"

	)

92 #define 
	#PRIoLEAST16
 "o"

	)

93 #define 
	#PRIoLEAST32
 "o"

	)

94 #define 
	#PRIoLEAST64
 
__PRI64_PREFIX
 "o"

	)

96 #define 
	#PRIoFAST8
 "o"

	)

97 #define 
	#PRIoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

98 #define 
	#PRIoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

99 #define 
	#PRIoFAST64
 
__PRI64_PREFIX
 "o"

	)

102 #define 
	#PRIu8
 "u"

	)

103 #define 
	#PRIu16
 "u"

	)

104 #define 
	#PRIu32
 "u"

	)

105 #define 
	#PRIu64
 
__PRI64_PREFIX
 "u"

	)

107 #define 
	#PRIuLEAST8
 "u"

	)

108 #define 
	#PRIuLEAST16
 "u"

	)

109 #define 
	#PRIuLEAST32
 "u"

	)

110 #define 
	#PRIuLEAST64
 
__PRI64_PREFIX
 "u"

	)

112 #define 
	#PRIuFAST8
 "u"

	)

113 #define 
	#PRIuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

114 #define 
	#PRIuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

115 #define 
	#PRIuFAST64
 
__PRI64_PREFIX
 "u"

	)

118 #define 
	#PRIx8
 "x"

	)

119 #define 
	#PRIx16
 "x"

	)

120 #define 
	#PRIx32
 "x"

	)

121 #define 
	#PRIx64
 
__PRI64_PREFIX
 "x"

	)

123 #define 
	#PRIxLEAST8
 "x"

	)

124 #define 
	#PRIxLEAST16
 "x"

	)

125 #define 
	#PRIxLEAST32
 "x"

	)

126 #define 
	#PRIxLEAST64
 
__PRI64_PREFIX
 "x"

	)

128 #define 
	#PRIxFAST8
 "x"

	)

129 #define 
	#PRIxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

130 #define 
	#PRIxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

131 #define 
	#PRIxFAST64
 
__PRI64_PREFIX
 "x"

	)

134 #define 
	#PRIX8
 "X"

	)

135 #define 
	#PRIX16
 "X"

	)

136 #define 
	#PRIX32
 "X"

	)

137 #define 
	#PRIX64
 
__PRI64_PREFIX
 "X"

	)

139 #define 
	#PRIXLEAST8
 "X"

	)

140 #define 
	#PRIXLEAST16
 "X"

	)

141 #define 
	#PRIXLEAST32
 "X"

	)

142 #define 
	#PRIXLEAST64
 
__PRI64_PREFIX
 "X"

	)

144 #define 
	#PRIXFAST8
 "X"

	)

145 #define 
	#PRIXFAST16
 
__PRIPTR_PREFIX
 "X"

	)

146 #define 
	#PRIXFAST32
 
__PRIPTR_PREFIX
 "X"

	)

147 #define 
	#PRIXFAST64
 
__PRI64_PREFIX
 "X"

	)

151 #define 
	#PRIdMAX
 
__PRI64_PREFIX
 "d"

	)

152 #define 
	#PRIiMAX
 
__PRI64_PREFIX
 "i"

	)

153 #define 
	#PRIoMAX
 
__PRI64_PREFIX
 "o"

	)

154 #define 
	#PRIuMAX
 
__PRI64_PREFIX
 "u"

	)

155 #define 
	#PRIxMAX
 
__PRI64_PREFIX
 "x"

	)

156 #define 
	#PRIXMAX
 
__PRI64_PREFIX
 "X"

	)

160 #define 
	#PRIdPTR
 
__PRIPTR_PREFIX
 "d"

	)

161 #define 
	#PRIiPTR
 
__PRIPTR_PREFIX
 "i"

	)

162 #define 
	#PRIoPTR
 
__PRIPTR_PREFIX
 "o"

	)

163 #define 
	#PRIuPTR
 
__PRIPTR_PREFIX
 "u"

	)

164 #define 
	#PRIxPTR
 
__PRIPTR_PREFIX
 "x"

	)

165 #define 
	#PRIXPTR
 
__PRIPTR_PREFIX
 "X"

	)

171 #define 
	#SCNd8
 "hhd"

	)

172 #define 
	#SCNd16
 "hd"

	)

173 #define 
	#SCNd32
 "d"

	)

174 #define 
	#SCNd64
 
__PRI64_PREFIX
 "d"

	)

176 #define 
	#SCNdLEAST8
 "hhd"

	)

177 #define 
	#SCNdLEAST16
 "hd"

	)

178 #define 
	#SCNdLEAST32
 "d"

	)

179 #define 
	#SCNdLEAST64
 
__PRI64_PREFIX
 "d"

	)

181 #define 
	#SCNdFAST8
 "hhd"

	)

182 #define 
	#SCNdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

183 #define 
	#SCNdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

184 #define 
	#SCNdFAST64
 
__PRI64_PREFIX
 "d"

	)

187 #define 
	#SCNi8
 "hhi"

	)

188 #define 
	#SCNi16
 "hi"

	)

189 #define 
	#SCNi32
 "i"

	)

190 #define 
	#SCNi64
 
__PRI64_PREFIX
 "i"

	)

192 #define 
	#SCNiLEAST8
 "hhi"

	)

193 #define 
	#SCNiLEAST16
 "hi"

	)

194 #define 
	#SCNiLEAST32
 "i"

	)

195 #define 
	#SCNiLEAST64
 
__PRI64_PREFIX
 "i"

	)

197 #define 
	#SCNiFAST8
 "hhi"

	)

198 #define 
	#SCNiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

199 #define 
	#SCNiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

200 #define 
	#SCNiFAST64
 
__PRI64_PREFIX
 "i"

	)

203 #define 
	#SCNu8
 "hhu"

	)

204 #define 
	#SCNu16
 "hu"

	)

205 #define 
	#SCNu32
 "u"

	)

206 #define 
	#SCNu64
 
__PRI64_PREFIX
 "u"

	)

208 #define 
	#SCNuLEAST8
 "hhu"

	)

209 #define 
	#SCNuLEAST16
 "hu"

	)

210 #define 
	#SCNuLEAST32
 "u"

	)

211 #define 
	#SCNuLEAST64
 
__PRI64_PREFIX
 "u"

	)

213 #define 
	#SCNuFAST8
 "hhu"

	)

214 #define 
	#SCNuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

215 #define 
	#SCNuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

216 #define 
	#SCNuFAST64
 
__PRI64_PREFIX
 "u"

	)

219 #define 
	#SCNo8
 "hho"

	)

220 #define 
	#SCNo16
 "ho"

	)

221 #define 
	#SCNo32
 "o"

	)

222 #define 
	#SCNo64
 
__PRI64_PREFIX
 "o"

	)

224 #define 
	#SCNoLEAST8
 "hho"

	)

225 #define 
	#SCNoLEAST16
 "ho"

	)

226 #define 
	#SCNoLEAST32
 "o"

	)

227 #define 
	#SCNoLEAST64
 
__PRI64_PREFIX
 "o"

	)

229 #define 
	#SCNoFAST8
 "hho"

	)

230 #define 
	#SCNoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

231 #define 
	#SCNoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

232 #define 
	#SCNoFAST64
 
__PRI64_PREFIX
 "o"

	)

235 #define 
	#SCNx8
 "hhx"

	)

236 #define 
	#SCNx16
 "hx"

	)

237 #define 
	#SCNx32
 "x"

	)

238 #define 
	#SCNx64
 
__PRI64_PREFIX
 "x"

	)

240 #define 
	#SCNxLEAST8
 "hhx"

	)

241 #define 
	#SCNxLEAST16
 "hx"

	)

242 #define 
	#SCNxLEAST32
 "x"

	)

243 #define 
	#SCNxLEAST64
 
__PRI64_PREFIX
 "x"

	)

245 #define 
	#SCNxFAST8
 "hhx"

	)

246 #define 
	#SCNxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

247 #define 
	#SCNxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

248 #define 
	#SCNxFAST64
 
__PRI64_PREFIX
 "x"

	)

252 #define 
	#SCNdMAX
 
__PRI64_PREFIX
 "d"

	)

253 #define 
	#SCNiMAX
 
__PRI64_PREFIX
 "i"

	)

254 #define 
	#SCNoMAX
 
__PRI64_PREFIX
 "o"

	)

255 #define 
	#SCNuMAX
 
__PRI64_PREFIX
 "u"

	)

256 #define 
	#SCNxMAX
 
__PRI64_PREFIX
 "x"

	)

259 #define 
	#SCNdPTR
 
__PRIPTR_PREFIX
 "d"

	)

260 #define 
	#SCNiPTR
 
__PRIPTR_PREFIX
 "i"

	)

261 #define 
	#SCNoPTR
 
__PRIPTR_PREFIX
 "o"

	)

262 #define 
	#SCNuPTR
 
__PRIPTR_PREFIX
 "u"

	)

263 #define 
	#SCNxPTR
 
__PRIPTR_PREFIX
 "x"

	)

266 
	g__BEGIN_DECLS


268 #if 
__WORDSIZE
 == 64

273 long int 
	mquot
;

274 long int 
	mrem
;

275 } 
	timaxdiv_t
;

282 
__extension__
 long long int 
	mquot
;

283 
__extension__
 long long int 
	mrem
;

284 } 
	timaxdiv_t
;

290 extern 
intmax_t
 
	$imaxabs
 (
intmax_t
 
__n
) 
__THROW
 
	`__attribute__
 ((
__const__
));

293 extern 
imaxdiv_t
 
	$imaxdiv
 (
intmax_t
 
__numer
, intmax_t 
__denom
)

294 
__THROW
 
	`__attribute__
 ((
__const__
));

297 extern 
intmax_t
 
	$strtoimax
 (const char *
__restrict
 
__nptr
,

298 char **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

301 extern 
uintmax_t
 
	$strtoumax
 (const char *
__restrict
 
__nptr
,

302 char ** 
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

305 extern 
intmax_t
 
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

306 
__gwchar_t
 **
__restrict
 
__endptr
, int 
__base
)

307 
__THROW
;

310 extern 
uintmax_t
 
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

311 
__gwchar_t
 ** 
__restrict
 
__endptr
, int 
__base
)

312 
__THROW
;

314 #ifdef 
__USE_EXTERN_INLINES


316 #if 
__WORDSIZE
 == 64

318 extern long int 
	$__strtol_internal
 (const char *
__restrict
 
__nptr
,

319 char **
__restrict
 
__endptr
,

320 int 
__base
, int 
__group
)

321 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

323 
__extern_inline
 
intmax_t


324 
	`__NTH
 (
	$strtoimax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

325 int 
base
))

327 return 
	`__strtol_internal
 (
nptr
, 
endptr
, 
base
, 0);

328 
	}
}

330 extern unsigned long int 
	$__strtoul_internal
 (const char *
__restrict
 
__nptr
,

331 char ** 
__restrict
 
__endptr
,

332 int 
__base
, int 
__group
)

333 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

335 
__extern_inline
 
uintmax_t


336 
	`__NTH
 (
	$strtoumax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

337 int 
base
))

339 return 
	`__strtoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

340 
	}
}

342 extern long int 
	$__wcstol_internal
 (const 
__gwchar_t
 * 
__restrict
 
__nptr
,

343 
__gwchar_t
 **
__restrict
 
__endptr
,

344 int 
__base
, int 
__group
)

345 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

347 
__extern_inline
 
intmax_t


348 
	`__NTH
 (
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

349 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

351 return 
	`__wcstol_internal
 (
nptr
, 
endptr
, 
base
, 0);

352 
	}
}

354 extern unsigned long int 
	$__wcstoul_internal
 (const 
__gwchar_t
 *

355 
__restrict
 
__nptr
,

356 
__gwchar_t
 **

357 
__restrict
 
__endptr
,

358 int 
__base
, int 
__group
)

359 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

361 
__extern_inline
 
uintmax_t


362 
	`__NTH
 (
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

363 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

365 return 
	`__wcstoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

366 
	}
}

370 
__extension__


371 extern long long int 
	$__strtoll_internal
 (const char *
__restrict
 
__nptr
,

372 char **
__restrict
 
__endptr
,

373 int 
__base
, int 
__group
)

374 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

376 
__extern_inline
 
intmax_t


377 
	`__NTH
 (
	$strtoimax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

378 int 
base
))

380 return 
	`__strtoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

381 
	}
}

383 
__extension__


384 extern unsigned long long int 
	$__strtoull_internal
 (const char *

385 
__restrict
 
__nptr
,

387 
__restrict
 
__endptr
,

388 int 
__base
,

389 int 
__group
)

390 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

392 
__extern_inline
 
uintmax_t


393 
	`__NTH
 (
	$strtoumax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

394 int 
base
))

396 return 
	`__strtoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

397 
	}
}

399 
__extension__


400 extern long long int 
	$__wcstoll_internal
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

401 
__gwchar_t
 **
__restrict
 
__endptr
,

402 int 
__base
, int 
__group
)

403 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

405 
__extern_inline
 
intmax_t


406 
	`__NTH
 (
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

407 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

409 return 
	`__wcstoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

410 
	}
}

413 
__extension__


414 extern unsigned long long int 
	$__wcstoull_internal
 (const 
__gwchar_t
 *

415 
__restrict
 
__nptr
,

416 
__gwchar_t
 **

417 
__restrict
 
__endptr
,

418 int 
__base
,

419 int 
__group
)

420 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

422 
__extern_inline
 
uintmax_t


423 
	`__NTH
 (
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

424 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

426 return 
	`__wcstoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

427 
	}
}

432 
	g__END_DECLS


	@/usr/include/stdio.h

23 #ifndef 
_STDIO_H


25 #if !
defined
 
__need_FILE
 && !defined 
__need___FILE


26 #define 
	#_STDIO_H
 1

	)

27 #include 
	~<features.h
>

29 
	g__BEGIN_DECLS


31 #define 
	#__need_size_t


	)

32 #define 
	#__need_NULL


	)

33 #include 
	~<stddef.h
>

35 #include 
	~<bits/types.h
>

36 #define 
	#__need_FILE


	)

37 #define 
	#__need___FILE


	)

41 #if !
defined
 
__FILE_defined
 && defined 
__need_FILE


44 struct 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 typedef struct 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #if 
defined
 
__USE_LARGEFILE64
 || defined 
__USE_POSIX
 \

51 || 
defined
 
	g__USE_ISOC99
 || defined 
	g__USE_XOPEN
 \

52 || 
defined
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 #define 
	#__FILE_defined
 1

	)

58 #undef 
__need_FILE


61 #if !
defined
 
____FILE_defined
 && defined 
__need___FILE


64 typedef struct 
_IO_FILE
 
	t__FILE
;

66 #define 
	#____FILE_defined
 1

	)

68 #undef 
__need___FILE


71 #ifdef 
_STDIO_H


72 #define 
	#_STDIO_USES_IOSTREAM


	)

74 #include 
	~<libio.h
>

76 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


77 #ifdef 
__GNUC__


78 #ifndef 
_VA_LIST_DEFINED


79 typedef 
_G_va_list
 
	tva_list
;

80 #define 
	#_VA_LIST_DEFINED


	)

83 #include 
	~<stdarg.h
>

87 #ifdef 
__USE_XOPEN2K8


88 #ifndef 
__off_t_defined


89 #ifndef 
__USE_FILE_OFFSET64


90 typedef 
__off_t
 
	toff_t
;

92 typedef 
__off64_t
 
	toff_t
;

94 #define 
	#__off_t_defined


	)

96 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


97 typedef 
__off64_t
 
	toff64_t
;

98 #define 
	#__off64_t_defined


	)

101 #ifndef 
__ssize_t_defined


102 typedef 
__ssize_t
 
	tssize_t
;

103 #define 
	#__ssize_t_defined


	)

108 
__BEGIN_NAMESPACE_STD


109 #ifndef 
__USE_FILE_OFFSET64


110 typedef 
_G_fpos_t
 
	tfpos_t
;

112 typedef 
_G_fpos64_t
 
	tfpos_t
;

114 
__END_NAMESPACE_STD


115 #ifdef 
__USE_LARGEFILE64


116 typedef 
_G_fpos64_t
 
	tfpos64_t
;

120 #define 
	#_IOFBF
 0

	)

121 #define 
	#_IOLBF
 1

	)

122 #define 
	#_IONBF
 2

	)

126 #ifndef 
BUFSIZ


127 #define 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ifndef 
EOF


134 #define 
	#EOF
 (-1)

	)

140 #define 
	#SEEK_SET
 0

	)

141 #define 
	#SEEK_CUR
 1

	)

142 #define 
	#SEEK_END
 2

	)

143 #ifdef 
__USE_GNU


144 #define 
	#SEEK_DATA
 3

	)

145 #define 
	#SEEK_HOLE
 4

	)

149 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


151 #define 
	#P_tmpdir
 "/tmp"

	)

164 #include 
	~<bits/stdio_lim.h
>

168 extern struct 
_IO_FILE
 *
stdin
;

169 extern struct 
_IO_FILE
 *
stdout
;

170 extern struct 
_IO_FILE
 *
stderr
;

172 #define 
	#stdin
 
stdin


	)

173 #define 
	#stdout
 
stdout


	)

174 #define 
	#stderr
 
stderr


	)

176 
__BEGIN_NAMESPACE_STD


178 extern int 
	$remove
 (const char *
__filename
) 
__THROW
;

180 extern int 
	$rename
 (const char *
__old
, const char *
__new
) 
__THROW
;

181 
__END_NAMESPACE_STD


183 #ifdef 
__USE_ATFILE


185 extern int 
	$renameat
 (int 
__oldfd
, const char *
__old
, int 
__newfd
,

186 const char *
__new
) 
__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ifndef 
__USE_FILE_OFFSET64


195 extern 
FILE
 *
	$tmpfile
 (void) 
__wur
;

197 #ifdef 
__REDIRECT


198 extern 
FILE
 *
	`__REDIRECT
 (
tmpfile
, (void), 
tmpfile64
) 
__wur
;

200 #define 
	#tmpfile
 
tmpfile64


	)

204 #ifdef 
__USE_LARGEFILE64


205 extern 
FILE
 *
	$tmpfile64
 (void) 
__wur
;

209 extern char *
	$tmpnam
 (char *
__s
) 
__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifdef 
__USE_MISC


215 extern char *
	$tmpnam_r
 (char *
__s
) 
__THROW
 
__wur
;

219 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


227 extern char *
	$tempnam
 (const char *
__dir
, const char *
__pfx
)

228 
__THROW
 
__attribute_malloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 extern int 
	`fclose
 (
FILE
 *
__stream
);

242 extern int 
	`fflush
 (
FILE
 *
__stream
);

243 
__END_NAMESPACE_STD


245 #ifdef 
__USE_MISC


252 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

255 #ifdef 
__USE_GNU


262 extern int 
	`fcloseall
 (void);

266 
__BEGIN_NAMESPACE_STD


267 #ifndef 
__USE_FILE_OFFSET64


272 extern 
FILE
 *
	$fopen
 (const char *
__restrict
 
__filename
,

273 const char *
__restrict
 
__modes
) 
__wur
;

278 extern 
FILE
 *
	$freopen
 (const char *
__restrict
 
__filename
,

279 const char *
__restrict
 
__modes
,

280 
FILE
 *
__restrict
 
__stream
) 
__wur
;

282 #ifdef 
__REDIRECT


283 extern 
FILE
 *
	`__REDIRECT
 (
fopen
, (const char *
__restrict
 
__filename
,

284 const char *
__restrict
 
__modes
), 
fopen64
)

285 
__wur
;

286 extern 
FILE
 *
	`__REDIRECT
 (
freopen
, (const char *
__restrict
 
__filename
,

287 const char *
__restrict
 
__modes
,

288 
FILE
 *
__restrict
 
__stream
), 
freopen64
)

289 
__wur
;

291 #define 
	#fopen
 
fopen64


	)

292 #define 
	#freopen
 
freopen64


	)

295 
__END_NAMESPACE_STD


296 #ifdef 
__USE_LARGEFILE64


297 extern 
FILE
 *
	$fopen64
 (const char *
__restrict
 
__filename
,

298 const char *
__restrict
 
__modes
) 
__wur
;

299 extern 
FILE
 *
	$freopen64
 (const char *
__restrict
 
__filename
,

300 const char *
__restrict
 
__modes
,

301 
FILE
 *
__restrict
 
__stream
) 
__wur
;

304 #ifdef 
__USE_POSIX


306 extern 
FILE
 *
	$fdopen
 (int 
__fd
, const char *
__modes
) 
__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 extern 
FILE
 *
	$fopencookie
 (void *
__restrict
 
__magic_cookie
,

313 const char *
__restrict
 
__modes
,

314 
_IO_cookie_io_functions_t
 
__io_funcs
) 
__THROW
 
__wur
;

317 #ifdef 
__USE_XOPEN2K8


319 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, const char *
__modes
)

320 
__THROW
 
__wur
;

325 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
__THROW
;

336 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

337 int 
__modes
, 
size_t
 
__n
) 
__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_MISC


343 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

344 
size_t
 
__size
) 
__THROW
;

347 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

357 const char *
__restrict
 
__format
, ...);

362 extern int 
	`printf
 (const char *
__restrict
 
__format
, ...);

364 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

365 const char *
__restrict
 
__format
, ...) 
__THROWNL
;

371 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

372 
_G_va_list
 
__arg
);

377 extern int 
	`vprintf
 (const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
);

379 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__format
,

380 
_G_va_list
 
__arg
) 
__THROWNL
;

381 
__END_NAMESPACE_STD


383 #if 
defined
 
__USE_ISOC99
 || defined 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

387 const char *
__restrict
 
__format
, ...)

388 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

390 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

391 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

392 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifdef 
__USE_GNU


399 extern int 
	$vasprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__f
,

400 
_G_va_list
 
__arg
)

401 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 0))) 
__wur
;

402 extern int 
	$__asprintf
 (char **
__restrict
 
__ptr
,

403 const char *
__restrict
 
__fmt
, ...)

404 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

405 extern int 
	$asprintf
 (char **
__restrict
 
__ptr
,

406 const char *
__restrict
 
__fmt
, ...)

407 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

410 #ifdef 
__USE_XOPEN2K8


412 extern int 
	$vdprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
,

413 
_G_va_list
 
__arg
)

414 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

415 extern int 
	$dprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, ...)

416 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 extern int 
	$fscanf
 (
FILE
 *
__restrict
 
__stream
,

426 const char *
__restrict
 
__format
, ...) 
__wur
;

431 extern int 
	$scanf
 (const char *
__restrict
 
__format
, ...) 
__wur
;

433 extern int 
	$sscanf
 (const char *
__restrict
 
__s
,

434 const char *
__restrict
 
__format
, ...) 
__THROW
;

436 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

437 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

438 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

439 #ifdef 
__REDIRECT


443 extern int 
	`__REDIRECT
 (
fscanf
, (
FILE
 *
__restrict
 
__stream
,

444 const char *
__restrict
 
__format
, ...),

445 
__isoc99_fscanf
) 
__wur
;

446 extern int 
	`__REDIRECT
 (
scanf
, (const char *
__restrict
 
__format
, ...),

447 
__isoc99_scanf
) 
__wur
;

448 extern int 
	`__REDIRECT_NTH
 (
sscanf
, (const char *
__restrict
 
__s
,

449 const char *
__restrict
 
__format
, ...),

450 
__isoc99_sscanf
);

452 extern int 
	$__isoc99_fscanf
 (
FILE
 *
__restrict
 
__stream
,

453 const char *
__restrict
 
__format
, ...) 
__wur
;

454 extern int 
	$__isoc99_scanf
 (const char *
__restrict
 
__format
, ...) 
__wur
;

455 extern int 
	$__isoc99_sscanf
 (const char *
__restrict
 
__s
,

456 const char *
__restrict
 
__format
, ...) 
__THROW
;

457 #define 
	#fscanf
 
__isoc99_fscanf


	)

458 #define 
	#scanf
 
__isoc99_scanf


	)

459 #define 
	#sscanf
 
__isoc99_sscanf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

472 
_G_va_list
 
__arg
)

473 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

479 extern int 
	$vscanf
 (const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

480 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

483 extern int 
	$vsscanf
 (const char *
__restrict
 
__s
,

484 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

485 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

487 #if !
defined
 
__USE_GNU
 \

488 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

489 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

490 #ifdef 
__REDIRECT


494 extern int 
	`__REDIRECT
 (
vfscanf
,

495 (
FILE
 *
__restrict
 
__s
,

496 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
),

497 
__isoc99_vfscanf
)

498 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

499 extern int 
	`__REDIRECT
 (
vscanf
, (const char *
__restrict
 
__format
,

500 
_G_va_list
 
__arg
), 
__isoc99_vscanf
)

501 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

502 extern int 
	`__REDIRECT_NTH
 (
vsscanf
,

503 (const char *
__restrict
 
__s
,

504 const char *
__restrict
 
__format
,

505 
_G_va_list
 
__arg
), 
__isoc99_vsscanf
)

506 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

508 extern int 
	$__isoc99_vfscanf
 (
FILE
 *
__restrict
 
__s
,

509 const char *
__restrict
 
__format
,

510 
_G_va_list
 
__arg
) 
__wur
;

511 extern int 
	$__isoc99_vscanf
 (const char *
__restrict
 
__format
,

512 
_G_va_list
 
__arg
) 
__wur
;

513 extern int 
	$__isoc99_vsscanf
 (const char *
__restrict
 
__s
,

514 const char *
__restrict
 
__format
,

515 
_G_va_list
 
__arg
) 
__THROW
;

516 #define 
	#vfscanf
 
__isoc99_vfscanf


	)

517 #define 
	#vscanf
 
__isoc99_vscanf


	)

518 #define 
	#vsscanf
 
__isoc99_vsscanf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 extern int 
	`fgetc
 (
FILE
 *
__stream
);

532 extern int 
	`getc
 (
FILE
 *
__stream
);

538 extern int 
	`getchar
 (void);

539 
__END_NAMESPACE_STD


543 #define 
	#getc
(
_fp
) 
	`_IO_getc
 (_fp)

	)

545 #ifdef 
__USE_POSIX


550 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

551 extern int 
	`getchar_unlocked
 (void);

554 #ifdef 
__USE_MISC


561 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

565 
__BEGIN_NAMESPACE_STD


573 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

574 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

580 extern int 
	`putchar
 (int 
__c
);

581 
__END_NAMESPACE_STD


585 #define 
	#putc
(
_ch
, 
_fp
) 
	`_IO_putc
 (_ch, _fp)

	)

587 #ifdef 
__USE_MISC


594 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

597 #ifdef 
__USE_POSIX


602 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

603 extern int 
	`putchar_unlocked
 (int 
__c
);

607 #if 
defined
 
__USE_MISC
 \

608 || (
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

610 extern int 
	`getw
 (
FILE
 *
__stream
);

613 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

617 
__BEGIN_NAMESPACE_STD


622 extern char *
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

623 
__wur
;

625 #if !
defined
 
__USE_ISOC11
 \

626 || (
defined
 
__cplusplus
 && __cplusplus <= 201103L)

638 extern char *
	$gets
 (char *
__s
) 
__wur
 
__attribute_deprecated__
;

640 
__END_NAMESPACE_STD


642 #ifdef 
__USE_GNU


649 extern char *
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
,

650 
FILE
 *
__restrict
 
__stream
) 
__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 extern 
_IO_ssize_t
 
	$__getdelim
 (char **
__restrict
 
__lineptr
,

666 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

667 
FILE
 *
__restrict
 
__stream
) 
__wur
;

668 extern 
_IO_ssize_t
 
	$getdelim
 (char **
__restrict
 
__lineptr
,

669 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

670 
FILE
 *
__restrict
 
__stream
) 
__wur
;

678 extern 
_IO_ssize_t
 
	$getline
 (char **
__restrict
 
__lineptr
,

679 
size_t
 *
__restrict
 
__n
,

680 
FILE
 *
__restrict
 
__stream
) 
__wur
;

684 
__BEGIN_NAMESPACE_STD


689 extern int 
	`fputs
 (const char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

695 extern int 
	`puts
 (const char *
__s
);

702 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

709 extern 
size_t
 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

715 extern 
size_t
 
	`fwrite
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

716 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifdef 
__USE_GNU


726 extern int 
	`fputs_unlocked
 (const char *
__restrict
 
__s
,

727 
FILE
 *
__restrict
 
__stream
);

730 #ifdef 
__USE_MISC


737 extern 
size_t
 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

739 extern 
size_t
 
	`fwrite_unlocked
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

740 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
);

744 
__BEGIN_NAMESPACE_STD


749 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

754 extern long int 
	$ftell
 (
FILE
 *
__stream
) 
__wur
;

759 extern void 
	`rewind
 (
FILE
 *
__stream
);

760 
__END_NAMESPACE_STD


767 #if 
defined
 
__USE_LARGEFILE
 || defined 
__USE_XOPEN2K


768 #ifndef 
__USE_FILE_OFFSET64


773 extern int 
	`fseeko
 (
FILE
 *
__stream
, 
__off_t
 
__off
, int 
__whence
);

778 extern 
__off_t
 
	$ftello
 (
FILE
 *
__stream
) 
__wur
;

780 #ifdef 
__REDIRECT


781 extern int 
	`__REDIRECT
 (
fseeko
,

782 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
),

783 
fseeko64
);

784 extern 
__off64_t
 
	`__REDIRECT
 (
ftello
, (
FILE
 *
__stream
), 
ftello64
);

786 #define 
	#fseeko
 
fseeko64


	)

787 #define 
	#ftello
 
ftello64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ifndef 
__USE_FILE_OFFSET64


798 extern int 
	`fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
);

803 extern int 
	`fsetpos
 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
);

805 #ifdef 
__REDIRECT


806 extern int 
	`__REDIRECT
 (
fgetpos
, (
FILE
 *
__restrict
 
__stream
,

807 
fpos_t
 *
__restrict
 
__pos
), 
fgetpos64
);

808 extern int 
	`__REDIRECT
 (
fsetpos
,

809 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
), 
fsetpos64
);

811 #define 
	#fgetpos
 
fgetpos64


	)

812 #define 
	#fsetpos
 
fsetpos64


	)

815 
__END_NAMESPACE_STD


817 #ifdef 
__USE_LARGEFILE64


818 extern int 
	`fseeko64
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
);

819 extern 
__off64_t
 
	$ftello64
 (
FILE
 *
__stream
) 
__wur
;

820 extern int 
	`fgetpos64
 (
FILE
 *
__restrict
 
__stream
, 
fpos64_t
 *__restrict 
__pos
);

821 extern int 
	`fsetpos64
 (
FILE
 *
__stream
, const 
fpos64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
__THROW
;

828 extern int 
	$feof
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

830 extern int 
	$ferror
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifdef 
__USE_MISC


835 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
__THROW
;

836 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

837 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 extern void 
	`perror
 (const char *
__s
);

847 
__END_NAMESPACE_STD


853 #include 
	~<bits/sys_errlist.h
>

856 #ifdef 
__USE_POSIX


858 extern int 
	$fileno
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

861 #ifdef 
__USE_MISC


863 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

867 #ifdef 
__USE_POSIX2


872 extern 
FILE
 *
	$popen
 (const char *
__command
, const char *
__modes
) 
__wur
;

878 extern int 
	`pclose
 (
FILE
 *
__stream
);

882 #ifdef 
__USE_POSIX


884 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

888 #ifdef 
__USE_XOPEN


890 extern char *
	`cuserid
 (char *
__s
);

894 #ifdef 
__USE_GNU


895 struct 
obstack
;

898 extern int 
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

899 const char *
__restrict
 
__format
, ...)

900 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

901 extern int 
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

902 const char *
__restrict
 
__format
,

903 
_G_va_list
 
__args
)

904 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

908 #ifdef 
__USE_POSIX


912 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
__THROW
;

916 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

919 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
__THROW
;

922 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
 && !defined 
__USE_GNU


926 #define 
	#__need_getopt


	)

927 #include 
	~<getopt.h
>

932 #ifdef 
__USE_EXTERN_INLINES


933 #include 
	~<bits/stdio.h
>

935 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


936 #include 
	~<bits/stdio2.h
>

938 #ifdef 
__LDBL_COMPAT


939 #include 
	~<bits/stdio-ldbl.h
>

942 
__END_DECLS


	@/usr/include/stdlib.h

22 #ifndef 
_STDLIB_H


24 #include 
	~<features.h
>

27 #define 
	#__need_size_t


	)

28 #ifndef 
__need_malloc_and_calloc


29 #define 
	#__need_wchar_t


	)

30 #define 
	#__need_NULL


	)

32 #include 
	~<stddef.h
>

34 
	g__BEGIN_DECLS


36 #ifndef 
__need_malloc_and_calloc


37 #define 
	#_STDLIB_H
 1

	)

39 #if (
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) && !defined 
_SYS_WAIT_H


41 #include 
	~<bits/waitflags.h
>

42 #include 
	~<bits/waitstatus.h
>

44 #ifdef 
__USE_MISC


49 #if 
defined
 
__GNUC__
 && !defined 
__cplusplus


50 #define 
	#__WAIT_INT
(
status
) \

51 (
	`__extension__
 (((union { 
	`__typeof
(
status
) 
__in
; int 
__i
; }) \

52 { .
__in
 = (
status
) }).
__i
))

	)

54 #define 
	#__WAIT_INT
(
status
) (*(int *) &(status))

	)

62 #if !
defined
 
__GNUC__
 || __GNUC__ < 2 || defined 
__cplusplus


63 #define 
	#__WAIT_STATUS
 void *

	)

64 #define 
	#__WAIT_STATUS_DEFN
 void *

	)

69 union 
wait
 *
	m__uptr
;

70 int *
	m__iptr
;

71 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

72 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

77 #define 
	#__WAIT_INT
(
status
) (status)

	)

78 #define 
	#__WAIT_STATUS
 int *

	)

79 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

84 #define 
	#WEXITSTATUS
(
status
) 
	`__WEXITSTATUS
 (
	`__WAIT_INT
 (status))

	)

85 #define 
	#WTERMSIG
(
status
) 
	`__WTERMSIG
 (
	`__WAIT_INT
 (status))

	)

86 #define 
	#WSTOPSIG
(
status
) 
	`__WSTOPSIG
 (
	`__WAIT_INT
 (status))

	)

87 #define 
	#WIFEXITED
(
status
) 
	`__WIFEXITED
 (
	`__WAIT_INT
 (status))

	)

88 #define 
	#WIFSIGNALED
(
status
) 
	`__WIFSIGNALED
 (
	`__WAIT_INT
 (status))

	)

89 #define 
	#WIFSTOPPED
(
status
) 
	`__WIFSTOPPED
 (
	`__WAIT_INT
 (status))

	)

90 #ifdef 
__WIFCONTINUED


91 #define 
	#WIFCONTINUED
(
status
) 
	`__WIFCONTINUED
 (
	`__WAIT_INT
 (status))

	)

95 
__BEGIN_NAMESPACE_STD


99 int 
	mquot
;

100 int 
	mrem
;

101 } 
	tdiv_t
;

104 #ifndef 
__ldiv_t_defined


107 long int 
	mquot
;

108 long int 
	mrem
;

109 } 
	tldiv_t
;

110 #define 
	#__ldiv_t_defined
 1

	)

112 
	g__END_NAMESPACE_STD


114 #if 
defined
 
__USE_ISOC99
 && !defined 
__lldiv_t_defined


115 
__BEGIN_NAMESPACE_C99


117 
__extension__
 typedef struct

119 long long int 
	mquot
;

120 long long int 
	mrem
;

121 } 
	tlldiv_t
;

122 #define 
	#__lldiv_t_defined
 1

	)

123 
	g__END_NAMESPACE_C99


128 #define 
	#RAND_MAX
 2147483647

	)

133 #define 
	#EXIT_FAILURE
 1

	)

134 #define 
	#EXIT_SUCCESS
 0

	)

138 #define 
	#MB_CUR_MAX
 (
	`__ctype_get_mb_cur_max
 ())

	)

139 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 extern double 
	$atof
 (const char *
__nptr
)

145 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

147 extern int 
	$atoi
 (const char *
__nptr
)

148 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

150 extern long int 
	$atol
 (const char *
__nptr
)

151 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

152 
__END_NAMESPACE_STD


154 #ifdef 
__USE_ISOC99


155 
__BEGIN_NAMESPACE_C99


157 
__extension__
 extern long long int 
	$atoll
 (const char *
__nptr
)

158 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 extern double 
	$strtod
 (const char *
__restrict
 
__nptr
,

165 char **
__restrict
 
__endptr
)

166 
__THROW
 
	`__nonnull
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 extern float 
	$strtof
 (const char *
__restrict
 
__nptr
,

173 char **
__restrict
 
__endptr
) 
__THROW
 
	`__nonnull
 ((1));

175 extern long double 
	$strtold
 (const char *
__restrict
 
__nptr
,

176 char **
__restrict
 
__endptr
)

177 
__THROW
 
	`__nonnull
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 extern long int 
	$strtol
 (const char *
__restrict
 
__nptr
,

184 char **
__restrict
 
__endptr
, int 
__base
)

185 
__THROW
 
	`__nonnull
 ((1));

187 extern unsigned long int 
	$strtoul
 (const char *
__restrict
 
__nptr
,

188 char **
__restrict
 
__endptr
, int 
__base
)

189 
__THROW
 
	`__nonnull
 ((1));

190 
__END_NAMESPACE_STD


192 #ifdef 
__USE_MISC


194 
__extension__


195 extern long long int 
	$strtoq
 (const char *
__restrict
 
__nptr
,

196 char **
__restrict
 
__endptr
, int 
__base
)

197 
__THROW
 
	`__nonnull
 ((1));

199 
__extension__


200 extern unsigned long long int 
	$strtouq
 (const char *
__restrict
 
__nptr
,

201 char **
__restrict
 
__endptr
, int 
__base
)

202 
__THROW
 
	`__nonnull
 ((1));

205 #ifdef 
__USE_ISOC99


206 
__BEGIN_NAMESPACE_C99


208 
__extension__


209 extern long long int 
	$strtoll
 (const char *
__restrict
 
__nptr
,

210 char **
__restrict
 
__endptr
, int 
__base
)

211 
__THROW
 
	`__nonnull
 ((1));

213 
__extension__


214 extern unsigned long long int 
	$strtoull
 (const char *
__restrict
 
__nptr
,

215 char **
__restrict
 
__endptr
, int 
__base
)

216 
__THROW
 
	`__nonnull
 ((1));

217 
__END_NAMESPACE_C99


221 #ifdef 
__USE_GNU


235 #include 
	~<xlocale.h
>

239 extern long int 
	$strtol_l
 (const char *
__restrict
 
__nptr
,

240 char **
__restrict
 
__endptr
, int 
__base
,

241 
__locale_t
 
__loc
) 
__THROW
 
	`__nonnull
 ((1, 4));

243 extern unsigned long int 
	$strtoul_l
 (const char *
__restrict
 
__nptr
,

244 char **
__restrict
 
__endptr
,

245 int 
__base
, 
__locale_t
 
__loc
)

246 
__THROW
 
	`__nonnull
 ((1, 4));

248 
__extension__


249 extern long long int 
	$strtoll_l
 (const char *
__restrict
 
__nptr
,

250 char **
__restrict
 
__endptr
, int 
__base
,

251 
__locale_t
 
__loc
)

252 
__THROW
 
	`__nonnull
 ((1, 4));

254 
__extension__


255 extern unsigned long long int 
	$strtoull_l
 (const char *
__restrict
 
__nptr
,

256 char **
__restrict
 
__endptr
,

257 int 
__base
, 
__locale_t
 
__loc
)

258 
__THROW
 
	`__nonnull
 ((1, 4));

260 extern double 
	$strtod_l
 (const char *
__restrict
 
__nptr
,

261 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

262 
__THROW
 
	`__nonnull
 ((1, 3));

264 extern float 
	$strtof_l
 (const char *
__restrict
 
__nptr
,

265 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

266 
__THROW
 
	`__nonnull
 ((1, 3));

268 extern long double 
	$strtold_l
 (const char *
__restrict
 
__nptr
,

269 char **
__restrict
 
__endptr
,

270 
__locale_t
 
__loc
)

271 
__THROW
 
	`__nonnull
 ((1, 3));

275 #ifdef 
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__extern_inline
 int

278 
	`__NTH
 (
	$atoi
 (const char *
__nptr
))

280 return (int) 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

281 
	}
}

282 
__extern_inline
 long int

283 
__NTH
 (
	$atol
 (const char *
__nptr
))

285 return 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #ifdef 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__extension__
 
__extern_inline
 long long int

292 
__NTH
 (
	$atoll
 (const char *
__nptr
))

294 return 
	`strtoll
 (
__nptr
, (char **) 
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


305 extern char *
	$l64a
 (long int 
__n
) 
__THROW
 
__wur
;

308 extern long int 
	$a64l
 (const char *
__s
)

309 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

313 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


314 #include 
	~<sys/types.h
>

321 extern long int 
	$random
 (void) 
__THROW
;

324 extern void 
	$srandom
 (unsigned int 
__seed
) 
__THROW
;

330 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

331 
size_t
 
__statelen
) 
__THROW
 
	`__nonnull
 ((2));

335 extern char *
	$setstate
 (char *
__statebuf
) 
__THROW
 
	`__nonnull
 ((1));

338 #ifdef 
__USE_MISC


343 struct 
	srandom_data


345 
int32_t
 *
fptr
;

346 
int32_t
 *
rptr
;

347 
int32_t
 *
state
;

348 int 
rand_type
;

349 int 
rand_deg
;

350 int 
rand_sep
;

351 
int32_t
 *
end_ptr
;

354 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

355 
int32_t
 *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

357 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

358 
__THROW
 
	`__nonnull
 ((2));

360 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

361 
size_t
 
__statelen
,

362 struct 
random_data
 *
__restrict
 
__buf
)

363 
__THROW
 
	`__nonnull
 ((2, 4));

365 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

366 struct 
random_data
 *
__restrict
 
__buf
)

367 
__THROW
 
	`__nonnull
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 extern int 
	$rand
 (void) 
__THROW
;

376 extern void 
	$srand
 (unsigned int 
__seed
) 
__THROW
;

377 
__END_NAMESPACE_STD


379 #ifdef 
__USE_POSIX


381 extern int 
	$rand_r
 (unsigned int *
__seed
) 
__THROW
;

385 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


389 extern double 
	$drand48
 (void) 
__THROW
;

390 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
__THROW
 
	`__nonnull
 ((1));

393 extern long int 
	$lrand48
 (void) 
__THROW
;

394 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

395 
__THROW
 
	`__nonnull
 ((1));

398 extern long int 
	$mrand48
 (void) 
__THROW
;

399 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

400 
__THROW
 
	`__nonnull
 ((1));

403 extern void 
	$srand48
 (long int 
__seedval
) 
__THROW
;

404 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

405 
__THROW
 
	`__nonnull
 ((1));

406 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
__THROW
 
	`__nonnull
 ((1));

408 #ifdef 
__USE_MISC


412 struct 
	sdrand48_data


414 unsigned short int 
__x
[3];

415 unsigned short int 
__old_x
[3];

416 unsigned short int 
__c
;

417 unsigned short int 
__init
;

418 
__extension__
 unsigned long long int 
__a
;

423 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

424 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

425 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

426 struct 
drand48_data
 *
__restrict
 
__buffer
,

427 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

430 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

431 long int *
__restrict
 
__result
)

432 
__THROW
 
	`__nonnull
 ((1, 2));

433 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

434 struct 
drand48_data
 *
__restrict
 
__buffer
,

435 long int *
__restrict
 
__result
)

436 
__THROW
 
	`__nonnull
 ((1, 2));

439 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

440 long int *
__restrict
 
__result
)

441 
__THROW
 
	`__nonnull
 ((1, 2));

442 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

443 struct 
drand48_data
 *
__restrict
 
__buffer
,

444 long int *
__restrict
 
__result
)

445 
__THROW
 
	`__nonnull
 ((1, 2));

448 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

449 
__THROW
 
	`__nonnull
 ((2));

451 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

452 struct 
drand48_data
 *
__buffer
) 
__THROW
 
	`__nonnull
 ((1, 2));

454 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

455 struct 
drand48_data
 *
__buffer
)

456 
__THROW
 
	`__nonnull
 ((1, 2));

462 #ifndef 
__malloc_and_calloc_defined


463 #define 
	#__malloc_and_calloc_defined


	)

464 
__BEGIN_NAMESPACE_STD


466 extern void *
	$malloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

468 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

469 
__THROW
 
__attribute_malloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ifndef 
__need_malloc_and_calloc


474 
__BEGIN_NAMESPACE_STD


480 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

481 
__THROW
 
__attribute_warn_unused_result__
;

483 extern void 
	$free
 (void *
__ptr
) 
__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 extern void 
	$cfree
 (void *
__ptr
) 
__THROW
;

491 #ifdef 
__USE_MISC


492 #include 
	~<alloca.h
>

495 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

496 || 
defined
 
__USE_MISC


498 extern void *
	$valloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

501 #ifdef 
__USE_XOPEN2K


503 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

504 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

507 #ifdef 
__USE_ISOC11


509 extern void *
	$aligned_alloc
 (
size_t
 
__alignment
, size_t 
__size
)

510 
__THROW
 
__attribute_malloc__
 
	`__attribute_alloc_size__
 ((2)) 
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 extern void 
	$abort
 (void) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

519 extern int 
	$atexit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

521 #if 
defined
 
__USE_ISOC11
 || defined 
__USE_ISOCXX11


523 #ifdef 
__cplusplus


524 extern "C++" int 
	$at_quick_exit
 (void (*
__func
) (void))

525 
__THROW
 
	`__asm
 ("at_quick_exit") 
	`__nonnull
 ((1));

527 extern int 
	$at_quick_exit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 extern int 
	$on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

536 
__THROW
 
	`__nonnull
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 extern void 
	$exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

545 #if 
defined
 
__USE_ISOC11
 || defined 
__USE_ISOCXX11


549 extern void 
	$quick_exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

551 
__END_NAMESPACE_STD


553 #ifdef 
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 extern void 
	$_Exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 extern char *
	$getenv
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

565 
__END_NAMESPACE_STD


567 #ifdef 
__USE_GNU


570 extern char *
	$secure_getenv
 (const char *
__name
)

571 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

574 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


578 extern int 
	$putenv
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

581 #ifdef 
__USE_XOPEN2K


584 extern int 
	$setenv
 (const char *
__name
, const char *
__value
, int 
__replace
)

585 
__THROW
 
	`__nonnull
 ((2));

588 extern int 
	$unsetenv
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

591 #ifdef 
__USE_MISC


595 extern int 
	$clearenv
 (void) 
__THROW
;

599 #if 
defined
 
__USE_MISC
 \

600 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
)

606 extern char *
	$mktemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1));

609 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


618 #ifndef 
__USE_FILE_OFFSET64


619 extern int 
	$mkstemp
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

621 #ifdef 
__REDIRECT


622 extern int 
	`__REDIRECT
 (
mkstemp
, (char *
__template
), 
mkstemp64
)

623 
	`__nonnull
 ((1)) 
__wur
;

625 #define 
	#mkstemp
 
mkstemp64


	)

628 #ifdef 
__USE_LARGEFILE64


629 extern int 
	$mkstemp64
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

633 #ifdef 
__USE_MISC


640 #ifndef 
__USE_FILE_OFFSET64


641 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__nonnull
 ((1)) 
__wur
;

643 #ifdef 
__REDIRECT


644 extern int 
	`__REDIRECT
 (
mkstemps
, (char *
__template
, int 
__suffixlen
),

645 
mkstemps64
) 
	`__nonnull
 ((1)) 
__wur
;

647 #define 
	#mkstemps
 
mkstemps64


	)

650 #ifdef 
__USE_LARGEFILE64


651 extern int 
	$mkstemps64
 (char *
__template
, int 
__suffixlen
)

652 
	`__nonnull
 ((1)) 
__wur
;

656 #ifdef 
__USE_XOPEN2K8


662 extern char *
	$mkdtemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

665 #ifdef 
__USE_GNU


672 #ifndef 
__USE_FILE_OFFSET64


673 extern int 
	$mkostemp
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

675 #ifdef 
__REDIRECT


676 extern int 
	`__REDIRECT
 (
mkostemp
, (char *
__template
, int 
__flags
), 
mkostemp64
)

677 
	`__nonnull
 ((1)) 
__wur
;

679 #define 
	#mkostemp
 
mkostemp64


	)

682 #ifdef 
__USE_LARGEFILE64


683 extern int 
	$mkostemp64
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

692 #ifndef 
__USE_FILE_OFFSET64


693 extern int 
	$mkostemps
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

694 
	`__nonnull
 ((1)) 
__wur
;

696 #ifdef 
__REDIRECT


697 extern int 
	`__REDIRECT
 (
mkostemps
, (char *
__template
, int 
__suffixlen
,

698 int 
__flags
), 
mkostemps64
)

699 
	`__nonnull
 ((1)) 
__wur
;

701 #define 
	#mkostemps
 
mkostemps64


	)

704 #ifdef 
__USE_LARGEFILE64


705 extern int 
	$mkostemps64
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

706 
	`__nonnull
 ((1)) 
__wur
;

711 
__BEGIN_NAMESPACE_STD


716 extern int 
	$system
 (const char *
__command
) 
__wur
;

717 
__END_NAMESPACE_STD


720 #ifdef 
__USE_GNU


723 extern char *
	$canonicalize_file_name
 (const char *
__name
)

724 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

727 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


733 extern char *
	$realpath
 (const char *
__restrict
 
__name
,

734 char *
__restrict
 
__resolved
) 
__THROW
 
__wur
;

739 #ifndef 
__COMPAR_FN_T


740 #define 
	#__COMPAR_FN_T


	)

741 typedef int (*
	t__compar_fn_t
) (const void *, const void *);

743 #ifdef 
__USE_GNU


744 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

747 #ifdef 
__USE_GNU


748 typedef int (*
	t__compar_d_fn_t
) (const void *, const void *, void *);

751 
__BEGIN_NAMESPACE_STD


754 extern void *
	$bsearch
 (const void *
__key
, const void *
__base
,

755 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

756 
	`__nonnull
 ((1, 2, 5)) 
__wur
;

758 #ifdef 
__USE_EXTERN_INLINES


759 #include 
	~<bits/stdlib-bsearch.h
>

764 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

765 
__compar_fn_t
 
__compar
) 
	`__nonnull
 ((1, 4));

766 #ifdef 
__USE_GNU


767 extern void 
	$qsort_r
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

768 
__compar_d_fn_t
 
__compar
, void *
__arg
)

769 
	`__nonnull
 ((1, 4));

774 extern int 
	$abs
 (int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

775 extern long int 
	$labs
 (long int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

776 
__END_NAMESPACE_STD


778 #ifdef 
__USE_ISOC99


779 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

780 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

784 
__BEGIN_NAMESPACE_STD


788 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

789 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

790 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

791 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

792 
__END_NAMESPACE_STD


794 #ifdef 
__USE_ISOC99


795 
__BEGIN_NAMESPACE_C99


796 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

797 long long int 
__denom
)

798 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

799 
__END_NAMESPACE_C99


803 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

804 || 
defined
 
__USE_MISC


811 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

812 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

817 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

818 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

823 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

824 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

827 #ifdef 
__USE_MISC


829 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

830 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

831 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

832 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

833 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

834 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

835 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

836 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

841 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

842 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

843 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

844 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

845 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

846 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

848 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

849 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

850 char *
__restrict
 
__buf
, 
size_t
 
__len
)

851 
__THROW
 
	`__nonnull
 ((3, 4, 5));

852 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

853 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

854 char *
__restrict
 
__buf
, 
size_t
 
__len
)

855 
__THROW
 
	`__nonnull
 ((3, 4, 5));

859 
__BEGIN_NAMESPACE_STD


862 extern int 
	$mblen
 (const char *
__s
, 
size_t
 
__n
) 
__THROW
;

865 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

866 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

869 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
__THROW
;

873 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

874 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

876 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

877 const 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

878 
__THROW
;

879 
__END_NAMESPACE_STD


882 #ifdef 
__USE_MISC


887 extern int 
	$rpmatch
 (const char *
__response
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

891 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


898 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

899 char *const *
__restrict
 
__tokens
,

900 char **
__restrict
 
__valuep
)

901 
__THROW
 
	`__nonnull
 ((1, 2, 3)) 
__wur
;

905 #ifdef 
__USE_XOPEN


907 extern void 
	$setkey
 (const char *
__key
) 
__THROW
 
	`__nonnull
 ((1));

913 #ifdef 
__USE_XOPEN2KXSI


915 extern int 
	$posix_openpt
 (int 
__oflag
) 
__wur
;

918 #ifdef 
__USE_XOPEN


923 extern int 
	$grantpt
 (int 
__fd
) 
__THROW
;

927 extern int 
	$unlockpt
 (int 
__fd
) 
__THROW
;

932 extern char *
	$ptsname
 (int 
__fd
) 
__THROW
 
__wur
;

935 #ifdef 
__USE_GNU


939 extern int 
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

940 
__THROW
 
	`__nonnull
 ((2));

943 extern int 
	`getpt
 (void);

946 #ifdef 
__USE_MISC


950 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

951 
__THROW
 
	`__nonnull
 ((1));

954 #include 
	~<bits/stdlib-float.h
>

957 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


958 #include 
	~<bits/stdlib.h
>

960 #ifdef 
__LDBL_COMPAT


961 #include 
	~<bits/stdlib-ldbl.h
>

965 #undef 
__need_malloc_and_calloc


967 
__END_DECLS


	@/usr/include/string.h

22 #ifndef 
_STRING_H


23 #define 
	#_STRING_H
 1

	)

25 #include 
	~<features.h
>

27 
	g__BEGIN_DECLS


30 #define 
	#__need_size_t


	)

31 #define 
	#__need_NULL


	)

32 #include 
	~<stddef.h
>

35 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

36 #define 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

40 
__BEGIN_NAMESPACE_STD


42 extern void *
	$memcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

43 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

46 extern void *
	$memmove
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

47 
__THROW
 
	`__nonnull
 ((1, 2));

48 
__END_NAMESPACE_STD


53 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


54 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

55 int 
__c
, 
size_t
 
__n
)

56 
__THROW
 
	`__nonnull
 ((1, 2));

60 
__BEGIN_NAMESPACE_STD


62 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

65 extern int 
	$memcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

66 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

69 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


72 extern void *
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

73 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

74 extern const void *
	`memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

75 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

77 #ifdef 
__OPTIMIZE__


78 
__extern_always_inline
 void *

79 
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


81 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

84 
__extern_always_inline
 const void *

85 
	`memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


87 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

90 
	}
}

92 extern void *
	$memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

93 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

95 
__END_NAMESPACE_STD


97 #ifdef 
__USE_GNU


100 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


101 extern "C++" void *
	$rawmemchr
 (void *
__s
, int 
__c
)

102 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

103 extern "C++" const void *
	$rawmemchr
 (const void *
__s
, int 
__c
)

104 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

106 extern void *
	$rawmemchr
 (const void *
__s
, int 
__c
)

107 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

111 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


112 extern "C++" void *
	$memrchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

113 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

114 extern "C++" const void *
	$memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

115 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

117 extern void *
	$memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

118 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

123 
__BEGIN_NAMESPACE_STD


125 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

126 
__THROW
 
	`__nonnull
 ((1, 2));

128 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

129 const char *
__restrict
 
__src
, 
size_t
 
__n
)

130 
__THROW
 
	`__nonnull
 ((1, 2));

133 extern char *
	$strcat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

134 
__THROW
 
	`__nonnull
 ((1, 2));

136 extern char *
	$strncat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

137 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

140 extern int 
	$strcmp
 (const char *
__s1
, const char *
__s2
)

141 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

143 extern int 
	$strncmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

144 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

147 extern int 
	$strcoll
 (const char *
__s1
, const char *
__s2
)

148 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

150 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

151 const char *
__restrict
 
__src
, 
size_t
 
__n
)

152 
__THROW
 
	`__nonnull
 ((2));

153 
__END_NAMESPACE_STD


155 #ifdef 
__USE_XOPEN2K8


159 #include 
	~<xlocale.h
>

162 extern int 
	$strcoll_l
 (const char *
__s1
, const char *
__s2
, 
__locale_t
 
__l
)

163 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

165 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
,

166 
__locale_t
 
__l
) 
__THROW
 
	`__nonnull
 ((2, 4));

169 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


171 extern char *
	$strdup
 (const char *
__s
)

172 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

178 #if 
defined
 
__USE_XOPEN2K8


179 extern char *
	$strndup
 (const char *
__string
, 
size_t
 
__n
)

180 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

183 #if 
defined
 
__USE_GNU
 && defined 
__GNUC__


185 #define 
	#strdupa
(
s
) \

186 (
__extension__
 \

188 const char *
__old
 = (
s
); \

189 
size_t
 
__len
 = 
	`strlen
 (
__old
) + 1; \

190 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
); \

191 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

192 
	}
}))

	)

195 #define 
	#strndupa
(
s
, 
n
) \

196 (
__extension__
 \

198 const char *
__old
 = (
s
); \

199 
size_t
 
__len
 = 
	`strnlen
 (
__old
, (
n
)); \

200 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
 + 1); \

201 
__new
[
__len
] = '\0'; \

202 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

203 }))

	)

206 
	g__BEGIN_NAMESPACE_STD


208 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


211 extern char *
strchr
 (char *
__s
, int 
__c
)

212 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

213 extern const char *
strchr
 (const char *
__s
, int 
__c
)

214 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

216 #ifdef 
__OPTIMIZE__


217 
__extern_always_inline
 char *

218 
strchr
 (char *
__s
, int 
__c
) 
	g__THROW


220 return 
__builtin_strchr
 (
__s
, 
__c
);

223 
__extern_always_inline
 const char *

224 
strchr
 (const char *
__s
, int 
__c
) 
	g__THROW


226 return 
__builtin_strchr
 (
__s
, 
__c
);

231 extern char *
	$strchr
 (const char *
__s
, int 
__c
)

232 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

235 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


238 extern char *
	`strrchr
 (char *
__s
, int 
__c
)

239 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

240 extern const char *
	`strrchr
 (const char *
__s
, int 
__c
)

241 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

243 #ifdef 
__OPTIMIZE__


244 
__extern_always_inline
 char *

245 
	`strrchr
 (char *
__s
, int 
__c
) 
__THROW


247 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

250 
__extern_always_inline
 const char *

251 
	`strrchr
 (const char *
__s
, int 
__c
) 
__THROW


253 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

256 
	}
}

258 extern char *
	$strrchr
 (const char *
__s
, int 
__c
)

259 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

261 
__END_NAMESPACE_STD


263 #ifdef 
__USE_GNU


266 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


267 extern "C++" char *
	$strchrnul
 (char *
__s
, int 
__c
)

268 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

269 extern "C++" const char *
	$strchrnul
 (const char *
__s
, int 
__c
)

270 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

272 extern char *
	$strchrnul
 (const char *
__s
, int 
__c
)

273 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

277 
__BEGIN_NAMESPACE_STD


280 extern 
size_t
 
	$strcspn
 (const char *
__s
, const char *
__reject
)

281 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

284 extern 
size_t
 
	$strspn
 (const char *
__s
, const char *
__accept
)

285 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

287 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


290 extern char *
	`strpbrk
 (char *
__s
, const char *
__accept
)

291 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

292 extern const char *
	`strpbrk
 (const char *
__s
, const char *
__accept
)

293 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

295 #ifdef 
__OPTIMIZE__


296 
__extern_always_inline
 char *

297 
	`strpbrk
 (char *
__s
, const char *
__accept
) 
__THROW


299 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

302 
__extern_always_inline
 const char *

303 
	`strpbrk
 (const char *
__s
, const char *
__accept
) 
__THROW


305 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

308 
	}
}

310 extern char *
	$strpbrk
 (const char *
__s
, const char *
__accept
)

311 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

314 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


317 extern char *
	`strstr
 (char *
__haystack
, const char *
__needle
)

318 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

319 extern const char *
	`strstr
 (const char *
__haystack
, const char *
__needle
)

320 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

322 #ifdef 
__OPTIMIZE__


323 
__extern_always_inline
 char *

324 
	`strstr
 (char *
__haystack
, const char *
__needle
) 
__THROW


326 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

329 
__extern_always_inline
 const char *

330 
	`strstr
 (const char *
__haystack
, const char *
__needle
) 
__THROW


332 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

335 
	}
}

337 extern char *
	$strstr
 (const char *
__haystack
, const char *
__needle
)

338 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

343 extern char *
	$strtok
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
)

344 
__THROW
 
	`__nonnull
 ((2));

345 
__END_NAMESPACE_STD


349 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

350 const char *
__restrict
 
__delim
,

351 char **
__restrict
 
__save_ptr
)

352 
__THROW
 
	`__nonnull
 ((2, 3));

353 #ifdef 
__USE_POSIX


354 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
,

355 char **
__restrict
 
__save_ptr
)

356 
__THROW
 
	`__nonnull
 ((2, 3));

359 #ifdef 
__USE_GNU


361 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


362 extern "C++" char *
	$strcasestr
 (char *
__haystack
, const char *
__needle
)

363 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

364 extern "C++" const char *
	$strcasestr
 (const char *
__haystack
,

365 const char *
__needle
)

366 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

368 extern char *
	$strcasestr
 (const char *
__haystack
, const char *
__needle
)

369 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

373 #ifdef 
__USE_GNU


377 extern void *
	$memmem
 (const void *
__haystack
, 
size_t
 
__haystacklen
,

378 const void *
__needle
, 
size_t
 
__needlelen
)

379 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 3));

383 extern void *
	$__mempcpy
 (void *
__restrict
 
__dest
,

384 const void *
__restrict
 
__src
, 
size_t
 
__n
)

385 
__THROW
 
	`__nonnull
 ((1, 2));

386 extern void *
	$mempcpy
 (void *
__restrict
 
__dest
,

387 const void *
__restrict
 
__src
, 
size_t
 
__n
)

388 
__THROW
 
	`__nonnull
 ((1, 2));

392 
__BEGIN_NAMESPACE_STD


394 extern 
size_t
 
	$strlen
 (const char *
__s
)

395 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

396 
__END_NAMESPACE_STD


398 #ifdef 
__USE_XOPEN2K8


401 extern 
size_t
 
	$strnlen
 (const char *
__string
, 
size_t
 
__maxlen
)

402 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

406 
__BEGIN_NAMESPACE_STD


408 extern char *
	$strerror
 (int 
__errnum
) 
__THROW
;

409 
__END_NAMESPACE_STD


410 #ifdef 
__USE_XOPEN2K


418 #if 
defined
 
__USE_XOPEN2K
 && !defined 
__USE_GNU


421 #ifdef 
__REDIRECT_NTH


422 extern int 
	`__REDIRECT_NTH
 (
strerror_r
,

423 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
),

424 
__xpg_strerror_r
) 
	`__nonnull
 ((2));

426 extern int 
	$__xpg_strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

427 
__THROW
 
	`__nonnull
 ((2));

428 #define 
	#strerror_r
 
__xpg_strerror_r


	)

433 extern char *
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

434 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

438 #ifdef 
__USE_XOPEN2K8


440 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
__THROW
;

446 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

448 #ifdef 
__USE_MISC


450 extern void 
	$bcopy
 (const void *
__src
, void *
__dest
, 
size_t
 
__n
)

451 
__THROW
 
	`__nonnull
 ((1, 2));

454 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

457 extern int 
	$bcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

458 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

461 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


464 extern char *
	`index
 (char *
__s
, int 
__c
)

465 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

466 extern const char *
	`index
 (const char *
__s
, int 
__c
)

467 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

469 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


470 
__extern_always_inline
 char *

471 
	`index
 (char *
__s
, int 
__c
) 
__THROW


473 return 
	`__builtin_index
 (
__s
, 
__c
);

476 
__extern_always_inline
 const char *

477 
	`index
 (const char *
__s
, int 
__c
) 
__THROW


479 return 
	`__builtin_index
 (
__s
, 
__c
);

482 
	}
}

484 extern char *
	$index
 (const char *
__s
, int 
__c
)

485 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

489 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


492 extern char *
	`rindex
 (char *
__s
, int 
__c
)

493 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

494 extern const char *
	`rindex
 (const char *
__s
, int 
__c
)

495 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

497 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


498 
__extern_always_inline
 char *

499 
	`rindex
 (char *
__s
, int 
__c
) 
__THROW


501 return 
	`__builtin_rindex
 (
__s
, 
__c
);

504 
__extern_always_inline
 const char *

505 
	`rindex
 (const char *
__s
, int 
__c
) 
__THROW


507 return 
	`__builtin_rindex
 (
__s
, 
__c
);

510 
	}
}

512 extern char *
	$rindex
 (const char *
__s
, int 
__c
)

513 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

518 extern int 
	$ffs
 (int 
__i
) 
__THROW
 
	`__attribute__
 ((
__const__
));

522 #ifdef 
__USE_GNU


523 extern int 
	$ffsl
 (long int 
__l
) 
__THROW
 
	`__attribute__
 ((
__const__
));

524 
__extension__
 extern int 
	$ffsll
 (long long int 
__ll
)

525 
__THROW
 
	`__attribute__
 ((
__const__
));

529 extern int 
	$strcasecmp
 (const char *
__s1
, const char *
__s2
)

530 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

533 extern int 
	$strncasecmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

534 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

537 #ifdef 
__USE_GNU


540 extern int 
	$strcasecmp_l
 (const char *
__s1
, const char *
__s2
,

541 
__locale_t
 
__loc
)

542 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

544 extern int 
	$strncasecmp_l
 (const char *
__s1
, const char *
__s2
,

545 
size_t
 
__n
, 
__locale_t
 
__loc
)

546 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 4));

549 #ifdef 
__USE_MISC


552 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

553 const char *
__restrict
 
__delim
)

554 
__THROW
 
	`__nonnull
 ((1, 2));

557 #ifdef 
__USE_XOPEN2K8


559 extern char *
	$strsignal
 (int 
__sig
) 
__THROW
;

562 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

563 
__THROW
 
	`__nonnull
 ((1, 2));

564 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

565 
__THROW
 
	`__nonnull
 ((1, 2));

569 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

570 const char *
__restrict
 
__src
, 
size_t
 
__n
)

571 
__THROW
 
	`__nonnull
 ((1, 2));

572 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

573 const char *
__restrict
 
__src
, 
size_t
 
__n
)

574 
__THROW
 
	`__nonnull
 ((1, 2));

577 #ifdef 
__USE_GNU


579 extern int 
	$strverscmp
 (const char *
__s1
, const char *
__s2
)

580 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

583 extern char *
	$strfry
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

586 extern void *
	$memfrob
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

588 #ifndef 
basename


593 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


594 extern "C++" char *
	$basename
 (char *
__filename
)

595 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

596 extern "C++" const char *
	$basename
 (const char *
__filename
)

597 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

599 extern char *
	$basename
 (const char *
__filename
) 
__THROW
 
	`__nonnull
 ((1));

605 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

606 #if 
defined
 
__OPTIMIZE__
 && !defined 
__OPTIMIZE_SIZE__
 \

607 && !
defined
 
__NO_INLINE__
 && !defined 
__cplusplus


627 #include 
	~<bits/string.h
>

630 #include 
	~<bits/string2.h
>

633 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


635 #include 
	~<bits/string3.h
>

639 #if 
defined
 
__USE_GNU
 && defined 
__OPTIMIZE__
 \

640 && 
defined
 
__extern_always_inline
 && 
	$__GNUC_PREREQ
 (3,2)

641 #if !
defined
 
_FORCE_INLINES
 && !defined 
_HAVE_STRING_ARCH_mempcpy


643 #undef 
mempcpy


644 #undef 
__mempcpy


645 #define 
	#mempcpy
(
dest
, 
src
, 
n
) 
	`__mempcpy_inline
 (dest, src, n)

	)

646 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) 
	`__mempcpy_inline
 (dest, src, n)

	)

648 
__extern_always_inline
 void *

649 
	$__mempcpy_inline
 (void *
__restrict
 
__dest
,

650 const void *
__restrict
 
__src
, 
size_t
 
__n
)

652 return (char *) 
	`memcpy
 (
__dest
, 
__src
, 
__n
) + __n;

653 
	}
}

658 
	g__END_DECLS


	@/usr/include/unistd.h

22 #ifndef 
_UNISTD_H


23 #define 
	#_UNISTD_H
 1

	)

25 #include 
	~<features.h
>

27 
	g__BEGIN_DECLS


32 #ifdef 
__USE_XOPEN2K8


34 #define 
	#_POSIX_VERSION
 200809L

	)

35 #elif 
defined
 
__USE_XOPEN2K


37 #define 
	#_POSIX_VERSION
 200112L

	)

38 #elif 
defined
 
__USE_POSIX199506


40 #define 
	#_POSIX_VERSION
 199506L

	)

41 #elif 
defined
 
__USE_POSIX199309


43 #define 
	#_POSIX_VERSION
 199309L

	)

46 #define 
	#_POSIX_VERSION
 199009L

	)

52 #ifdef 
__USE_XOPEN2K8


53 #define 
	#__POSIX2_THIS_VERSION
 200809L

	)

55 #elif 
defined
 
__USE_XOPEN2K


57 #define 
	#__POSIX2_THIS_VERSION
 200112L

	)

58 #elif 
defined
 
__USE_POSIX199506


60 #define 
	#__POSIX2_THIS_VERSION
 199506L

	)

63 #define 
	#__POSIX2_THIS_VERSION
 199209L

	)

67 #define 
	#_POSIX2_VERSION
 
__POSIX2_THIS_VERSION


	)

70 #define 
	#_POSIX2_C_VERSION
 
__POSIX2_THIS_VERSION


	)

74 #define 
	#_POSIX2_C_BIND
 
__POSIX2_THIS_VERSION


	)

78 #define 
	#_POSIX2_C_DEV
 
__POSIX2_THIS_VERSION


	)

82 #define 
	#_POSIX2_SW_DEV
 
__POSIX2_THIS_VERSION


	)

86 #define 
	#_POSIX2_LOCALEDEF
 
__POSIX2_THIS_VERSION


	)

89 #ifdef 
__USE_XOPEN2K8


90 #define 
	#_XOPEN_VERSION
 700

	)

91 #elif 
defined
 
__USE_XOPEN2K


92 #define 
	#_XOPEN_VERSION
 600

	)

93 #elif 
defined
 
__USE_UNIX98


94 #define 
	#_XOPEN_VERSION
 500

	)

96 #define 
	#_XOPEN_VERSION
 4

	)

100 #define 
	#_XOPEN_XCU_VERSION
 4

	)

103 #define 
	#_XOPEN_XPG2
 1

	)

104 #define 
	#_XOPEN_XPG3
 1

	)

105 #define 
	#_XOPEN_XPG4
 1

	)

108 #define 
	#_XOPEN_UNIX
 1

	)

111 #define 
	#_XOPEN_CRYPT
 1

	)

115 #define 
	#_XOPEN_ENH_I18N
 1

	)

118 #define 
	#_XOPEN_LEGACY
 1

	)

205 #include 
	~<bits/posix_opt.h
>

208 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


209 #include 
	~<bits/environments.h
>

213 #define 
	#STDIN_FILENO
 0

	)

214 #define 
	#STDOUT_FILENO
 1

	)

215 #define 
	#STDERR_FILENO
 2

	)

220 #include 
	~<bits/types.h
>

222 #ifndef 
__ssize_t_defined


223 typedef 
__ssize_t
 
	tssize_t
;

224 #define 
	#__ssize_t_defined


	)

227 #define 
	#__need_size_t


	)

228 #define 
	#__need_NULL


	)

229 #include 
	~<stddef.h
>

231 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K


234 #ifndef 
__gid_t_defined


235 typedef 
__gid_t
 
	tgid_t
;

236 #define 
	#__gid_t_defined


	)

239 #ifndef 
__uid_t_defined


240 typedef 
__uid_t
 
	tuid_t
;

241 #define 
	#__uid_t_defined


	)

244 #ifndef 
__off_t_defined


245 #ifndef 
__USE_FILE_OFFSET64


246 typedef 
__off_t
 
	toff_t
;

248 typedef 
__off64_t
 
	toff_t
;

250 #define 
	#__off_t_defined


	)

252 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


253 typedef 
__off64_t
 
	toff64_t
;

254 #define 
	#__off64_t_defined


	)

257 #ifndef 
__useconds_t_defined


258 typedef 
__useconds_t
 
	tuseconds_t
;

259 #define 
	#__useconds_t_defined


	)

262 #ifndef 
__pid_t_defined


263 typedef 
__pid_t
 
	tpid_t
;

264 #define 
	#__pid_t_defined


	)

268 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


269 #ifndef 
__intptr_t_defined


270 typedef 
__intptr_t
 
	tintptr_t
;

271 #define 
	#__intptr_t_defined


	)

275 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


276 #ifndef 
__socklen_t_defined


277 typedef 
__socklen_t
 
	tsocklen_t
;

278 #define 
	#__socklen_t_defined


	)

284 #define 
	#R_OK
 4

	)

285 #define 
	#W_OK
 2

	)

286 #define 
	#X_OK
 1

	)

287 #define 
	#F_OK
 0

	)

290 extern int 
	$access
 (const char *
__name
, int 
__type
) 
__THROW
 
	`__nonnull
 ((1));

292 #ifdef 
__USE_GNU


295 extern int 
	$euidaccess
 (const char *
__name
, int 
__type
)

296 
__THROW
 
	`__nonnull
 ((1));

299 extern int 
	$eaccess
 (const char *
__name
, int 
__type
)

300 
__THROW
 
	`__nonnull
 ((1));

303 #ifdef 
__USE_ATFILE


307 extern int 
	$faccessat
 (int 
__fd
, const char *
__file
, int 
__type
, int 
__flag
)

308 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

313 #ifndef 
_STDIO_H


314 #define 
	#SEEK_SET
 0

	)

315 #define 
	#SEEK_CUR
 1

	)

316 #define 
	#SEEK_END
 2

	)

317 #ifdef 
__USE_GNU


318 #define 
	#SEEK_DATA
 3

	)

319 #define 
	#SEEK_HOLE
 4

	)

323 #if 
defined
 
__USE_MISC
 && !defined 
L_SET


325 #define 
	#L_SET
 
SEEK_SET


	)

326 #define 
	#L_INCR
 
SEEK_CUR


	)

327 #define 
	#L_XTND
 
SEEK_END


	)

336 #ifndef 
__USE_FILE_OFFSET64


337 extern 
__off_t
 
	$lseek
 (int 
__fd
, 
__off_t
 
__offset
, int 
__whence
) 
__THROW
;

339 #ifdef 
__REDIRECT_NTH


340 extern 
__off64_t
 
	`__REDIRECT_NTH
 (
lseek
,

341 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
),

342 
lseek64
);

344 #define 
	#lseek
 
lseek64


	)

347 #ifdef 
__USE_LARGEFILE64


348 extern 
__off64_t
 
	$lseek64
 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
)

349 
__THROW
;

356 extern int 
	`close
 (int 
__fd
);

363 extern 
ssize_t
 
	$read
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
) 
__wur
;

369 extern 
ssize_t
 
	$write
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
) 
__wur
;

371 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


372 #ifndef 
__USE_FILE_OFFSET64


379 extern 
ssize_t
 
	$pread
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

380 
__off_t
 
__offset
) 
__wur
;

387 extern 
ssize_t
 
	$pwrite
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
,

388 
__off_t
 
__offset
) 
__wur
;

390 #ifdef 
__REDIRECT


391 extern 
ssize_t
 
	`__REDIRECT
 (
pread
, (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

392 
__off64_t
 
__offset
),

393 
pread64
) 
__wur
;

394 extern 
ssize_t
 
	`__REDIRECT
 (
pwrite
, (int 
__fd
, const void *
__buf
,

395 
size_t
 
__nbytes
, 
__off64_t
 
__offset
),

396 
pwrite64
) 
__wur
;

398 #define 
	#pread
 
pread64


	)

399 #define 
	#pwrite
 
pwrite64


	)

403 #ifdef 
__USE_LARGEFILE64


407 extern 
ssize_t
 
	$pread64
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

408 
__off64_t
 
__offset
) 
__wur
;

411 extern 
ssize_t
 
	$pwrite64
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
,

412 
__off64_t
 
__offset
) 
__wur
;

420 extern int 
	$pipe
 (int 
__pipedes
[2]) 
__THROW
 
__wur
;

422 #ifdef 
__USE_GNU


425 extern int 
	$pipe2
 (int 
__pipedes
[2], int 
__flags
) 
__THROW
 
__wur
;

435 extern unsigned int 
	$alarm
 (unsigned int 
__seconds
) 
__THROW
;

447 extern unsigned int 
	`sleep
 (unsigned int 
__seconds
);

449 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

450 || 
defined
 
__USE_MISC


455 extern 
__useconds_t
 
	$ualarm
 (
__useconds_t
 
__value
, __useconds_t 
__interval
)

456 
__THROW
;

463 extern int 
	`usleep
 (
__useconds_t
 
__useconds
);

472 extern int 
	`pause
 (void);

476 extern int 
	$chown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

477 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

479 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


481 extern int 
	$fchown
 (int 
__fd
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
) 
__THROW
 
__wur
;

486 extern int 
	$lchown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

487 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

491 #ifdef 
__USE_ATFILE


494 extern int 
	$fchownat
 (int 
__fd
, const char *
__file
, 
__uid_t
 
__owner
,

495 
__gid_t
 
__group
, int 
__flag
)

496 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

500 extern int 
	$chdir
 (const char *
__path
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

502 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


504 extern int 
	$fchdir
 (int 
__fd
) 
__THROW
 
__wur
;

514 extern char *
	$getcwd
 (char *
__buf
, 
size_t
 
__size
) 
__THROW
 
__wur
;

516 #ifdef 
__USE_GNU


520 extern char *
	$get_current_dir_name
 (void) 
__THROW
;

523 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

524 || 
defined
 
__USE_MISC


528 extern char *
	$getwd
 (char *
__buf
)

529 
__THROW
 
	`__nonnull
 ((1)) 
__attribute_deprecated__
 
__wur
;

534 extern int 
	$dup
 (int 
__fd
) 
__THROW
 
__wur
;

537 extern int 
	$dup2
 (int 
__fd
, int 
__fd2
) 
__THROW
;

539 #ifdef 
__USE_GNU


542 extern int 
	$dup3
 (int 
__fd
, int 
__fd2
, int 
__flags
) 
__THROW
;

546 extern char **
__environ
;

547 #ifdef 
__USE_GNU


548 extern char **
environ
;

554 extern int 
	$execve
 (const char *
__path
, char *const 
__argv
[],

555 char *const 
__envp
[]) 
__THROW
 
	`__nonnull
 ((1, 2));

557 #ifdef 
__USE_XOPEN2K8


560 extern int 
	$fexecve
 (int 
__fd
, char *const 
__argv
[], char *const 
__envp
[])

561 
__THROW
 
	`__nonnull
 ((2));

566 extern int 
	$execv
 (const char *
__path
, char *const 
__argv
[])

567 
__THROW
 
	`__nonnull
 ((1, 2));

571 extern int 
	$execle
 (const char *
__path
, const char *
__arg
, ...)

572 
__THROW
 
	`__nonnull
 ((1, 2));

576 extern int 
	$execl
 (const char *
__path
, const char *
__arg
, ...)

577 
__THROW
 
	`__nonnull
 ((1, 2));

581 extern int 
	$execvp
 (const char *
__file
, char *const 
__argv
[])

582 
__THROW
 
	`__nonnull
 ((1, 2));

587 extern int 
	$execlp
 (const char *
__file
, const char *
__arg
, ...)

588 
__THROW
 
	`__nonnull
 ((1, 2));

590 #ifdef 
__USE_GNU


593 extern int 
	$execvpe
 (const char *
__file
, char *const 
__argv
[],

594 char *const 
__envp
[])

595 
__THROW
 
	`__nonnull
 ((1, 2));

599 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


601 extern int 
	$nice
 (int 
__inc
) 
__THROW
 
__wur
;

606 extern void 
	$_exit
 (int 
__status
) 
	`__attribute__
 ((
__noreturn__
));

612 #include 
	~<bits/confname.h
>

615 extern long int 
	$pathconf
 (const char *
__path
, int 
__name
)

616 
__THROW
 
	`__nonnull
 ((1));

619 extern long int 
	$fpathconf
 (int 
__fd
, int 
__name
) 
__THROW
;

622 extern long int 
	$sysconf
 (int 
__name
) 
__THROW
;

624 #ifdef 
__USE_POSIX2


626 extern 
size_t
 
	$confstr
 (int 
__name
, char *
__buf
, 
size_t
 
__len
) 
__THROW
;

631 extern 
__pid_t
 
	$getpid
 (void) 
__THROW
;

634 extern 
__pid_t
 
	$getppid
 (void) 
__THROW
;

637 extern 
__pid_t
 
	$getpgrp
 (void) 
__THROW
;

640 extern 
__pid_t
 
	$__getpgid
 (
__pid_t
 
__pid
) 
__THROW
;

641 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


642 extern 
__pid_t
 
	$getpgid
 (
__pid_t
 
__pid
) 
__THROW
;

649 extern int 
	$setpgid
 (
__pid_t
 
__pid
, __pid_t 
__pgid
) 
__THROW
;

651 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


663 extern int 
	$setpgrp
 (void) 
__THROW
;

670 extern 
__pid_t
 
	$setsid
 (void) 
__THROW
;

672 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


674 extern 
__pid_t
 
	$getsid
 (
__pid_t
 
__pid
) 
__THROW
;

678 extern 
__uid_t
 
	$getuid
 (void) 
__THROW
;

681 extern 
__uid_t
 
	$geteuid
 (void) 
__THROW
;

684 extern 
__gid_t
 
	$getgid
 (void) 
__THROW
;

687 extern 
__gid_t
 
	$getegid
 (void) 
__THROW
;

692 extern int 
	$getgroups
 (int 
__size
, 
__gid_t
 
__list
[]) 
__THROW
 
__wur
;

694 #ifdef 
__USE_GNU


696 extern int 
	$group_member
 (
__gid_t
 
__gid
) 
__THROW
;

703 extern int 
	$setuid
 (
__uid_t
 
__uid
) 
__THROW
 
__wur
;

705 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


708 extern int 
	$setreuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
) 
__THROW
 
__wur
;

711 #ifdef 
__USE_XOPEN2K


713 extern int 
	$seteuid
 (
__uid_t
 
__uid
) 
__THROW
 
__wur
;

720 extern int 
	$setgid
 (
__gid_t
 
__gid
) 
__THROW
 
__wur
;

722 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


725 extern int 
	$setregid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
) 
__THROW
 
__wur
;

728 #ifdef 
__USE_XOPEN2K


730 extern int 
	$setegid
 (
__gid_t
 
__gid
) 
__THROW
 
__wur
;

733 #ifdef 
__USE_GNU


736 extern int 
	$getresuid
 (
__uid_t
 *
__ruid
, __uid_t *
__euid
, __uid_t *
__suid
)

737 
__THROW
;

741 extern int 
	$getresgid
 (
__gid_t
 *
__rgid
, __gid_t *
__egid
, __gid_t *
__sgid
)

742 
__THROW
;

746 extern int 
	$setresuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
, __uid_t 
__suid
)

747 
__THROW
 
__wur
;

751 extern int 
	$setresgid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
, __gid_t 
__sgid
)

752 
__THROW
 
__wur
;

759 extern 
__pid_t
 
	$fork
 (void) 
__THROWNL
;

761 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

762 || 
defined
 
__USE_MISC


767 extern 
__pid_t
 
	$vfork
 (void) 
__THROW
;

773 extern char *
	$ttyname
 (int 
__fd
) 
__THROW
;

777 extern int 
	$ttyname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

778 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

782 extern int 
	$isatty
 (int 
__fd
) 
__THROW
;

784 #if 
defined
 
__USE_MISC
 \

785 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_UNIX98
)

788 extern int 
	$ttyslot
 (void) 
__THROW
;

793 extern int 
	$link
 (const char *
__from
, const char *
__to
)

794 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

796 #ifdef 
__USE_ATFILE


799 extern int 
	$linkat
 (int 
__fromfd
, const char *
__from
, int 
__tofd
,

800 const char *
__to
, int 
__flags
)

801 
__THROW
 
	`__nonnull
 ((2, 4)) 
__wur
;

804 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


806 extern int 
	$symlink
 (const char *
__from
, const char *
__to
)

807 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

812 extern 
ssize_t
 
	$readlink
 (const char *
__restrict
 
__path
,

813 char *
__restrict
 
__buf
, 
size_t
 
__len
)

814 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

817 #ifdef 
__USE_ATFILE


819 extern int 
	$symlinkat
 (const char *
__from
, int 
__tofd
,

820 const char *
__to
) 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

823 extern 
ssize_t
 
	$readlinkat
 (int 
__fd
, const char *
__restrict
 
__path
,

824 char *
__restrict
 
__buf
, 
size_t
 
__len
)

825 
__THROW
 
	`__nonnull
 ((2, 3)) 
__wur
;

829 extern int 
	$unlink
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

831 #ifdef 
__USE_ATFILE


833 extern int 
	$unlinkat
 (int 
__fd
, const char *
__name
, int 
__flag
)

834 
__THROW
 
	`__nonnull
 ((2));

838 extern int 
	$rmdir
 (const char *
__path
) 
__THROW
 
	`__nonnull
 ((1));

842 extern 
__pid_t
 
	$tcgetpgrp
 (int 
__fd
) 
__THROW
;

845 extern int 
	$tcsetpgrp
 (int 
__fd
, 
__pid_t
 
__pgrp_id
) 
__THROW
;

852 extern char *
	`getlogin
 (void);

853 #if 
defined
 
__USE_REENTRANT
 || defined 
__USE_POSIX199506


860 extern int 
	$getlogin_r
 (char *
__name
, 
size_t
 
__name_len
) 
	`__nonnull
 ((1));

863 #ifdef 
__USE_MISC


865 extern int 
	$setlogin
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

869 #ifdef 
__USE_POSIX2


873 #define 
	#__need_getopt


	)

874 #include 
	~<getopt.h
>

878 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


882 extern int 
	$gethostname
 (char *
__name
, 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((1));

886 #if 
defined
 
__USE_MISC


889 extern int 
	$sethostname
 (const char *
__name
, 
size_t
 
__len
)

890 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

894 extern int 
	$sethostid
 (long int 
__id
) 
__THROW
 
__wur
;

900 extern int 
	$getdomainname
 (char *
__name
, 
size_t
 
__len
)

901 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

902 extern int 
	$setdomainname
 (const char *
__name
, 
size_t
 
__len
)

903 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

909 extern int 
	$vhangup
 (void) 
__THROW
;

912 extern int 
	$revoke
 (const char *
__file
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

920 extern int 
	$profil
 (unsigned short int *
__sample_buffer
, 
size_t
 
__size
,

921 
size_t
 
__offset
, unsigned int 
__scale
)

922 
__THROW
 
	`__nonnull
 ((1));

928 extern int 
	$acct
 (const char *
__name
) 
__THROW
;

932 extern char *
	$getusershell
 (void) 
__THROW
;

933 extern void 
	$endusershell
 (void) 
__THROW
;

934 extern void 
	$setusershell
 (void) 
__THROW
;

940 extern int 
	$daemon
 (int 
__nochdir
, int 
__noclose
) 
__THROW
 
__wur
;

944 #if 
defined
 
__USE_MISC
 || (defined 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

947 extern int 
	$chroot
 (const char *
__path
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

951 extern char *
	$getpass
 (const char *
__prompt
) 
	`__nonnull
 ((1));

959 extern int 
	`fsync
 (int 
__fd
);

962 #ifdef 
__USE_GNU


965 extern int 
	$syncfs
 (int 
__fd
) 
__THROW
;

969 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


972 extern long int 
	`gethostid
 (void);

975 extern void 
	$sync
 (void) 
__THROW
;

978 #if 
defined
 
__USE_MISC
 || !defined 
__USE_XOPEN2K


981 extern int 
	$getpagesize
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

986 extern int 
	$getdtablesize
 (void) 
__THROW
;

992 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


995 #ifndef 
__USE_FILE_OFFSET64


996 extern int 
	$truncate
 (const char *
__file
, 
__off_t
 
__length
)

997 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

999 #ifdef 
__REDIRECT_NTH


1000 extern int 
	`__REDIRECT_NTH
 (
truncate
,

1001 (const char *
__file
, 
__off64_t
 
__length
),

1002 
truncate64
) 
	`__nonnull
 ((1)) 
__wur
;

1004 #define 
	#truncate
 
truncate64


	)

1007 #ifdef 
__USE_LARGEFILE64


1008 extern int 
	$truncate64
 (const char *
__file
, 
__off64_t
 
__length
)

1009 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

1014 #if 
defined
 
__USE_POSIX199309
 \

1015 || 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


1018 #ifndef 
__USE_FILE_OFFSET64


1019 extern int 
	$ftruncate
 (int 
__fd
, 
__off_t
 
__length
) 
__THROW
 
__wur
;

1021 #ifdef 
__REDIRECT_NTH


1022 extern int 
	`__REDIRECT_NTH
 (
ftruncate
, (int 
__fd
, 
__off64_t
 
__length
),

1023 
ftruncate64
) 
__wur
;

1025 #define 
	#ftruncate
 
ftruncate64


	)

1028 #ifdef 
__USE_LARGEFILE64


1029 extern int 
	$ftruncate64
 (int 
__fd
, 
__off64_t
 
__length
) 
__THROW
 
__wur
;

1035 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

1036 || 
defined
 
__USE_MISC


1040 extern int 
	$brk
 (void *
__addr
) 
__THROW
 
__wur
;

1046 extern void *
	$sbrk
 (
intptr_t
 
__delta
) 
__THROW
;

1050 #ifdef 
__USE_MISC


1061 extern long int 
	$syscall
 (long int 
__sysno
, ...) 
__THROW
;

1066 #if (
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
) && !defined 
F_LOCK


1078 #define 
	#F_ULOCK
 0

	)

1079 #define 
	#F_LOCK
 1

	)

1080 #define 
	#F_TLOCK
 2

	)

1081 #define 
	#F_TEST
 3

	)

1083 #ifndef 
__USE_FILE_OFFSET64


1084 extern int 
	$lockf
 (int 
__fd
, int 
__cmd
, 
__off_t
 
__len
) 
__wur
;

1086 #ifdef 
__REDIRECT


1087 extern int 
	`__REDIRECT
 (
lockf
, (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
),

1088 
lockf64
) 
__wur
;

1090 #define 
	#lockf
 
lockf64


	)

1093 #ifdef 
__USE_LARGEFILE64


1094 extern int 
	$lockf64
 (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
) 
__wur
;

1099 #ifdef 
__USE_GNU


1104 #define 
	#TEMP_FAILURE_RETRY
(
expression
) \

1105 (
__extension__
 \

1106 ({ long int 
__result
; \

1107 do 
__result
 = (long int) (
expression
); \

1108 while (
__result
 == -1L && 
errno
 == 
EINTR
); \

1109 
__result
; 
	}
}))

	)

1112 #if 
defined
 
__USE_POSIX199309
 || defined 
__USE_UNIX98


1115 extern int 
fdatasync
 (int 
__fildes
);

1121 #ifdef 
__USE_XOPEN


1123 extern char *
	$crypt
 (const char *
__key
, const char *
__salt
)

1124 
__THROW
 
	`__nonnull
 ((1, 2));

1128 extern void 
	$encrypt
 (char *
__glibc_block
, int 
__edflag
)

1129 
__THROW
 
	`__nonnull
 ((1));

1136 extern void 
	$swab
 (const void *
__restrict
 
__from
, void *__restrict 
__to
,

1137 
ssize_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

1143 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K


1145 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

1150 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


1151 #include 
	~<bits/unistd.h
>

1154 
__END_DECLS


	@/usr/include/alloca.h

18 #ifndef 
_ALLOCA_H


19 #define 
	#_ALLOCA_H
 1

	)

21 #include 
	~<features.h
>

23 #define 
	#__need_size_t


	)

24 #include 
	~<stddef.h
>

26 
	g__BEGIN_DECLS


29 #undef 
alloca


32 extern void *
	$alloca
 (
size_t
 
__size
) 
__THROW
;

34 #ifdef 
__GNUC__


35 #define 
	#alloca
(
size
) 
	`__builtin_alloca
 (size)

	)

38 
__END_DECLS


	@/usr/include/endian.h

18 #ifndef 
_ENDIAN_H


19 #define 
	#_ENDIAN_H
 1

	)

21 #include 
	~<features.h
>

31 #define 
	#__LITTLE_ENDIAN
 1234

	)

32 #define 
	#__BIG_ENDIAN
 4321

	)

33 #define 
	#__PDP_ENDIAN
 3412

	)

36 #include 
	~<bits/endian.h
>

40 #ifndef 
__FLOAT_WORD_ORDER


41 #define 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_MISC


45 #define 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 #define 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 #define 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 #define 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


52 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) LO, 
	)
HI

53 #elif 
__BYTE_ORDER
 == 
__BIG_ENDIAN


54 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) HI, 
	)
LO

58 #if 
defined
 
__USE_MISC
 && !defined 
__ASSEMBLER__


60 #include 
	~<bits/byteswap.h
>

62 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


63 #define 
	#htobe16
(
x
) 
	`__bswap_16
 (x)

	)

64 #define 
	#htole16
(
x
) (x)

	)

65 #define 
	#be16toh
(
x
) 
	`__bswap_16
 (x)

	)

66 #define 
	#le16toh
(
x
) (x)

	)

68 #define 
	#htobe32
(
x
) 
	`__bswap_32
 (x)

	)

69 #define 
	#htole32
(
x
) (x)

	)

70 #define 
	#be32toh
(
x
) 
	`__bswap_32
 (x)

	)

71 #define 
	#le32toh
(
x
) (x)

	)

73 #define 
	#htobe64
(
x
) 
	`__bswap_64
 (x)

	)

74 #define 
	#htole64
(
x
) (x)

	)

75 #define 
	#be64toh
(
x
) 
	`__bswap_64
 (x)

	)

76 #define 
	#le64toh
(
x
) (x)

	)

79 #define 
	#htobe16
(
x
) (x)

	)

80 #define 
	#htole16
(
x
) 
	`__bswap_16
 (x)

	)

81 #define 
	#be16toh
(
x
) (x)

	)

82 #define 
	#le16toh
(
x
) 
	`__bswap_16
 (x)

	)

84 #define 
	#htobe32
(
x
) (x)

	)

85 #define 
	#htole32
(
x
) 
	`__bswap_32
 (x)

	)

86 #define 
	#be32toh
(
x
) (x)

	)

87 #define 
	#le32toh
(
x
) 
	`__bswap_32
 (x)

	)

89 #define 
	#htobe64
(
x
) (x)

	)

90 #define 
	#htole64
(
x
) 
	`__bswap_64
 (x)

	)

91 #define 
	#be64toh
(
x
) (x)

	)

92 #define 
	#le64toh
(
x
) 
	`__bswap_64
 (x)

	)

	@/usr/include/features.h

18 #ifndef 
_FEATURES_H


19 #define 
	#_FEATURES_H
 1

	)

97 #undef 
__USE_ISOC11


98 #undef 
__USE_ISOC99


99 #undef 
__USE_ISOC95


100 #undef 
__USE_ISOCXX11


101 #undef 
__USE_POSIX


102 #undef 
__USE_POSIX2


103 #undef 
__USE_POSIX199309


104 #undef 
__USE_POSIX199506


105 #undef 
__USE_XOPEN


106 #undef 
__USE_XOPEN_EXTENDED


107 #undef 
__USE_UNIX98


108 #undef 
__USE_XOPEN2K


109 #undef 
__USE_XOPEN2KXSI


110 #undef 
__USE_XOPEN2K8


111 #undef 
__USE_XOPEN2K8XSI


112 #undef 
__USE_LARGEFILE


113 #undef 
__USE_LARGEFILE64


114 #undef 
__USE_FILE_OFFSET64


115 #undef 
__USE_MISC


116 #undef 
__USE_ATFILE


117 #undef 
__USE_GNU


118 #undef 
__USE_REENTRANT


119 #undef 
__USE_FORTIFY_LEVEL


120 #undef 
__KERNEL_STRICT_NAMES


124 #ifndef 
_LOOSE_KERNEL_NAMES


125 #define 
	#__KERNEL_STRICT_NAMES


	)

135 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


136 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

137 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

139 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

146 #if (
defined
 
_BSD_SOURCE
 || defined 
_SVID_SOURCE
) \

147 && !
defined
 
	g_DEFAULT_SOURCE


152 #undef 
_DEFAULT_SOURCE


153 #define 
	#_DEFAULT_SOURCE
 1

	)

157 #ifdef 
_GNU_SOURCE


158 #undef 
_ISOC95_SOURCE


159 #define 
	#_ISOC95_SOURCE
 1

	)

160 #undef 
_ISOC99_SOURCE


161 #define 
	#_ISOC99_SOURCE
 1

	)

162 #undef 
_ISOC11_SOURCE


163 #define 
	#_ISOC11_SOURCE
 1

	)

164 #undef 
_POSIX_SOURCE


165 #define 
	#_POSIX_SOURCE
 1

	)

166 #undef 
_POSIX_C_SOURCE


167 #define 
	#_POSIX_C_SOURCE
 200809L

	)

168 #undef 
_XOPEN_SOURCE


169 #define 
	#_XOPEN_SOURCE
 700

	)

170 #undef 
_XOPEN_SOURCE_EXTENDED


171 #define 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

172 #undef 
_LARGEFILE64_SOURCE


173 #define 
	#_LARGEFILE64_SOURCE
 1

	)

174 #undef 
_DEFAULT_SOURCE


175 #define 
	#_DEFAULT_SOURCE
 1

	)

176 #undef 
_ATFILE_SOURCE


177 #define 
	#_ATFILE_SOURCE
 1

	)

182 #if (
defined
 
_DEFAULT_SOURCE
 \

183 || (!
defined
 
	g__STRICT_ANSI__
 \

184 && !
defined
 
	g_ISOC99_SOURCE
 \

185 && !
defined
 
	g_POSIX_SOURCE
 && !defined 
	g_POSIX_C_SOURCE
 \

186 && !
defined
 
	g_XOPEN_SOURCE
))

187 #undef 
_DEFAULT_SOURCE


188 #define 
	#_DEFAULT_SOURCE
 1

	)

192 #if (
defined
 
_ISOC11_SOURCE
 \

193 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

194 #define 
	#__USE_ISOC11
 1

	)

198 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC11_SOURCE
 \

199 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

200 #define 
	#__USE_ISOC99
 1

	)

204 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC11_SOURCE
 \

205 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

206 #define 
	#__USE_ISOC95
 1

	)

213 #if ((
defined
 
__cplusplus
 && __cplusplus >= 201103L) \

214 || 
defined
 
__GXX_EXPERIMENTAL_CXX0X__
)

215 #define 
	#__USE_ISOCXX11
 1

	)

221 #ifdef 
_DEFAULT_SOURCE


222 #if !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE


223 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

225 #undef 
_POSIX_SOURCE


226 #define 
	#_POSIX_SOURCE
 1

	)

227 #undef 
_POSIX_C_SOURCE


228 #define 
	#_POSIX_C_SOURCE
 200809L

	)

230 #if ((!
defined
 
__STRICT_ANSI__
 \

231 || (
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) >= 500)) \

232 && !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE
)

233 #define 
	#_POSIX_SOURCE
 1

	)

234 #if 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

235 #define 
	#_POSIX_C_SOURCE
 2

	)

236 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

237 #define 
	#_POSIX_C_SOURCE
 199506L

	)

238 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

239 #define 
	#_POSIX_C_SOURCE
 200112L

	)

241 #define 
	#_POSIX_C_SOURCE
 200809L

	)

243 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

246 #if (
defined
 
_POSIX_SOURCE
 \

247 || (
defined
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 1) \

248 || 
defined
 
_XOPEN_SOURCE
)

249 #define 
	#__USE_POSIX
 1

	)

252 #if 
defined
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 2 || defined 
_XOPEN_SOURCE


253 #define 
	#__USE_POSIX2
 1

	)

256 #if 
defined
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199309L

257 #define 
	#__USE_POSIX199309
 1

	)

260 #if 
defined
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199506L

261 #define 
	#__USE_POSIX199506
 1

	)

264 #if 
defined
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200112L

265 #define 
	#__USE_XOPEN2K
 1

	)

266 #undef 
__USE_ISOC95


267 #define 
	#__USE_ISOC95
 1

	)

268 #undef 
__USE_ISOC99


269 #define 
	#__USE_ISOC99
 1

	)

272 #if 
defined
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200809L

273 #define 
	#__USE_XOPEN2K8
 1

	)

274 #undef 
_ATFILE_SOURCE


275 #define 
	#_ATFILE_SOURCE
 1

	)

278 #ifdef 
_XOPEN_SOURCE


279 #define 
	#__USE_XOPEN
 1

	)

280 #if (
_XOPEN_SOURCE
 - 0) >= 500

281 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

282 #define 
	#__USE_UNIX98
 1

	)

283 #undef 
_LARGEFILE_SOURCE


284 #define 
	#_LARGEFILE_SOURCE
 1

	)

285 #if (
_XOPEN_SOURCE
 - 0) >= 600

286 #if (
_XOPEN_SOURCE
 - 0) >= 700

287 #define 
	#__USE_XOPEN2K8
 1

	)

288 #define 
	#__USE_XOPEN2K8XSI
 1

	)

290 #define 
	#__USE_XOPEN2K
 1

	)

291 #define 
	#__USE_XOPEN2KXSI
 1

	)

292 #undef 
__USE_ISOC95


293 #define 
	#__USE_ISOC95
 1

	)

294 #undef 
__USE_ISOC99


295 #define 
	#__USE_ISOC99
 1

	)

298 #ifdef 
_XOPEN_SOURCE_EXTENDED


299 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

304 #ifdef 
_LARGEFILE_SOURCE


305 #define 
	#__USE_LARGEFILE
 1

	)

308 #ifdef 
_LARGEFILE64_SOURCE


309 #define 
	#__USE_LARGEFILE64
 1

	)

312 #if 
defined
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

313 #define 
	#__USE_FILE_OFFSET64
 1

	)

316 #if 
defined
 
_DEFAULT_SOURCE


317 #define 
	#__USE_MISC
 1

	)

320 #ifdef 
_ATFILE_SOURCE


321 #define 
	#__USE_ATFILE
 1

	)

324 #ifdef 
_GNU_SOURCE


325 #define 
	#__USE_GNU
 1

	)

328 #if 
defined
 
_REENTRANT
 || defined 
_THREAD_SAFE


329 #define 
	#__USE_REENTRANT
 1

	)

332 #if 
defined
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

333 && 
__GNUC_PREREQ
 (4, 1) && 
defined
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

334 #if 
_FORTIFY_SOURCE
 > 1

335 #define 
	#__USE_FORTIFY_LEVEL
 2

	)

337 #define 
	#__USE_FORTIFY_LEVEL
 1

	)

340 #define 
	#__USE_FORTIFY_LEVEL
 0

	)

345 #include 
	~<stdc-predef.h
>

353 #undef 
__GNU_LIBRARY__


354 #define 
	#__GNU_LIBRARY__
 6

	)

358 #define 
	#__GLIBC__
 2

	)

359 #define 
	#__GLIBC_MINOR__
 23

	)

361 #define 
	#__GLIBC_PREREQ
(
maj
, 
min
) \

362 ((
__GLIBC__
 << 16) + 
__GLIBC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

365 #ifndef 
__ASSEMBLER__


366 #ifndef 
_SYS_CDEFS_H


367 #include 
	~<sys/cdefs.h
>

372 #if 
defined
 
__USE_FILE_OFFSET64
 && !defined 
__REDIRECT


373 #define 
	#__USE_LARGEFILE
 1

	)

374 #define 
	#__USE_LARGEFILE64
 1

	)

380 #if 
__GNUC_PREREQ
 (2, 7) && 
defined
 
__OPTIMIZE__
 \

381 && !
defined
 
	g__OPTIMIZE_SIZE__
 && !defined 
	g__NO_INLINE__
 \

382 && 
defined
 
	g__extern_inline


383 #define 
	#__USE_EXTERN_INLINES
 1

	)

391 #include 
	~<gnu/stubs.h
>

	@/usr/include/getopt.h

19 #ifndef 
_GETOPT_H


21 #ifndef 
__need_getopt


22 #define 
	#_GETOPT_H
 1

	)

32 #if !
defined
 
__GNU_LIBRARY__


33 #include 
	~<ctype.h
>

36 #ifndef 
__THROW


37 #ifndef 
__GNUC_PREREQ


38 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) (0)

	)

40 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

41 #define 
	#__THROW
 
	`throw
 ()

	)

43 #define 
	#__THROW


	)

47 #ifdef 
__cplusplus


57 extern char *
optarg
;

71 extern int 
optind
;

76 extern int 
opterr
;

80 extern int 
optopt
;

82 #ifndef 
__need_getopt


104 struct 
	soption


106 const char *
	gname
;

109 int 
	ghas_arg
;

110 int *
	gflag
;

111 int 
	gval
;

116 #define 
	#no_argument
 0

	)

117 #define 
	#required_argument
 1

	)

118 #define 
	#optional_argument
 2

	)

146 #ifdef 
__GNU_LIBRARY__


150 extern int 
getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

151 
__THROW
;

153 #if 
defined
 
__need_getopt
 && defined 
__USE_POSIX2
 \

154 && !
defined
 
	g__USE_POSIX_IMPLICITLY
 && !defined 
	g__USE_GNU


158 #ifdef 
__REDIRECT


159 extern int 
__REDIRECT_NTH
 (
getopt
, (int 
___argc
, char *const *
___argv
,

160 const char *
__shortopts
),

161 
__posix_getopt
);

163 extern int 
__posix_getopt
 (int 
___argc
, char *const *
___argv
,

164 const char *
__shortopts
) 
__THROW
;

165 #define 
	#getopt
 
__posix_getopt


	)

169 extern int 
getopt
 ();

172 #ifndef 
__need_getopt


173 extern int 
getopt_long
 (int 
___argc
, char *const *
___argv
,

174 const char *
__shortopts
,

175 const struct 
option
 *
__longopts
, int *
__longind
)

176 
__THROW
;

177 extern int 
getopt_long_only
 (int 
___argc
, char *const *
___argv
,

178 const char *
__shortopts
,

179 const struct 
option
 *
__longopts
, int *
__longind
)

180 
__THROW
;

184 #ifdef 
__cplusplus


189 #undef 
__need_getopt


	@/usr/include/libio.h

28 #ifndef 
_IO_STDIO_H


29 #define 
	#_IO_STDIO_H


	)

31 #include 
	~<_G_config.h
>

33 #define 
	#_IO_fpos_t
 
_G_fpos_t


	)

34 #define 
	#_IO_fpos64_t
 
_G_fpos64_t


	)

35 #define 
	#_IO_size_t
 
size_t


	)

36 #define 
	#_IO_ssize_t
 
__ssize_t


	)

37 #define 
	#_IO_off_t
 
__off_t


	)

38 #define 
	#_IO_off64_t
 
__off64_t


	)

39 #define 
	#_IO_pid_t
 
__pid_t


	)

40 #define 
	#_IO_uid_t
 
__uid_t


	)

41 #define 
	#_IO_iconv_t
 
_G_iconv_t


	)

42 #define 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 #define 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 #define 
	#_IO_va_list
 
_G_va_list


	)

45 #define 
	#_IO_wint_t
 
wint_t


	)

48 #define 
	#__need___va_list


	)

49 #include 
	~<stdarg.h
>

50 #ifdef 
__GNUC_VA_LIST


51 #undef 
_IO_va_list


52 #define 
	#_IO_va_list
 
__gnuc_va_list


	)

55 #ifndef 
__P


56 #include 
	~<sys/cdefs.h
>

59 #define 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ifndef 
EOF


62 #define 
	#EOF
 (-1)

	)

64 #ifndef 
NULL


65 #if 
defined
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 8))

67 #define 
	#NULL
 (
__null
)

	)

69 #if !
defined
(
__cplusplus
)

70 #define 
	#NULL
 ((void*)0)

	)

72 #define 
	#NULL
 (0)

	)

77 #define 
	#_IOS_INPUT
 1

	)

78 #define 
	#_IOS_OUTPUT
 2

	)

79 #define 
	#_IOS_ATEND
 4

	)

80 #define 
	#_IOS_APPEND
 8

	)

81 #define 
	#_IOS_TRUNC
 16

	)

82 #define 
	#_IOS_NOCREATE
 32

	)

83 #define 
	#_IOS_NOREPLACE
 64

	)

84 #define 
	#_IOS_BIN
 128

	)

92 #define 
	#_IO_MAGIC
 0xFBAD0000

	)

93 #define 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 #define 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 #define 
	#_IO_USER_BUF
 1

	)

96 #define 
	#_IO_UNBUFFERED
 2

	)

97 #define 
	#_IO_NO_READS
 4

	)

98 #define 
	#_IO_NO_WRITES
 8

	)

99 #define 
	#_IO_EOF_SEEN
 0x10

	)

100 #define 
	#_IO_ERR_SEEN
 0x20

	)

101 #define 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 #define 
	#_IO_LINKED
 0x80

	)

103 #define 
	#_IO_IN_BACKUP
 0x100

	)

104 #define 
	#_IO_LINE_BUF
 0x200

	)

105 #define 
	#_IO_TIED_PUT_GET
 0x400

	)

106 #define 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 #define 
	#_IO_IS_APPENDING
 0x1000

	)

108 #define 
	#_IO_IS_FILEBUF
 0x2000

	)

109 #define 
	#_IO_BAD_SEEN
 0x4000

	)

110 #define 
	#_IO_USER_LOCK
 0x8000

	)

112 #define 
	#_IO_FLAGS2_MMAP
 1

	)

113 #define 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifdef 
_LIBC


115 #define 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 #define 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifdef 
_LIBC


119 #define 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 #define 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 #define 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 #define 
	#_IO_SKIPWS
 01

	)

126 #define 
	#_IO_LEFT
 02

	)

127 #define 
	#_IO_RIGHT
 04

	)

128 #define 
	#_IO_INTERNAL
 010

	)

129 #define 
	#_IO_DEC
 020

	)

130 #define 
	#_IO_OCT
 040

	)

131 #define 
	#_IO_HEX
 0100

	)

132 #define 
	#_IO_SHOWBASE
 0200

	)

133 #define 
	#_IO_SHOWPOINT
 0400

	)

134 #define 
	#_IO_UPPERCASE
 01000

	)

135 #define 
	#_IO_SHOWPOS
 02000

	)

136 #define 
	#_IO_SCIENTIFIC
 04000

	)

137 #define 
	#_IO_FIXED
 010000

	)

138 #define 
	#_IO_UNITBUF
 020000

	)

139 #define 
	#_IO_STDIO
 040000

	)

140 #define 
	#_IO_DONT_CLOSE
 0100000

	)

141 #define 
	#_IO_BOOLALPHA
 0200000

	)

144 struct 
_IO_jump_t
; struct 
	g_IO_FILE
;

147 #ifdef 
_IO_MTSAFE_IO


150 typedef void 
	t_IO_lock_t
;

156 struct 
	s_IO_marker
 {

157 struct 
_IO_marker
 *
	m_next
;

158 struct 
_IO_FILE
 *
	m_sbuf
;

162 int 
	m_pos
;

164 void 
set_streampos
(
streampos
 
sp
) { 
	m_spos
 = sp; }

165 void 
set_offset
(int 
offset
) { 
	m_pos
 = offset; 
	m_spos
 = (
streampos
)(-2); }

166 
	mpublic
:

167 
streammarker
(
streambuf
 *
sb
);

168 ~
streammarker
();

169 int 
saving
() { return 
	m_spos
 == -2; }

170 int 
delta
(
streammarker
&);

171 int 
delta
();

176 enum 
	e__codecvt_result


178 
	m__codecvt_ok
,

179 
	m__codecvt_partial
,

180 
	m__codecvt_error
,

181 
	m__codecvt_noconv


184 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


187 struct 
	s_IO_codecvt


189 void (*
	m__codecvt_destr
) (struct 
	m_IO_codecvt
 *);

190 enum 
__codecvt_result
 (*
__codecvt_do_out
) (struct 
	m_IO_codecvt
 *,

191 
	m__mbstate_t
 *,

192 const 
	mwchar_t
 *,

193 const 
	mwchar_t
 *,

194 const 
	mwchar_t
 **, char *,

196 enum 
__codecvt_result
 (*
__codecvt_do_unshift
) (struct 
	m_IO_codecvt
 *,

197 
	m__mbstate_t
 *, char *,

199 enum 
__codecvt_result
 (*
__codecvt_do_in
) (struct 
	m_IO_codecvt
 *,

200 
	m__mbstate_t
 *,

202 const char **, 
	mwchar_t
 *,

203 
	mwchar_t
 *, wchar_t **);

204 int (*
	m__codecvt_do_encoding
) (struct 
	m_IO_codecvt
 *);

205 int (*
	m__codecvt_do_always_noconv
) (struct 
	m_IO_codecvt
 *);

206 int (*
	m__codecvt_do_length
) (struct 
	m_IO_codecvt
 *, 
	m__mbstate_t
 *,

207 const char *, const char *, 
	m_IO_size_t
);

208 int (*
	m__codecvt_do_max_length
) (struct 
	m_IO_codecvt
 *);

210 
_IO_iconv_t
 
	m__cd_in
;

211 
_IO_iconv_t
 
	m__cd_out
;

215 struct 
	s_IO_wide_data


217 
wchar_t
 *
	m_IO_read_ptr
;

218 
wchar_t
 *
	m_IO_read_end
;

219 
wchar_t
 *
	m_IO_read_base
;

220 
wchar_t
 *
	m_IO_write_base
;

221 
wchar_t
 *
	m_IO_write_ptr
;

222 
wchar_t
 *
	m_IO_write_end
;

223 
wchar_t
 *
	m_IO_buf_base
;

224 
wchar_t
 *
	m_IO_buf_end
;

226 
wchar_t
 *
	m_IO_save_base
;

227 
wchar_t
 *
	m_IO_backup_base
;

229 
wchar_t
 *
	m_IO_save_end
;

231 
__mbstate_t
 
	m_IO_state
;

232 
__mbstate_t
 
	m_IO_last_state
;

233 struct 
_IO_codecvt
 
	m_codecvt
;

235 
wchar_t
 
	m_shortbuf
[1];

237 const struct 
_IO_jump_t
 *
	m_wide_vtable
;

241 struct 
	s_IO_FILE
 {

242 int 
	m_flags
;

243 #define 
	#_IO_file_flags
 
_flags


	)

247 char* 
	m_IO_read_ptr
;

248 char* 
	m_IO_read_end
;

249 char* 
	m_IO_read_base
;

250 char* 
	m_IO_write_base
;

251 char* 
	m_IO_write_ptr
;

252 char* 
	m_IO_write_end
;

253 char* 
	m_IO_buf_base
;

254 char* 
	m_IO_buf_end
;

256 char *
	m_IO_save_base
;

257 char *
	m_IO_backup_base
;

258 char *
	m_IO_save_end
;

260 struct 
_IO_marker
 *
	m_markers
;

262 struct 
_IO_FILE
 *
	m_chain
;

264 int 
	m_fileno
;

266 int 
	m_blksize
;

268 int 
	m_flags2
;

270 
_IO_off_t
 
	m_old_offset
;

272 #define 
	#__HAVE_COLUMN


	)

274 unsigned short 
	m_cur_column
;

275 signed char 
	m_vtable_offset
;

276 char 
	m_shortbuf
[1];

280 
_IO_lock_t
 *
	m_lock
;

281 #ifdef 
_IO_USE_OLD_IO_FILE


284 struct 
	s_IO_FILE_complete


286 struct 
_IO_FILE
 
	m_file
;

288 #if 
defined
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

289 
_IO_off64_t
 
	m_offset
;

290 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


292 struct 
_IO_codecvt
 *
	m_codecvt
;

293 struct 
_IO_wide_data
 *
	m_wide_data
;

294 struct 
_IO_FILE
 *
	m_freeres_list
;

295 void *
	m_freeres_buf
;

297 void *
	m__pad1
;

298 void *
	m__pad2
;

299 void *
	m__pad3
;

300 void *
	m__pad4
;

302 
size_t
 
	m__pad5
;

303 int 
	m_mode
;

305 char 
	m_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

309 #ifndef 
__cplusplus


310 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

313 struct 
	g_IO_FILE_plus
;

315 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

316 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

317 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

318 #ifndef 
_LIBC


319 #define 
	#_IO_stdin
 ((
_IO_FILE
*)(&
_IO_2_1_stdin_
))

	)

320 #define 
	#_IO_stdout
 ((
_IO_FILE
*)(&
_IO_2_1_stdout_
))

	)

321 #define 
	#_IO_stderr
 ((
_IO_FILE
*)(&
_IO_2_1_stderr_
))

	)

323 extern 
_IO_FILE
 *
_IO_stdin
 
attribute_hidden
;

324 extern 
_IO_FILE
 *
_IO_stdout
 
attribute_hidden
;

325 extern 
_IO_FILE
 *
_IO_stderr
 
attribute_hidden
;

333 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

341 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, const char *
	t__buf
,

342 
	tsize_t
 
	t__n
);

350 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t_IO_off64_t
 *
	t__pos
, int 
	t__w
);

353 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

356 #ifdef 
_GNU_SOURCE


358 typedef 
__io_read_fn
 
	tcookie_read_function_t
;

359 typedef 
__io_write_fn
 
	tcookie_write_function_t
;

360 typedef 
__io_seek_fn
 
	tcookie_seek_function_t
;

361 typedef 
__io_close_fn
 
	tcookie_close_function_t
;

366 
__io_read_fn
 *
	mread
;

367 
__io_write_fn
 *
	mwrite
;

368 
__io_seek_fn
 *
	mseek
;

369 
__io_close_fn
 *
	mclose
;

370 } 
	t_IO_cookie_io_functions_t
;

371 typedef 
_IO_cookie_io_functions_t
 
	tcookie_io_functions_t
;

373 struct 
	g_IO_cookie_file
;

376 extern void 
_IO_cookie_init
 (struct 
_IO_cookie_file
 *
__cfile
, int 
__read_write
,

377 void *
__cookie
, 
_IO_cookie_io_functions_t
 
__fns
);

381 #ifdef 
__cplusplus


385 extern int 
__underflow
 (
_IO_FILE
 *);

386 extern int 
__uflow
 (
_IO_FILE
 *);

387 extern int 
__overflow
 (
_IO_FILE
 *, int);

388 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


389 extern 
_IO_wint_t
 
__wunderflow
 (
_IO_FILE
 *);

390 extern 
_IO_wint_t
 
__wuflow
 (
_IO_FILE
 *);

391 extern 
_IO_wint_t
 
__woverflow
 (
_IO_FILE
 *, _IO_wint_t);

394 #if 
__GNUC__
 >= 3

395 #define 
	#_IO_BE
(
expr
, 
res
) 
	`__builtin_expect
 ((expr), res)

	)

397 #define 
	#_IO_BE
(
expr
, 
res
) (expr)

	)

400 #define 
	#_IO_getc_unlocked
(
_fp
) \

401 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

402 ? 
	`__uflow
 (
_fp
) : *(unsigned char *) (_fp)->
_IO_read_ptr
++)

	)

403 #define 
	#_IO_peekc_unlocked
(
_fp
) \

404 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

405 && 
	`__underflow
 (
_fp
) == 
EOF
 ? EOF \

406 : *(unsigned char *) (
_fp
)->
_IO_read_ptr
)

	)

407 #define 
	#_IO_putc_unlocked
(
_ch
, 
_fp
) \

408 (
	`_IO_BE
 ((
_fp
)->
_IO_write_ptr
 >= (_fp)->
_IO_write_end
, 0) \

409 ? 
	`__overflow
 (
_fp
, (unsigned char) (
_ch
)) \

410 : (unsigned char) (*(
_fp
)->
_IO_write_ptr
++ = (
_ch
)))

	)

412 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


413 #define 
	#_IO_getwc_unlocked
(
_fp
) \

414 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

415 || ((
_fp
)->
_wide_data
->
_IO_read_ptr
 \

416 >= (
_fp
)->
_wide_data
->
_IO_read_end
), 0) \

417 ? 
	`__wuflow
 (
_fp
) : (
_IO_wint_t
) *(_fp)->
_wide_data
->
_IO_read_ptr
++)

	)

418 #define 
	#_IO_putwc_unlocked
(
_wch
, 
_fp
) \

419 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

420 || ((
_fp
)->
_wide_data
->
_IO_write_ptr
 \

421 >= (
_fp
)->
_wide_data
->
_IO_write_end
), 0) \

422 ? 
	`__woverflow
 (
_fp
, 
_wch
) \

423 : (
_IO_wint_t
) (*(
_fp
)->
_wide_data
->
_IO_write_ptr
++ = (
_wch
)))

	)

426 #define 
	#_IO_feof_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_EOF_SEEN
) != 0)

	)

427 #define 
	#_IO_ferror_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_ERR_SEEN
) != 0)

	)

429 extern int 
_IO_getc
 (
_IO_FILE
 *
__fp
);

430 extern int 
_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

431 extern int 
_IO_feof
 (
_IO_FILE
 *
__fp
) 
__THROW
;

432 extern int 
_IO_ferror
 (
_IO_FILE
 *
__fp
) 
__THROW
;

434 extern int 
_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

437 #define 
	#_IO_PENDING_OUTPUT_COUNT
(
_fp
) \

438 ((
_fp
)->
_IO_write_ptr
 - (_fp)->
_IO_write_base
)

	)

440 extern void 
_IO_flockfile
 (
_IO_FILE
 *) 
__THROW
;

441 extern void 
_IO_funlockfile
 (
_IO_FILE
 *) 
__THROW
;

442 extern int 
_IO_ftrylockfile
 (
_IO_FILE
 *) 
__THROW
;

444 #ifdef 
_IO_MTSAFE_IO


445 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_locked
 (_fp)

	)

446 #define 
	#_IO_flockfile
(
_fp
) \

447 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_flockfile
 (_fp)

	)

448 #define 
	#_IO_funlockfile
(
_fp
) \

449 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_funlockfile
 (_fp)

	)

451 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_unlocked
 (_fp)

	)

452 #define 
	#_IO_flockfile
(
_fp
)

	)

453 #define 
	#_IO_funlockfile
(
_fp
)

	)

454 #define 
	#_IO_ftrylockfile
(
_fp
)

	)

455 #define 
	#_IO_cleanup_region_start
(
_fct
, 
_fp
)

	)

456 #define 
	#_IO_cleanup_region_end
(
_Doit
)

	)

459 extern int 
_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

460 
_IO_va_list
, int *
__restrict
);

461 extern int 
_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

462 
_IO_va_list
);

463 extern 
_IO_ssize_t
 
_IO_padn
 (
_IO_FILE
 *, int, _IO_ssize_t);

464 extern 
_IO_size_t
 
_IO_sgetn
 (
_IO_FILE
 *, void *, _IO_size_t);

466 extern 
_IO_off64_t
 
_IO_seekoff
 (
_IO_FILE
 *, _IO_off64_t, int, int);

467 extern 
_IO_off64_t
 
_IO_seekpos
 (
_IO_FILE
 *, _IO_off64_t, int);

469 extern void 
_IO_free_backup_area
 (
_IO_FILE
 *) 
__THROW
;

471 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


472 extern 
_IO_wint_t
 
_IO_getwc
 (
_IO_FILE
 *
__fp
);

473 extern 
_IO_wint_t
 
_IO_putwc
 (
wchar_t
 
__wc
, 
_IO_FILE
 *
__fp
);

474 extern int 
_IO_fwide
 (
_IO_FILE
 *
__fp
, int 
__mode
) 
__THROW
;

475 #if 
__GNUC__
 >= 2

478 #if 
defined
 
_LIBC
 && defined 
SHARED


479 #include 
	~<shlib-compat.h
>

480 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

481 #define 
	#_IO_fwide_maybe_incompatible
 \

482 (
	`__builtin_expect
 (&
_IO_stdin_used
 == 
NULL
, 0))

	)

483 extern const int 
_IO_stdin_used
;

484 
weak_extern
 (
_IO_stdin_used
);

487 #ifndef 
_IO_fwide_maybe_incompatible


488 #define 
	#_IO_fwide_maybe_incompatible
 (0)

	)

492 #define 
	#_IO_fwide
(
__fp
, 
__mode
) \

493 ({ int 
__result
 = (
__mode
); \

494 if (
__result
 < 0 && ! 
_IO_fwide_maybe_incompatible
) \

496 if ((
__fp
)->
_mode
 == 0) \

498 (
__fp
)->
_mode
 = -1; \

499 
__result
 = (
__fp
)->
_mode
; \

501 else if (
	`__builtin_constant_p
 (
__mode
) && (__mode) == 0) \

502 
__result
 = 
_IO_fwide_maybe_incompatible
 ? -1 : (
__fp
)->
_mode
; \

504 
__result
 = 
	`_IO_fwide
 (
__fp
, __result); \

505 
__result
; })

	)

508 extern int 
_IO_vfwscanf
 (
_IO_FILE
 * 
__restrict
, const 
wchar_t
 * __restrict,

509 
_IO_va_list
, int *
__restrict
);

510 extern int 
_IO_vfwprintf
 (
_IO_FILE
 *
__restrict
, const 
wchar_t
 *__restrict,

511 
_IO_va_list
);

512 extern 
_IO_ssize_t
 
_IO_wpadn
 (
_IO_FILE
 *, 
wint_t
, _IO_ssize_t);

513 extern void 
_IO_free_wbackup_area
 (
_IO_FILE
 *) 
__THROW
;

516 #ifdef 
__LDBL_COMPAT


517 #include 
	~<bits/libio-ldbl.h
>

520 #ifdef 
__cplusplus


	@/usr/include/stdint.h

22 #ifndef 
_STDINT_H


23 #define 
	#_STDINT_H
 1

	)

25 #include 
	~<features.h
>

26 #include 
	~<bits/wchar.h
>

27 #include 
	~<bits/wordsize.h
>

34 #ifndef 
__int8_t_defined


35 #define 
	#__int8_t_defined


	)

36 typedef signed char 
	tint8_t
;

37 typedef short int 
	tint16_t
;

38 typedef int 
	tint32_t
;

39 #if 
__WORDSIZE
 == 64

40 typedef long int 
	tint64_t
;

42 
__extension__


43 typedef long long int 
	tint64_t
;

48 typedef unsigned char 
	tuint8_t
;

49 typedef unsigned short int 
	tuint16_t
;

50 #ifndef 
__uint32_t_defined


51 typedef unsigned int 
	tuint32_t
;

52 #define 
	#__uint32_t_defined


	)

54 #if 
__WORDSIZE
 == 64

55 typedef unsigned long int 
	tuint64_t
;

57 
__extension__


58 typedef unsigned long long int 
	tuint64_t
;

65 typedef signed char 
	tint_least8_t
;

66 typedef short int 
	tint_least16_t
;

67 typedef int 
	tint_least32_t
;

68 #if 
__WORDSIZE
 == 64

69 typedef long int 
	tint_least64_t
;

71 
__extension__


72 typedef long long int 
	tint_least64_t
;

76 typedef unsigned char 
	tuint_least8_t
;

77 typedef unsigned short int 
	tuint_least16_t
;

78 typedef unsigned int 
	tuint_least32_t
;

79 #if 
__WORDSIZE
 == 64

80 typedef unsigned long int 
	tuint_least64_t
;

82 
__extension__


83 typedef unsigned long long int 
	tuint_least64_t
;

90 typedef signed char 
	tint_fast8_t
;

91 #if 
__WORDSIZE
 == 64

92 typedef long int 
	tint_fast16_t
;

93 typedef long int 
	tint_fast32_t
;

94 typedef long int 
	tint_fast64_t
;

96 typedef int 
	tint_fast16_t
;

97 typedef int 
	tint_fast32_t
;

98 
__extension__


99 typedef long long int 
	tint_fast64_t
;

103 typedef unsigned char 
	tuint_fast8_t
;

104 #if 
__WORDSIZE
 == 64

105 typedef unsigned long int 
	tuint_fast16_t
;

106 typedef unsigned long int 
	tuint_fast32_t
;

107 typedef unsigned long int 
	tuint_fast64_t
;

109 typedef unsigned int 
	tuint_fast16_t
;

110 typedef unsigned int 
	tuint_fast32_t
;

111 
__extension__


112 typedef unsigned long long int 
	tuint_fast64_t
;

117 #if 
__WORDSIZE
 == 64

118 #ifndef 
__intptr_t_defined


119 typedef long int 
	tintptr_t
;

120 #define 
	#__intptr_t_defined


	)

122 typedef unsigned long int 
	tuintptr_t
;

124 #ifndef 
__intptr_t_defined


125 typedef int 
	tintptr_t
;

126 #define 
	#__intptr_t_defined


	)

128 typedef unsigned int 
	tuintptr_t
;

133 #if 
__WORDSIZE
 == 64

134 typedef long int 
	tintmax_t
;

135 typedef unsigned long int 
	tuintmax_t
;

137 
__extension__


138 typedef long long int 
	tintmax_t
;

139 
__extension__


140 typedef unsigned long long int 
	tuintmax_t
;

144 #if 
__WORDSIZE
 == 64

145 #define 
	#__INT64_C
(
c
) c ## 
L


	)

146 #define 
	#__UINT64_C
(
c
) c ## 
UL


	)

148 #define 
	#__INT64_C
(
c
) c ## 
LL


	)

149 #define 
	#__UINT64_C
(
c
) c ## 
ULL


	)

155 #define 
	#INT8_MIN
 (-128)

	)

156 #define 
	#INT16_MIN
 (-32767-1)

	)

157 #define 
	#INT32_MIN
 (-2147483647-1)

	)

158 #define 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

160 #define 
	#INT8_MAX
 (127)

	)

161 #define 
	#INT16_MAX
 (32767)

	)

162 #define 
	#INT32_MAX
 (2147483647)

	)

163 #define 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

166 #define 
	#UINT8_MAX
 (255)

	)

167 #define 
	#UINT16_MAX
 (65535)

	)

168 #define 
	#UINT32_MAX
 (4294967295U)

	)

169 #define 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

173 #define 
	#INT_LEAST8_MIN
 (-128)

	)

174 #define 
	#INT_LEAST16_MIN
 (-32767-1)

	)

175 #define 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

176 #define 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

178 #define 
	#INT_LEAST8_MAX
 (127)

	)

179 #define 
	#INT_LEAST16_MAX
 (32767)

	)

180 #define 
	#INT_LEAST32_MAX
 (2147483647)

	)

181 #define 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

184 #define 
	#UINT_LEAST8_MAX
 (255)

	)

185 #define 
	#UINT_LEAST16_MAX
 (65535)

	)

186 #define 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

187 #define 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

191 #define 
	#INT_FAST8_MIN
 (-128)

	)

192 #if 
__WORDSIZE
 == 64

193 #define 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

194 #define 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

196 #define 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

197 #define 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

199 #define 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

201 #define 
	#INT_FAST8_MAX
 (127)

	)

202 #if 
__WORDSIZE
 == 64

203 #define 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

204 #define 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

206 #define 
	#INT_FAST16_MAX
 (2147483647)

	)

207 #define 
	#INT_FAST32_MAX
 (2147483647)

	)

209 #define 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

212 #define 
	#UINT_FAST8_MAX
 (255)

	)

213 #if 
__WORDSIZE
 == 64

214 #define 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

215 #define 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

217 #define 
	#UINT_FAST16_MAX
 (4294967295U)

	)

218 #define 
	#UINT_FAST32_MAX
 (4294967295U)

	)

220 #define 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

224 #if 
__WORDSIZE
 == 64

225 #define 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

226 #define 
	#INTPTR_MAX
 (9223372036854775807L)

	)

227 #define 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

229 #define 
	#INTPTR_MIN
 (-2147483647-1)

	)

230 #define 
	#INTPTR_MAX
 (2147483647)

	)

231 #define 
	#UINTPTR_MAX
 (4294967295U)

	)

236 #define 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

238 #define 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

241 #define 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

247 #if 
__WORDSIZE
 == 64

248 #define 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

249 #define 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

251 #define 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

252 #define 
	#PTRDIFF_MAX
 (2147483647)

	)

256 #define 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

257 #define 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

260 #if 
__WORDSIZE
 == 64

261 #define 
	#SIZE_MAX
 (18446744073709551615UL)

	)

263 #ifdef 
__WORDSIZE32_SIZE_ULONG


264 #define 
	#SIZE_MAX
 (4294967295UL)

	)

266 #define 
	#SIZE_MAX
 (4294967295U)

	)

271 #ifndef 
WCHAR_MIN


273 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

274 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

278 #define 
	#WINT_MIN
 (0u)

	)

279 #define 
	#WINT_MAX
 (4294967295u)

	)

282 #define 
	#INT8_C
(
c
) 
	)
c

283 #define 
	#INT16_C
(
c
) 
	)
c

284 #define 
	#INT32_C
(
c
) 
	)
c

285 #if 
__WORDSIZE
 == 64

286 #define 
	#INT64_C
(
c
) c ## 
L


	)

288 #define 
	#INT64_C
(
c
) c ## 
LL


	)

292 #define 
	#UINT8_C
(
c
) 
	)
c

293 #define 
	#UINT16_C
(
c
) 
	)
c

294 #define 
	#UINT32_C
(
c
) c ## 
U


	)

295 #if 
__WORDSIZE
 == 64

296 #define 
	#UINT64_C
(
c
) c ## 
UL


	)

298 #define 
	#UINT64_C
(
c
) c ## 
ULL


	)

302 #if 
__WORDSIZE
 == 64

303 #define 
	#INTMAX_C
(
c
) c ## 
L


	)

304 #define 
	#UINTMAX_C
(
c
) c ## 
UL


	)

306 #define 
	#INTMAX_C
(
c
) c ## 
LL


	)

307 #define 
	#UINTMAX_C
(
c
) c ## 
ULL


	)

	@/usr/include/xlocale.h

20 #ifndef 
_XLOCALE_H


21 #define 
	#_XLOCALE_H
 1

	)

27 typedef struct 
	s__locale_struct


30 struct 
__locale_data
 *
	m__locales
[13];

33 const unsigned short int *
	m__ctype_b
;

34 const int *
	m__ctype_tolower
;

35 const int *
	m__ctype_toupper
;

38 const char *
	m__names
[13];

39 } *
	t__locale_t
;

42 typedef 
__locale_t
 
	tlocale_t
;

	@/usr/include/_G_config.h

4 #ifndef 
_G_config_h


5 #define 
	#_G_config_h
 1

	)

9 #include 
	~<bits/types.h
>

10 #define 
	#__need_size_t


	)

11 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


12 #define 
	#__need_wchar_t


	)

14 #define 
	#__need_NULL


	)

15 #include 
	~<stddef.h
>

16 #define 
	#__need_mbstate_t


	)

17 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


18 #define 
	#__need_wint_t


	)

20 #include 
	~<wchar.h
>

23 
__off_t
 
	m__pos
;

24 
__mbstate_t
 
	m__state
;

25 } 
	t_G_fpos_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbstate_t
 
	m__state
;

30 } 
	t_G_fpos64_t
;

31 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


32 #include 
	~<gconv.h
>

35 struct 
__gconv_info
 
	m__cd
;

38 struct 
__gconv_info
 
	m__cd
;

39 struct 
__gconv_step_data
 
	m__data
;

40 } 
	m__combined
;

41 } 
	t_G_iconv_t
;

46 #define 
	#_G_va_list
 
__gnuc_va_list


	)

48 #define 
	#_G_HAVE_MMAP
 1

	)

49 #define 
	#_G_HAVE_MREMAP
 1

	)

51 #define 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 #define 
	#_G_HAVE_ST_BLKSIZE
 
	`defined
 (
_STATBUF_ST_BLKSIZE
)

	)

56 #define 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/stdc-predef.h

18 #ifndef 
_STDC_PREDEF_H


19 #define 
	#_STDC_PREDEF_H
 1

	)

36 #ifdef 
__GCC_IEC_559


37 #if 
__GCC_IEC_559
 > 0

38 #define 
	#__STDC_IEC_559__
 1

	)

41 #define 
	#__STDC_IEC_559__
 1

	)

44 #ifdef 
__GCC_IEC_559_COMPLEX


45 #if 
__GCC_IEC_559_COMPLEX
 > 0

46 #define 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 #define 
	#__STDC_IEC_559_COMPLEX__
 1

	)

55 #define 
	#__STDC_ISO_10646__
 201505L

	)

58 #define 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/gconv.h

22 #ifndef 
_GCONV_H


23 #define 
	#_GCONV_H
 1

	)

25 #include 
	~<features.h
>

26 #define 
	#__need_mbstate_t


	)

27 #define 
	#__need_wint_t


	)

28 #include 
	~<wchar.h
>

29 #define 
	#__need_size_t


	)

30 #define 
	#__need_wchar_t


	)

31 #include 
	~<stddef.h
>

34 #define 
	#__UNKNOWN_10646_CHAR
 ((
wchar_t
) 0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004,

60 
	m__GCONV_TRANSLIT
 = 0x0008

65 struct 
	g__gconv_step
;

66 struct 
	g__gconv_step_data
;

67 struct 
	g__gconv_loaded_object
;

71 typedef int (*
	t__gconv_fct
) (struct 
	t__gconv_step
 *, struct 
	t__gconv_step_data
 *,

73 unsigned char **, 
	tsize_t
 *, int, int);

76 typedef 
	$wint_t
 (*
	t__gconv_btowc_fct
) (struct 
	t__gconv_step
 *, unsigned char);

79 typedef int (*
	t__gconv_init_fct
) (struct 
	t__gconv_step
 *);

80 typedef void (*
	t__gconv_end_fct
) (struct 
	t__gconv_step
 *);

84 struct 
	s__gconv_step


86 struct 
__gconv_loaded_object
 *
__shlib_handle
;

87 const char *
__modname
;

89 int 
__counter
;

91 char *
__from_name
;

92 char *
__to_name
;

94 
__gconv_fct
 
__fct
;

95 
__gconv_btowc_fct
 
__btowc_fct
;

96 
__gconv_init_fct
 
__init_fct
;

97 
__gconv_end_fct
 
__end_fct
;

101 int 
__min_needed_from
;

102 int 
__max_needed_from
;

103 int 
__min_needed_to
;

104 int 
__max_needed_to
;

107 int 
__stateful
;

109 void *
__data
;

114 struct 
	s__gconv_step_data


116 unsigned char *
__outbuf
;

117 unsigned char *
__outbufend
;

121 int 
__flags
;

125 int 
__invocation_counter
;

129 int 
__internal_use
;

131 
__mbstate_t
 *
__statep
;

132 
__mbstate_t
 
__state
;

138 typedef struct 
	s__gconv_info


140 
size_t
 
__nsteps
;

141 struct 
__gconv_step
 *
__steps
;

142 
__extension__
 struct 
__gconv_step_data
 
__data
 
__flexarr
;

143 } *
	t__gconv_t
;

146 extern int 
	`__gconv_transliterate
 (struct 
__gconv_step
 *
step
,

147 struct 
__gconv_step_data
 *
step_data
,

148 const unsigned char *
inbufstart
,

149 const unsigned char **
inbufp
,

150 const unsigned char *
inbufend
,

151 unsigned char **
outbufstart
,

152 
size_t
 *
irreversible
);

	@/usr/include/wchar.h

23 #ifndef 
_WCHAR_H


25 #if !
defined
 
__need_mbstate_t
 && !defined 
__need_wint_t


26 #define 
	#_WCHAR_H
 1

	)

27 #include 
	~<features.h
>

30 #ifdef 
_WCHAR_H


32 #define 
	#__need___FILE


	)

33 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


34 #define 
	#__need_FILE


	)

36 #include 
	~<stdio.h
>

38 #define 
	#__need___va_list


	)

39 #include 
	~<stdarg.h
>

41 #include 
	~<bits/wchar.h
>

44 #define 
	#__need_size_t


	)

45 #define 
	#__need_wchar_t


	)

46 #define 
	#__need_NULL


	)

48 #if 
defined
 
_WCHAR_H
 || defined 
__need_wint_t
 || !defined 
__WINT_TYPE__


49 #undef 
__need_wint_t


50 #define 
	#__need_wint_t


	)

51 #include 
	~<stddef.h
>

55 #ifndef 
_WINT_T


60 #define 
	#_WINT_T


	)

61 typedef unsigned int 
	twint_t
;

65 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defined
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 typedef 
__WINT_TYPE__
 
	twint_t
;

69 
	g__END_NAMESPACE_STD


74 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

75 #define 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #if (
defined
 
_WCHAR_H
 || defined 
__need_mbstate_t
) && !defined 
____mbstate_t_defined


80 #define 
	#____mbstate_t_defined
 1

	)

84 int 
	m__count
;

87 #ifdef 
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wint_t
 
	m__wch
;

92 char 
	m__wchb
[4];

93 } 
	m__value
;

94 } 
	t__mbstate_t
;

96 #undef 
__need_mbstate_t


101 #ifdef 
_WCHAR_H


103 #ifndef 
__mbstate_t_defined


104 
__BEGIN_NAMESPACE_C99


106 typedef 
__mbstate_t
 
	tmbstate_t
;

107 
	g__END_NAMESPACE_C99


108 #define 
	#__mbstate_t_defined
 1

	)

111 #ifdef 
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbstate_t
)

115 #ifndef 
WCHAR_MIN


117 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ifndef 
WEOF


122 #define 
	#WEOF
 (0xffffffffu)

	)

127 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_UNIX98


128 #include 
	~<wctype.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 struct 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 extern 
wchar_t
 *
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
,

148 const 
wchar_t
 *
__restrict
 
__src
)

149 
__THROW
 
	`__nonnull
 ((1, 2));

152 extern 
wchar_t
 *
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
,

153 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

154 
__THROW
 
	`__nonnull
 ((1, 2));

157 extern 
wchar_t
 *
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
,

158 const 
wchar_t
 *
__restrict
 
__src
)

159 
__THROW
 
	`__nonnull
 ((1, 2));

161 extern 
wchar_t
 *
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
,

162 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

163 
__THROW
 
	`__nonnull
 ((1, 2));

166 extern int 
	$wcscmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
)

167 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

169 extern int 
	$wcsncmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

170 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

171 
__END_NAMESPACE_STD


173 #ifdef 
__USE_XOPEN2K8


175 extern int 
	$wcscasecmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
) 
__THROW
;

178 extern int 
	$wcsncasecmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

179 
size_t
 
__n
) 
__THROW
;

183 #include 
	~<xlocale.h
>

185 extern int 
	$wcscasecmp_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

186 
__locale_t
 
__loc
) 
__THROW
;

188 extern int 
	$wcsncasecmp_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

189 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

192 
__BEGIN_NAMESPACE_STD


195 extern int 
	$wcscoll
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
) 
__THROW
;

199 extern 
size_t
 
	$wcsxfrm
 (
wchar_t
 *
__restrict
 
__s1
,

200 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

201 
__END_NAMESPACE_STD


203 #ifdef 
__USE_XOPEN2K8


209 extern int 
	$wcscoll_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

210 
__locale_t
 
__loc
) 
__THROW
;

215 extern 
size_t
 
	$wcsxfrm_l
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
,

216 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

219 extern 
wchar_t
 *
	$wcsdup
 (const 
wchar_t
 *
__s
) 
__THROW
 
__attribute_malloc__
;

222 
__BEGIN_NAMESPACE_STD


224 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


225 extern "C++" 
wchar_t
 *
	$wcschr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

226 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

227 extern "C++" const 
wchar_t
 *
	$wcschr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

228 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

230 extern 
wchar_t
 *
	$wcschr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

231 
__THROW
 
__attribute_pure__
;

234 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


235 extern "C++" 
wchar_t
 *
	$wcsrchr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

236 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

237 extern "C++" const 
wchar_t
 *
	$wcsrchr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

238 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

240 extern 
wchar_t
 *
	$wcsrchr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

241 
__THROW
 
__attribute_pure__
;

243 
__END_NAMESPACE_STD


245 #ifdef 
__USE_GNU


248 extern 
wchar_t
 *
	$wcschrnul
 (const 
wchar_t
 *
__s
, wchar_t 
__wc
)

249 
__THROW
 
__attribute_pure__
;

252 
__BEGIN_NAMESPACE_STD


255 extern 
size_t
 
	$wcscspn
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__reject
)

256 
__THROW
 
__attribute_pure__
;

259 extern 
size_t
 
	$wcsspn
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

260 
__THROW
 
__attribute_pure__
;

262 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


263 extern "C++" 
wchar_t
 *
	$wcspbrk
 (
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

264 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

265 extern "C++" const 
wchar_t
 *
	$wcspbrk
 (const 
wchar_t
 *
__wcs
,

266 const 
wchar_t
 *
__accept
)

267 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

269 extern 
wchar_t
 *
	$wcspbrk
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

270 
__THROW
 
__attribute_pure__
;

273 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


274 extern "C++" 
wchar_t
 *
	$wcsstr
 (
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

275 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

276 extern "C++" const 
wchar_t
 *
	$wcsstr
 (const 
wchar_t
 *
__haystack
,

277 const 
wchar_t
 *
__needle
)

278 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

280 extern 
wchar_t
 *
	$wcsstr
 (const 
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

281 
__THROW
 
__attribute_pure__
;

285 extern 
wchar_t
 *
	$wcstok
 (
wchar_t
 *
__restrict
 
__s
,

286 const 
wchar_t
 *
__restrict
 
__delim
,

287 
wchar_t
 **
__restrict
 
__ptr
) 
__THROW
;

290 extern 
size_t
 
	$wcslen
 (const 
wchar_t
 *
__s
) 
__THROW
 
__attribute_pure__
;

291 
__END_NAMESPACE_STD


293 #ifdef 
__USE_XOPEN


295 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


296 extern "C++" 
wchar_t
 *
	$wcswcs
 (
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

297 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

298 extern "C++" const 
wchar_t
 *
	$wcswcs
 (const 
wchar_t
 *
__haystack
,

299 const 
wchar_t
 *
__needle
)

300 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

302 extern 
wchar_t
 *
	$wcswcs
 (const 
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

303 
__THROW
 
__attribute_pure__
;

307 #ifdef 
__USE_XOPEN2K8


309 extern 
size_t
 
	$wcsnlen
 (const 
wchar_t
 *
__s
, 
size_t
 
__maxlen
)

310 
__THROW
 
__attribute_pure__
;

314 
__BEGIN_NAMESPACE_STD


316 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


317 extern "C++" 
wchar_t
 *
	$wmemchr
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

319 extern "C++" const 
wchar_t
 *
	$wmemchr
 (const 
wchar_t
 *
__s
, wchar_t 
__c
,

320 
size_t
 
__n
)

321 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

323 extern 
wchar_t
 *
	$wmemchr
 (const 
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

324 
__THROW
 
__attribute_pure__
;

328 extern int 
	$wmemcmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

329 
__THROW
 
__attribute_pure__
;

332 extern 
wchar_t
 *
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
,

333 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

337 extern 
wchar_t
 *
	$wmemmove
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

338 
__THROW
;

341 extern 
wchar_t
 *
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
) 
__THROW
;

342 
__END_NAMESPACE_STD


344 #ifdef 
__USE_GNU


347 extern 
wchar_t
 *
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
,

348 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

349 
__THROW
;

353 
__BEGIN_NAMESPACE_STD


356 extern 
wint_t
 
	$btowc
 (int 
__c
) 
__THROW
;

360 extern int 
	$wctob
 (
wint_t
 
__c
) 
__THROW
;

364 extern int 
	$mbsinit
 (const 
mbstate_t
 *
__ps
) 
__THROW
 
__attribute_pure__
;

368 extern 
size_t
 
	$mbrtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

369 const char *
__restrict
 
__s
, 
size_t
 
__n
,

370 
mbstate_t
 *
__restrict
 
__p
) 
__THROW
;

373 extern 
size_t
 
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wc
,

374 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

377 extern 
size_t
 
	$__mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

378 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

379 extern 
size_t
 
	$mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

380 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

381 
__END_NAMESPACE_STD


383 #ifdef 
__USE_EXTERN_INLINES


389 extern 
wint_t
 
	$__btowc_alias
 (int 
__c
) 
	`__asm
 ("btowc");

390 
__extern_inline
 
wint_t


391 
	`__NTH
 (
	$btowc
 (int 
__c
))

392 { return (
	`__builtin_constant_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

393 ? (
wint_t
) 
__c
 : 
	`__btowc_alias
 (__c)); 
	}
}

395 extern int 
	$__wctob_alias
 (
wint_t
 
__c
) 
	`__asm
 ("wctob");

396 
__extern_inline
 int

397 
	`__NTH
 (
	$wctob
 (
wint_t
 
__wc
))

398 { return (
	`__builtin_constant_p
 (
__wc
) && __wc >= 
L
'\0' && __wc <= L'\x7f'

399 ? (int) 
__wc
 : 
	`__wctob_alias
 (__wc)); 
	}
}

401 
__extern_inline
 
size_t


402 
__NTH
 (
	$mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

403 
mbstate_t
 *
__restrict
 
__ps
))

404 { return (
__ps
 != 
NULL


405 ? 
	`mbrtowc
 (
NULL
, 
__s
, 
__n
, 
__ps
) : 
	`__mbrlen
 (__s, __n, NULL)); 
	}
}

408 
__BEGIN_NAMESPACE_STD


411 extern 
size_t
 
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

412 const char **
__restrict
 
__src
, 
size_t
 
__len
,

413 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

417 extern 
size_t
 
	$wcsrtombs
 (char *
__restrict
 
__dst
,

418 const 
wchar_t
 **
__restrict
 
__src
, 
size_t
 
__len
,

419 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

420 
__END_NAMESPACE_STD


423 #ifdef 
__USE_XOPEN2K8


426 extern 
size_t
 
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

427 const char **
__restrict
 
__src
, 
size_t
 
__nmc
,

428 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

432 extern 
size_t
 
	$wcsnrtombs
 (char *
__restrict
 
__dst
,

433 const 
wchar_t
 **
__restrict
 
__src
,

434 
size_t
 
__nwc
, size_t 
__len
,

435 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

440 #ifdef 
__USE_XOPEN


442 extern int 
	$wcwidth
 (
wchar_t
 
__c
) 
__THROW
;

446 extern int 
	$wcswidth
 (const 
wchar_t
 *
__s
, 
size_t
 
__n
) 
__THROW
;

450 
__BEGIN_NAMESPACE_STD


453 extern double 
	$wcstod
 (const 
wchar_t
 *
__restrict
 
__nptr
,

454 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

455 
__END_NAMESPACE_STD


457 #ifdef 
__USE_ISOC99


458 
__BEGIN_NAMESPACE_C99


460 extern float 
	$wcstof
 (const 
wchar_t
 *
__restrict
 
__nptr
,

461 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

462 extern long double 
	$wcstold
 (const 
wchar_t
 *
__restrict
 
__nptr
,

463 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

464 
__END_NAMESPACE_C99


468 
__BEGIN_NAMESPACE_STD


471 extern long int 
	$wcstol
 (const 
wchar_t
 *
__restrict
 
__nptr
,

472 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

476 extern unsigned long int 
	$wcstoul
 (const 
wchar_t
 *
__restrict
 
__nptr
,

477 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

478 
__THROW
;

479 
__END_NAMESPACE_STD


481 #ifdef 
__USE_ISOC99


482 
__BEGIN_NAMESPACE_C99


485 
__extension__


486 extern long long int 
	$wcstoll
 (const 
wchar_t
 *
__restrict
 
__nptr
,

487 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

488 
__THROW
;

492 
__extension__


493 extern unsigned long long int 
	$wcstoull
 (const 
wchar_t
 *
__restrict
 
__nptr
,

494 
wchar_t
 **
__restrict
 
__endptr
,

495 int 
__base
) 
__THROW
;

496 
__END_NAMESPACE_C99


499 #ifdef 
__USE_GNU


502 
__extension__


503 extern long long int 
	$wcstoq
 (const 
wchar_t
 *
__restrict
 
__nptr
,

504 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

505 
__THROW
;

509 
__extension__


510 extern unsigned long long int 
	$wcstouq
 (const 
wchar_t
 *
__restrict
 
__nptr
,

511 
wchar_t
 **
__restrict
 
__endptr
,

512 int 
__base
) 
__THROW
;

515 #ifdef 
__USE_GNU


529 #include 
	~<xlocale.h
>

533 extern long int 
	$wcstol_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

534 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
,

535 
__locale_t
 
__loc
) 
__THROW
;

537 extern unsigned long int 
	$wcstoul_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

538 
wchar_t
 **
__restrict
 
__endptr
,

539 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

541 
__extension__


542 extern long long int 
	$wcstoll_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

543 
wchar_t
 **
__restrict
 
__endptr
,

544 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

546 
__extension__


547 extern unsigned long long int 
	$wcstoull_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

548 
wchar_t
 **
__restrict
 
__endptr
,

549 int 
__base
, 
__locale_t
 
__loc
)

550 
__THROW
;

552 extern double 
	$wcstod_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

553 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

554 
__THROW
;

556 extern float 
	$wcstof_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

557 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

558 
__THROW
;

560 extern long double 
	$wcstold_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

561 
wchar_t
 **
__restrict
 
__endptr
,

562 
__locale_t
 
__loc
) 
__THROW
;

566 #ifdef 
__USE_XOPEN2K8


569 extern 
wchar_t
 *
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
,

570 const 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

574 extern 
wchar_t
 *
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
,

575 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

576 
__THROW
;

583 extern 
__FILE
 *
	$open_wmemstream
 (
wchar_t
 **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
;

586 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


587 
__BEGIN_NAMESPACE_STD


590 extern int 
	$fwide
 (
__FILE
 *
__fp
, int 
__mode
) 
__THROW
;

597 extern int 
	`fwprintf
 (
__FILE
 *
__restrict
 
__stream
,

598 const 
wchar_t
 *
__restrict
 
__format
, ...)

604 extern int 
	`wprintf
 (const 
wchar_t
 *
__restrict
 
__format
, ...)

607 extern int 
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

608 const 
wchar_t
 *
__restrict
 
__format
, ...)

609 
__THROW
 ;

615 extern int 
	`vfwprintf
 (
__FILE
 *
__restrict
 
__s
,

616 const 
wchar_t
 *
__restrict
 
__format
,

617 
__gnuc_va_list
 
__arg
)

623 extern int 
	`vwprintf
 (const 
wchar_t
 *
__restrict
 
__format
,

624 
__gnuc_va_list
 
__arg
)

628 extern int 
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

629 const 
wchar_t
 *
__restrict
 
__format
,

630 
__gnuc_va_list
 
__arg
)

631 
__THROW
 ;

638 extern int 
	`fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

639 const 
wchar_t
 *
__restrict
 
__format
, ...)

645 extern int 
	`wscanf
 (const 
wchar_t
 *
__restrict
 
__format
, ...)

648 extern int 
	$swscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

649 const 
wchar_t
 *
__restrict
 
__format
, ...)

650 
__THROW
 ;

652 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

653 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

654 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

655 #ifdef 
__REDIRECT


659 extern int 
	`__REDIRECT
 (
fwscanf
, (
__FILE
 *
__restrict
 
__stream
,

660 const 
wchar_t
 *
__restrict
 
__format
, ...),

661 
__isoc99_fwscanf
)

663 extern int 
	`__REDIRECT
 (
wscanf
, (const 
wchar_t
 *
__restrict
 
__format
, ...),

664 
__isoc99_wscanf
)

666 extern int 
	`__REDIRECT_NTH
 (
swscanf
, (const 
wchar_t
 *
__restrict
 
__s
,

667 const 
wchar_t
 *
__restrict
 
__format
,

668 ...), 
__isoc99_swscanf
)

671 extern int 
	`__isoc99_fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

672 const 
wchar_t
 *
__restrict
 
__format
, ...);

673 extern int 
	`__isoc99_wscanf
 (const 
wchar_t
 *
__restrict
 
__format
, ...);

674 extern int 
	$__isoc99_swscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

675 const 
wchar_t
 *
__restrict
 
__format
, ...)

676 
__THROW
;

677 #define 
	#fwscanf
 
__isoc99_fwscanf


	)

678 #define 
	#wscanf
 
__isoc99_wscanf


	)

679 #define 
	#swscanf
 
__isoc99_swscanf


	)

683 
__END_NAMESPACE_STD


686 #ifdef 
__USE_ISOC99


687 
__BEGIN_NAMESPACE_C99


692 extern int 
	`vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

693 const 
wchar_t
 *
__restrict
 
__format
,

694 
__gnuc_va_list
 
__arg
)

700 extern int 
	`vwscanf
 (const 
wchar_t
 *
__restrict
 
__format
,

701 
__gnuc_va_list
 
__arg
)

704 extern int 
	$vswscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

705 const 
wchar_t
 *
__restrict
 
__format
,

706 
__gnuc_va_list
 
__arg
)

707 
__THROW
 ;

709 #if !
defined
 
__USE_GNU
 \

710 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

711 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

712 #ifdef 
__REDIRECT


713 extern int 
	`__REDIRECT
 (
vfwscanf
, (
__FILE
 *
__restrict
 
__s
,

714 const 
wchar_t
 *
__restrict
 
__format
,

715 
__gnuc_va_list
 
__arg
), 
__isoc99_vfwscanf
)

717 extern int 
	`__REDIRECT
 (
vwscanf
, (const 
wchar_t
 *
__restrict
 
__format
,

718 
__gnuc_va_list
 
__arg
), 
__isoc99_vwscanf
)

720 extern int 
	`__REDIRECT_NTH
 (
vswscanf
, (const 
wchar_t
 *
__restrict
 
__s
,

721 const 
wchar_t
 *
__restrict
 
__format
,

722 
__gnuc_va_list
 
__arg
), 
__isoc99_vswscanf
)

725 extern int 
	`__isoc99_vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

726 const 
wchar_t
 *
__restrict
 
__format
,

727 
__gnuc_va_list
 
__arg
);

728 extern int 
	`__isoc99_vwscanf
 (const 
wchar_t
 *
__restrict
 
__format
,

729 
__gnuc_va_list
 
__arg
);

730 extern int 
	$__isoc99_vswscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

731 const 
wchar_t
 *
__restrict
 
__format
,

732 
__gnuc_va_list
 
__arg
) 
__THROW
;

733 #define 
	#vfwscanf
 
__isoc99_vfwscanf


	)

734 #define 
	#vwscanf
 
__isoc99_vwscanf


	)

735 #define 
	#vswscanf
 
__isoc99_vswscanf


	)

739 
__END_NAMESPACE_C99


743 
__BEGIN_NAMESPACE_STD


748 extern 
wint_t
 
	`fgetwc
 (
__FILE
 *
__stream
);

749 extern 
wint_t
 
	`getwc
 (
__FILE
 *
__stream
);

755 extern 
wint_t
 
	`getwchar
 (void);

762 extern 
wint_t
 
	`fputwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

763 extern 
wint_t
 
	`putwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

769 extern 
wint_t
 
	`putwchar
 (
wchar_t
 
__wc
);

777 extern 
wchar_t
 *
	`fgetws
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

778 
__FILE
 *
__restrict
 
__stream
);

784 extern int 
	`fputws
 (const 
wchar_t
 *
__restrict
 
__ws
,

785 
__FILE
 *
__restrict
 
__stream
);

792 extern 
wint_t
 
	`ungetwc
 (wint_t 
__wc
, 
__FILE
 *
__stream
);

793 
__END_NAMESPACE_STD


796 #ifdef 
__USE_GNU


804 extern 
wint_t
 
	`getwc_unlocked
 (
__FILE
 *
__stream
);

805 extern 
wint_t
 
	`getwchar_unlocked
 (void);

813 extern 
wint_t
 
	`fgetwc_unlocked
 (
__FILE
 *
__stream
);

821 extern 
wint_t
 
	`fputwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

830 extern 
wint_t
 
	`putwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

831 extern 
wint_t
 
	`putwchar_unlocked
 (
wchar_t
 
__wc
);

840 extern 
wchar_t
 *
	`fgetws_unlocked
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

841 
__FILE
 *
__restrict
 
__stream
);

849 extern int 
	`fputws_unlocked
 (const 
wchar_t
 *
__restrict
 
__ws
,

850 
__FILE
 *
__restrict
 
__stream
);

854 
__BEGIN_NAMESPACE_C99


858 extern 
size_t
 
	$wcsftime
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

859 const 
wchar_t
 *
__restrict
 
__format
,

860 const struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

861 
__END_NAMESPACE_C99


863 #ifdef 
__USE_GNU


864 #include 
	~<xlocale.h
>

868 extern 
size_t
 
	$wcsftime_l
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

869 const 
wchar_t
 *
__restrict
 
__format
,

870 const struct 
tm
 *
__restrict
 
__tp
,

871 
__locale_t
 
__loc
) 
__THROW
;

880 #if 
defined
 
__USE_UNIX98
 && !defined 
__USE_GNU


881 #define 
	#__need_iswxxx


	)

882 #include 
	~<wctype.h
>

886 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


887 #include 
	~<bits/wchar2.h
>

890 #ifdef 
__LDBL_COMPAT


891 #include 
	~<bits/wchar-ldbl.h
>

894 
__END_DECLS


902 #undef 
__need_mbstate_t


903 #undef 
__need_wint_t


	@/usr/include/wctype.h

23 #ifndef 
_WCTYPE_H


25 #include 
	~<features.h
>

26 #include 
	~<bits/types.h
>

28 #ifndef 
__need_iswxxx


29 #define 
	#_WCTYPE_H
 1

	)

32 #define 
	#__need_wint_t


	)

33 #include 
	~<wchar.h
>

37 #ifndef 
WEOF


38 #define 
	#WEOF
 (0xffffffffu)

	)

41 #undef 
__need_iswxxx


46 #ifndef 
__iswxxx_defined


47 #define 
	#__iswxxx_defined
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 typedef unsigned long int 
	twctype_t
;

53 
	g__END_NAMESPACE_C99


55 #ifndef 
_ISwbit


60 #include 
	~<endian.h
>

61 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


62 #define 
	#_ISwbit
(
bit
) (1 << (bit))

	)

64 #define 
	#_ISwbit
(
bit
) \

65 ((
bit
) < 8 ? (int) ((1UL << (bit)) << 24) \

66 : ((
bit
) < 16 ? (int) ((1UL << (bit)) << 8) \

67 : ((
bit
) < 24 ? (int) ((1UL << (bit)) >> 8) \

68 : (int) ((1UL << (
bit
)) >> 24))))

	)

73 
	m__ISwupper
 = 0,

74 
	m__ISwlower
 = 1,

75 
	m__ISwalpha
 = 2,

76 
	m__ISwdigit
 = 3,

77 
	m__ISwxdigit
 = 4,

78 
	m__ISwspace
 = 5,

79 
	m__ISwprint
 = 6,

80 
	m__ISwgraph
 = 7,

81 
	m__ISwblank
 = 8,

82 
	m__ISwcntrl
 = 9,

83 
	m__ISwpunct
 = 10,

84 
	m__ISwalnum
 = 11,

86 
	m_ISwupper
 = 
_ISwbit
 (
__ISwupper
),

87 
	m_ISwlower
 = 
_ISwbit
 (
__ISwlower
),

88 
	m_ISwalpha
 = 
_ISwbit
 (
__ISwalpha
),

89 
	m_ISwdigit
 = 
_ISwbit
 (
__ISwdigit
),

90 
	m_ISwxdigit
 = 
_ISwbit
 (
__ISwxdigit
),

91 
	m_ISwspace
 = 
_ISwbit
 (
__ISwspace
),

92 
	m_ISwprint
 = 
_ISwbit
 (
__ISwprint
),

93 
	m_ISwgraph
 = 
_ISwbit
 (
__ISwgraph
),

94 
	m_ISwblank
 = 
_ISwbit
 (
__ISwblank
),

95 
	m_ISwcntrl
 = 
_ISwbit
 (
__ISwcntrl
),

96 
	m_ISwpunct
 = 
_ISwbit
 (
__ISwpunct
),

97 
	m_ISwalnum
 = 
_ISwbit
 (
__ISwalnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 extern int 
	$iswalnum
 (
wint_t
 
__wc
) 
__THROW
;

117 extern int 
	$iswalpha
 (
wint_t
 
__wc
) 
__THROW
;

120 extern int 
	$iswcntrl
 (
wint_t
 
__wc
) 
__THROW
;

124 extern int 
	$iswdigit
 (
wint_t
 
__wc
) 
__THROW
;

128 extern int 
	$iswgraph
 (
wint_t
 
__wc
) 
__THROW
;

133 extern int 
	$iswlower
 (
wint_t
 
__wc
) 
__THROW
;

136 extern int 
	$iswprint
 (
wint_t
 
__wc
) 
__THROW
;

141 extern int 
	$iswpunct
 (
wint_t
 
__wc
) 
__THROW
;

146 extern int 
	$iswspace
 (
wint_t
 
__wc
) 
__THROW
;

151 extern int 
	$iswupper
 (
wint_t
 
__wc
) 
__THROW
;

156 extern int 
	$iswxdigit
 (
wint_t
 
__wc
) 
__THROW
;

161 #ifdef 
__USE_ISOC99


162 extern int 
	$iswblank
 (
wint_t
 
__wc
) 
__THROW
;

171 extern 
wctype_t
 
	$wctype
 (const char *
__property
) 
__THROW
;

175 extern int 
	$iswctype
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
) 
__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 typedef const 
	t__int32_t
 *
	twctrans_t
;

187 
__END_NAMESPACE_C99


188 #ifdef 
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wctrans_t
)

192 
__BEGIN_NAMESPACE_C99


194 extern 
wint_t
 
	$towlower
 (
wint_t
 
__wc
) 
__THROW
;

197 extern 
wint_t
 
	$towupper
 (
wint_t
 
__wc
) 
__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifdef 
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 extern 
wctrans_t
 
	$wctrans
 (const char *
__property
) 
__THROW
;

221 extern 
wint_t
 
	$towctrans
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
) 
__THROW
;

222 
__END_NAMESPACE_C99


224 #ifdef 
__USE_XOPEN2K8


226 #include 
	~<xlocale.h
>

230 extern int 
	$iswalnum_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

236 extern int 
	$iswalpha_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

239 extern int 
	$iswcntrl_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

243 extern int 
	$iswdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

247 extern int 
	$iswgraph_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

252 extern int 
	$iswlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

255 extern int 
	$iswprint_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

260 extern int 
	$iswpunct_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

265 extern int 
	$iswspace_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

270 extern int 
	$iswupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

275 extern int 
	$iswxdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

280 extern int 
	$iswblank_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

284 extern 
wctype_t
 
	$wctype_l
 (const char *
__property
, 
__locale_t
 
__locale
)

285 
__THROW
;

289 extern int 
	$iswctype_l
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
, 
__locale_t
 
__locale
)

290 
__THROW
;

298 extern 
wint_t
 
	$towlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

301 extern 
wint_t
 
	$towupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

305 extern 
wctrans_t
 
	$wctrans_l
 (const char *
__property
, 
__locale_t
 
__locale
)

306 
__THROW
;

309 extern 
wint_t
 
	$towctrans_l
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
,

310 
__locale_t
 
__locale
) 
__THROW
;

314 
__END_DECLS


	@
1
.
1
/usr/include
32
724
Assignment1/lexical_hardcoded.cpp
Assignment1/lexical_hardcoded.hpp
Assignment2/lexical_parser.cpp
Assignment2/lexical_parser.hpp
Assignment3/a/lex.c
Assignment3/lex.yy.c
Assignment3/lexical.hpp
Pyth/ncl1701.py
Pyth/neO01.py
Pyth/sumq.py
Pyth/unionset.py
lexical_hardcoded.cpp
lexical_hardcoded.hpp
/usr/include/ctype.h
/usr/include/errno.h
/usr/include/inttypes.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/unistd.h
/usr/include/alloca.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/stdint.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/stdc-predef.h
/usr/include/gconv.h
/usr/include/wchar.h
/usr/include/wctype.h
